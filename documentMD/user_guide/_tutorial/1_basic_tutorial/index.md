---
title: チュートリアル 基礎編
lang: ja
permalink: /tutorial/1_basic_tutorial/
---

本チュートリアルでは、WHEELの基本的な機能のみを使ってワークフローを作成・実行することでWHEELの使い方を学んでいきます。

### 1. 新規プロジェクトの作成
WHEELでは、1つのワークフローの実行単位のことを __プロジェクト__ と呼びます。
プロジェクトの中には、実際にプログラムを実行する __タスクコンポーネント__ を1つ以上作成し
これらの間で入出力ファイルをやりとりしたり、実行順序を制御することで1つのワークフローを構成します。

まず初めに空のプロジェクトを作成しましょう。

#### ブラウザを起動して home 画面へアクセス
ブラウザを起動して、WHEELサーバへ接続するとhome画面が表示されます。
画面左上に表示されている __NEW__ ボタンをクリックしてください。

![img](./img/home_screen.png "Home画面")


ディレクトリツリーが表示されるので、必要に応じて新規プロジェクトを作成するディレクトリ(1)を選択します。
プロジェクト名(2)を入力して __CREATE__ ボタン(3)をクリックしてください。
![img](./img/new_project.png "新規プロジェクト名入力ダイアログ")

プロジェクト名はディレクトリ名の一部として使われるため、アルファベット・数字および一部の記号のみしか使えません。

#### プロジェクトを開く
新しく作成したプロジェクトが一覧の中に表示されるので、プロジェクト名の左側にあるチェックボックス(1)にチェックを入れて、 __OPEN__ ボタン(2)をクリックしてください。
![img](./img/home_screen2.png "Home画面2")

画面が遷移して、ワークフロー画面が表示されます。


### 2. 最初のコンポーネントの追加
ワークフロー画面では、画面左側にあるパレットからワークフローの部品である __コンポーネント__ を
ドラッグ&ドロップすることでワークフローを作成します。

ここでは、設定されたプログラムを実行する __Taskコンポーネント__ を1つプロジェクトに追加してみましょう。

#### Taskコンポーネントの追加
まずはじめにTaskコンポーネント(1)をドラッグして、画面中央の黒い部分(2)にドロップしてください。
![img](./img/workflow.png "ワークフロー画面")

これで、プロジェクトに1つ目のコンポーネントが追加されました。
![img](./img/workflow2.png "Taskコンポーネント追加後の画面")


続けてこのTaskコンポーネントの中で実行する処理を定義します。

### 3. Taskコンポーネントのプロパティ設定
Taskコンポーネントを含む全てのコンポーネントは、動作を規定する __プロパティ__ を設定することで
初めてワークフローの部品として機能するようになります。
Taskコンポーネントでは、実行したいプログラムを直接指定するのではなく、
そのプログラムを呼び出すbashスクリプトを作成し、実行したいスクリプトを指定する必要があります。

ここではサンプルとして、echoコマンドを呼び出すだけの単純なシェルスクリプトを作成して実行します。

#### シェルスクリプトの作成
さきほど作成した、__task0__ コンポーネント(1)をクリックすると画面右側にプロパティを設定するためのサブ画面(2)が表示されます。

![img](./img/property_screen.png "プロパティ画面")

プロパティ画面上で下にスクロールすると、最下段に __Files__ と書かれた行(1)があります。

![img](./img/property_screen2.png "ファイルエリア-close")

この行をクリックすると、ファイル操作エリアが下側に展開されます。
シェルスクリプトの元となる空ファイルを作成するために、__new file__ ボタン(1)をクリックしてください。

![img](./img/property_screen3.png "ファイルエリア-open")


ファイル名を入力するダイアログが表示されるので、作成するシェルスクリプトの名前(1)を入力し、
__OK__ ボタン(2)をクリックしてください。

![img](./img/newfile_dialog.png "新規作成ファイル名入力")

正常にファイルが作成できたら、ファイル操作エリアの下にファイル名(1)が表示されるのでクリックして選択してください。
ワークフロー画面左上の __text editor__ ボタン(2)をクリックすることで、このファイルを編集することができます。

![img](./img/workflow3.png "スクリプトファイル選択")

ここでは、数値計算プログラムを実行する代わりに、echoコマンドを用いて文字列を出力するシェルスクリプトを作成して実行します。
テキストエディタ部分(1)に `echo Hello WHEEL` と入力して画面右上の __SAVE ALL FILES__ ボタン(2)をクリックします。
最後に画面左上の __graph view__ ボタン(3)をクリックして元の画面に戻ってください。

![img](./img/text_editor.png "スクリプト編集")

#### 実行スクリプトの指定
プロパティサブ画面を表示し、__script__ ドロップダウンリスト(1)から、
先ほど作成したスクリプトファイルを選択してください。

![img](./img/property_screen4.png "スクリプト指定")

最後に、画面右上の __save project__ ボタン(1)をクリックして作成したプロジェクトをsaveしましょう。
<!--__revert project__ ボタン(2)をクリックすると、直前にsaveした状態まで巻き戻すことができますが
redo(元に戻す処理を取り止めること)はできませんので、注意してください。-->

![img](./img/workflow4.png "save および revert")

__save処理について__  
WHEELでは、プロジェクトファイルの管理にgitを使っています。  
__save project__ ボタンをクリックしたタイミングで、save処理としてgitリポジトリにコミットされます。
{: .notice--info}

__revert project ボタンについて__  
__revert project__ ボタン(2)をクリックすると、直前にsaveした状態まで巻き戻すことができます。  
ただし、redo(元に戻す処理を取り止めること)はできませんので、ご注意ください。
{: .notice--info}

### 4. プロジェクトの実行
続いて、作成したプロジェクトを実行してみましょう。
__run project__ ボタン(1)をクリックすると、プロジェクトが実行されます。

![img](./img/workflow5.png "run project")

今回のプロジェクトでは、`echo`コマンドを使っているので、標準出力に文字が表示されます。
画面下部の▽ ボタン(2)をクリックすると、WHEELのログ出力や、プロジェクト内で実行したコマンドの
標準出力、標準エラー出力を表示するログ画面が表示されます。

ログ画面を開いた直後は __INFO__ タブが表示されていて、WHEELのログ出力が確認できます。
標準出力に未読の出力がある時は、 __STDOUT__ タブ(1)が緑色になります。このタブをクリックすると、echoコマンドの出力が確認できます。

![img](./img/log_screen.png "ログ表示")

プロジェクトの実行が終了すると、画面上部のステータス表示が __FINISHED__ に変わります。もしプロジェクト内で実行したプログラムが正常に終了しなかった時は、 __FAILED__ となります。

![img](./img/project_state.png "プロジェクトのステータス")

### 5. プロジェクトの初期化
プログラムによっては、実行後にファイルが出力されていたり、既存のファイルが書き換えられていることがあります。
また、WHEELはプロジェクト内の個々のコンポーネントの実行状態を管理しているため、
プロジェクトの修正をしたり、再実行する時には一度実行開始前の状態に戻す必要があります。

本チュートリアルでは、この後プロジェクトに修正を加えながら何回か再実行していくので
画面上部にある __cleanup project__ ボタンをクリックして、実行開始前の状態に戻してください。

![img](./img/clean_button.png "cleanボタン")


### 6. リモートホスト上でのタスクの実行
先ほどのタスクをリモートホストで実行してみましょう。

task0コンポーネントをクリックしプロパティ画面を表示します。
__host__ ドロップダウンリストとをクリックすると、[リモートホスト設定]({{ site.baseurl }}/how_to_boot/#リモートホスト設定)で設定されたリモートホストの一覧が表示されるので、
使用するリモートホストのラベルを選択してください。

![img](./img/select_host.png "リモートホスト設定")

__save project__ ボタン(1)をクリックすると準備完了です。
ローカルホストで実行した時と同じく、 __run project__ ボタン(2)をクリックするとプロジェクトの実行が始まります。

![img](./img/save_run_project.png "プロジェクトの実行")

今回はリモートホストを指定しているので、リモートホストに接続するためのパスワードを入力するダイアログが表示されます。
パスワード認証での接続の場合はパスワードを、公開鍵認証での接続の場合は
秘密鍵に設定したパスフレーズを入力して __OK__ ボタンをクリックしてください。

![img](./img/password_dialog.png "パスワード入力ダイアログ")

ログ画面を開くと、実行終了時に __STDOUT(SSH)__ タブにechoコマンドの出力が表示されています。

![img](./img/stdout_ssh.png "STDOUT(SSH)")

出力内容を確認したら、__cleanup project__ ボタンをクリックしてプロジェクトを初期化してください。

![img](./img/clean_button.png "cleanボタン")


### 7. バッチシステム経由でのタスクの実行
次は、同じ内容のワークフローをバッチシステム経由で実行してみます。

__バッチシステム経由でタスクを実行するための事前準備について__   
バッチシステム経由でタスクを実行する場合は、事前に[バッチシステムがある場合の追加設定]({{ site.baseurl }}/how_to_boot/#バッチシステムがある場合の追加設定)に従いリモートホスト設定が実施されている必要があります。
{: .notice--info}


再度task0のプロパティ画面を表示してください。

バッチシステムを介してジョブを実行すると、標準出力の内容を取得する方法がシステムによって異なるので、
先ほどのスクリプトを変更して、 `stdout.txt` というファイルにechoコマンドの結果を出力するように変更しましょう。

プロパティ画面下部のFiles から [3. Taskコンポーネントのプロパティ設定](#3-taskコンポーネントのプロパティ設定)
で作成したスクリプトを選択し、テキストエディタで開いてください。

echoコマンドの行末に追記して `echo Hello WHEEL > stdout.txt` と変更してください。

![img](./img/text_editor2.png "スクリプト変更")

1回目のスクリプト作成時は、 __SAVE ALL FILES__ ボタンをクリックしてファイルを保存しましたが、
今回は別の方法で保存してみましょう。

ファイル名が書かれたタブ部分をクリックすると、__save__、__close without save__ という2つのメニューが表示されます。

ここでは、 __save__ を選択してください。

![img](./img/text_editor3.png "ファイル毎の保存メニュー")

__ファイル編集の破棄方法__  
ファイルの編集を破棄したい場合は、__close without save__ ボタンを利用します。  
__close without save__ ボタンをクリックすると、編集したテキストが破棄されてタブが閉じられます。
{: .notice--info}

{% capture notice-save %}
__一部のファイルのみを保存する方法__  
複数ファイルを開いて編集し、一部のファイルのみを保存したい場合は以下の手順で保存します。  
1. __close without save__ ボタンをクリックし、不要なファイル編集を破棄します。  
1. __SAVE ALL FILES__ ボタンで一括保存(または、 __save__ ボタンにて必要なファイルを個別に保存)します。
{% endcapture %}
<div class="notice--info">
  {{ notice-save | markdownify }}
</div>

スクリプトの編集が終わったらグラフビュー画面に戻って、再びtask0のプロパティを編集します。

まず、__use job scheduler__ スイッチ(1)を有効にしてください。
ジョブに関する設定を入力できるようになるので __queue__ (2) の欄から投入先のキューを選択してください。

![img](./img/use_job_scheduler.png "バッチ使用設定")

続いて、スクリプトが出力する __stdout.txt__ をダウンロードする設定を追加します。
プロパティ画面の最上部にある __basic__ の右にある上向き矢印をクリックしてください。

![img](./img/property_screen5.png "property折り畳み")

上段の設定項目が折り畳まれて、全てのカテゴリが表示されるので、__remote file setting__ を
クリックして開いてください。

![img](./img/property_screen6.png "remote file setting")

includeの欄(1)に __stdout.txt__ と入力してEnterキーを押すか、
右にある __+__ ボタン(2)をクリックしてください。

![img](./img/property_screen7.png "include設定")

設定が終了したら、プロジェクトをsaveして実行してください。

実行終了後に、task0コンポーネントのプロパティから、 __stdout.txt__ を選択して
テキストエディタを立ち上げてください。

![img](./img/job_result.png "ジョブ実行結果確認")

echoコマンドの実行結果がファイルに出力されています。

![img](./img/job_result2.png "ジョブ実行結果出力")

以上でバッチシステム経由でのタスク実行は終了です。  
次のチュートリアルのために __cleanup project__ ボタンをクリックしてプロジェクトを初期化してください。

<!--### 9. 入出力ファイルの受け渡し-->
### 8. 入出力ファイルの受け渡し
これまでは、タスクが1つしか無いワークフローを実行してきましたが
実際のワークフローでは、先行するプログラムが出力したファイルを
別のプログラムに渡して処理を行なうことがよくあります。

ここでは、WHEELのタスクコンポーネント間でファイルを受け渡す方法について学びましょう。

まず、ワークフローに2つ目のタスクを追加してください。
最初のタスクの名前をデフォルトのtask0から変更していない場合、task1という名前のタスクが作成されます。

![img](./img/workflow7.png "2つ目のタスク")

次に、task0が実行結果として __stdout.txt__ というファイルを出力することを指定します。
task0のプロパティ画面を開いて下にスクロールすると、 __input/output files__ という行があります。
これをクリックして入力欄を表示し、__output files__ に __stdout.txt__ と入力してください。

![img](./img/output_files.png "output file設定 入力")

task0コンポーネントの右下に __stdout.txt__ という表示が追加されます。

![img](./img/output_files2.png "output file設定 GUI")

この右にある▶をドラッグすると線が伸びていくので、task1の上にドロップしてください。

![img](./img/file_dependency.png "file依存性設定")


これで、task0が出力する __stdout.txt__ を受けとってtask1を実行するという設定ができました。

実際には、まだtask1は未設定ですので、最初のタスクの時と同様に空ファイルを作成して
スクリプトを作りましょう。

スクリプトの内容は、
```
ls -l stdout.txt
```
として、task0からファイルが渡ってきたか確認できるようにしてください。
また、scriptプロパティに作成したスクリプトファイルを指定してください。

プロジェクトをsaveして実行すると、ログ出力に次のような出力が見えます。

![img](./img/file_dependency_log.png "outputFileを含むプロジェクトのログ出力")

この結果から分かるように、output filesに指定されたファイルは、後続のコンポーネントに
シンボリックリンクとして渡されます。

実際には、以下のような使い方が考えられます。
* 先行するタスクでソルバを実行し、実行結果ファイルを後続のポスト処理コンポーネントに渡す
* 先行するタスクでプリ処理を実行し、入力ファイルを後続のソルバコンポーネントに渡す


この時、前後のコンポーネントで実行するホストが違っていても、WHEELが自動的にダウンロードして転送します。
そのため、ライセンスや、計算機アーキテクチャの都合でそれぞれの処理を別のシステムで実行しても、
同様のワークフローで実行することができます。


以上でコンポーネント間のファイルの受け渡し方法のチュートリアルは終了です。  
次のチュートリアルのために __cleanup project__ ボタンをクリックしてプロジェクトを初期化してください。


<!--### 10. タスク実行順の制御-->
### 9. タスク実行順の制御
前の章では、先行するコンポーネントが出力したファイル受け取ってから、後続のコンポーネントを実行しました。

実際のワークフローでは、ファイルの受け渡しは発生しないが、
あるプログラムが終わってから、次のプログラムを実行する必要がある
という状況があります。

WHEELには、先行コンポーネントの終了を待ってから実行する機能があるので
この機能を使って2つのタスクの実行順を制御してみましょう。

#### タスク内容の変更
先ほどの、task0, task1の内容ではどちらが先に実行されたのか分かり難いので
それぞれのスクリプトを次のように変更してください。

task0
```
sleep 10
echo task0
```

task1
```
echo task1
```

また、リモートホストでの実行待ちなどが発生するのを避けるために、 __host__ を
__localhost__ に変更してローカル環境で実行するように設定してください。

続いて、stdout.txtは今回は使わないので、output filesの設定を削除します。

まず、 __task0__ のプロパティ画面を開いて __input/output files__ の
設定欄を表示させ、 __stdout.txt__ の右にあるゴミ箱アイコンをクリックしてください。

![img](./img/output_files3.png "outputFileの削除")

__output files__ から __stdout.txt__ が削除され、task1の __stdout.txt__ と接続された線も削除されます。

![img](./img/output_files4.png "outputFile削除後のワークフロー")

task1のinput files には、__stdout.txt__ の指定が残っていますが、これも同様の操作で削除することができます。  
なお、線で結ばれていない input/output files の指定はワークフローの動作には影響しませんので、
一時的に変更する場合などは、使わない設定を残したままでも問題ありません。

この状態で、一旦saveしてワークフローを実行してみましょう。
今は実行順の制御を行なっていないので、task0とtask1は順不同で実行されます。
ログ画面の __STDOUT__ タブを見るとtask1は実行開始直後に表示され
task0の方はsleep10 が入っているので10秒後に表示されるはずです。

![img](./img/log_screen3.png "実行順未指定時のログ")

では、一回プロジェクトを初期化して、task0が先に実行されるようにしてみましょう。

task0コンポーネントの下部にある▼(1)をドラッグして、task1コンポーネントの上部にある■(2)にドロップしてください。
両taskが緑の線で接続されます。

![img](./img/workflow8.png "実行順指定後のワークフロー")

これで、task0の実行が終了してからtask1が実行されるようになりました。

では、プロジェクトをsaveして実行してみましょう。

ログ出力を見ると今度はtask0が表示されてからtask1が表示されているはずです。


![img](./img/log_screen4.png "実行順指定時のログ")


これで基本編のチュートリアルは終了です。

本チュートリアルでは扱わなかったWHEELの高度な機能について知りたい方は
[応用編チュートリアル]({{ site.baseurl }}/tutorial/2_advanced_tutorial/) に進んでください。

また、個々の機能の詳細な内容については、[リファレンスマニュアル]({{ site.baseurl }}/reference/) をご参照ください。


--------
[利用者向けのトップページに戻る]({{ site.baseurl }}/tutorial/)
