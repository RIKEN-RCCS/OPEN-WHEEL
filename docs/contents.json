{
  "paths": [
    {
      "type": "file",
      "value": "index.md"
    },
    {
      "type": "dir",
      "name": "1_how_to_boot",
      "children": [
        {
          "type": "file",
          "value": "1_how_to_boot/index.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "2_tutorial",
      "children": [
        {
          "type": "dir",
          "name": "1_basic_tutorial",
          "children": [
            {
              "type": "file",
              "value": "2_tutorial/1_basic_tutorial/index.md"
            }
          ]
        },
        {
          "type": "dir",
          "name": "2_advanced_tutorial",
          "children": [
            {
              "type": "file",
              "value": "2_tutorial/2_advanced_tutorial/index.md"
            }
          ]
        },
        {
          "type": "dir",
          "name": "3_application_tutorial",
          "children": [
            {
              "type": "dir",
              "name": "1_OpenFOAM_cavity",
              "children": [
                {
                  "type": "file",
                  "value": "2_tutorial/3_application_tutorial/1_OpenFOAM_cavity/index.md"
                }
              ]
            },
            {
              "type": "dir",
              "name": "2_OpenFOAM_PS",
              "children": [
                {
                  "type": "file",
                  "value": "2_tutorial/3_application_tutorial/2_OpenFOAM_PS/index.md"
                }
              ]
            },
            {
              "type": "dir",
              "name": "3_TensorFlow_mnist",
              "children": [
                {
                  "type": "file",
                  "value": "2_tutorial/3_application_tutorial/3_TensorFlow_mnist/index.md"
                }
              ]
            },
            {
              "type": "file",
              "value": "2_tutorial/3_application_tutorial/index.md"
            }
          ]
        },
        {
          "type": "file",
          "value": "2_tutorial/index.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "3_reference_manual",
      "children": [
        {
          "type": "dir",
          "name": "1_home_screen",
          "children": [
            {
              "type": "file",
              "value": "3_reference_manual/1_home_screen/index.md"
            }
          ]
        },
        {
          "type": "dir",
          "name": "2_remotehost_screen",
          "children": [
            {
              "type": "file",
              "value": "3_reference_manual/2_remotehost_screen/index.md"
            }
          ]
        },
        {
          "type": "dir",
          "name": "3_workflow_screen",
          "children": [
            {
              "type": "file",
              "value": "3_reference_manual/3_workflow_screen/1_graphview.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/3_workflow_screen/2_listview.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/3_workflow_screen/3_editor.md"
            }
          ]
        },
        {
          "type": "dir",
          "name": "4_component",
          "children": [
            {
              "type": "file",
              "value": "3_reference_manual/4_component/00_common.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/4_component/01_Task.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/4_component/02_If.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/4_component/03_For.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/4_component/04_while.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/4_component/05_Foreach.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/4_component/06_PS.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/4_component/07_Workflow.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/4_component/08_Storage.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/4_component/09_Source.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/4_component/10_Viewer.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/4_component/11_Stepjob.md"
            },
            {
              "type": "file",
              "value": "3_reference_manual/4_component/12_BulkjobTask.md"
            }
          ]
        },
        {
          "type": "file",
          "value": "3_reference_manual/index.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "4_ATTENTION",
      "children": [
        {
          "type": "file",
          "value": "4_ATTENTION/index.md"
        }
      ]
    }
  ],
  "contents": [
    {
      "path": "index.md",
      "url": "index.html",
      "content": "# WHEEL　ユーザーガイド\n本ユーザガイドは次の3部構成となっています。\n\n[WHEEL起動手順書](1_how_to_boot/index.md )\n\n[WHEEL チュートリアル](2_tutorial/index.md)\n\n[WHEELリファレンスマニュアル](3_reference_manual/index.md)\n\n\n### 制約事項\nWHEELは開発中のソフトウェアであり、いくつかの制約事項が残っています。\nこれらは次のページにまとまっていますのでご一読ください。\n\n[WHEEL制約事項](4_ATTENTION/index.md)\n",
      "html": "<h1 id=\"wheel-%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%82%AC%E3%82%A4%E3%83%89\">WHEEL　ユーザーガイド <a class=\"heading-anchor-permalink\" href=\"#wheel-%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%82%AC%E3%82%A4%E3%83%89\">#</a></h1>\n<p>本ユーザガイドは次の3部構成となっています。</p>\n<p><a href=\"1_how_to_boot/index.html\">WHEEL起動手順書</a></p>\n<p><a href=\"2_tutorial/index.html\">WHEEL チュートリアル</a></p>\n<p><a href=\"3_reference_manual/index.html\">WHEELリファレンスマニュアル</a></p>\n<h3 id=\"%E5%88%B6%E7%B4%84%E4%BA%8B%E9%A0%85\">制約事項 <a class=\"heading-anchor-permalink\" href=\"#%E5%88%B6%E7%B4%84%E4%BA%8B%E9%A0%85\">#</a></h3>\n<p>WHEELは開発中のソフトウェアであり、いくつかの制約事項が残っています。\nこれらは次のページにまとまっていますのでご一読ください。</p>\n<p><a href=\"4_ATTENTION/index.html\">WHEEL制約事項</a></p>\n",
      "id": 0
    },
    {
      "path": "1_how_to_boot/index.md",
      "url": "1_how_to_boot/index.html",
      "content": "# WHEELの起動方法\n\n## 事前準備\nWHEELの起動にはdockerを使用します。\n最新の [docker](https://www.docker.com/) を取得してください。\n\n## 起動方法\n1. 任意の場所にディレクトリを作成します。(以降では、このディレクトリを`CONFIG_DIR`とします。)\n2. `CONFIG_DIR`に以下の2つのファイルをダウンロードします。\n    - [jobScheduler.json](https://raw.githubusercontent.com/RIKEN-RCCS/OPEN-WHEEL/master/server/app/config/jobScheduler.json)\n    - [server.json](https://raw.githubusercontent.com/RIKEN-RCCS/OPEN-WHEEL/master/server/app/config/server.json)\n3.  HTTPS通信用のサーバ証明書および鍵ファイルを、それぞれ`server.crt`, `server.key`という名前で`CONFIG_DIR`に格納します。\n    自己証明書を使用する際は次のURLのドキュメントを参考にしてください。\n\n    https://letsencrypt.org/docs/certificates-for-localhost/\n\n    また、起動時に環境変数 WHEEL_USE_HTTP=1を指定することで、httpでの通信を行なうこともできます。\n    ローカルネットワーク内での試用など、セキュリティ上の問題が無い環境でのみお使いください。\n\n4. ターミナルを起動し、以下のコマンドを入力します。\n\n```\n> docker run -d -v ${HOME}:/root -v CONFIG_DIR:/usr/src/server/app/config -p 8089:8089 tmkawanabe/wheel:latest\n```\n\nこのとき、`CONFIG_DIR`は、ホストマシン上での絶対パスである必要があります。\n\n上記コマンドでは、\n\n- プロジェクトファイルの作成先を${HOME}に指定しています\n- WHHELのポート番号を8089に指定しています。\n\nWHEELサーバが起動したら、ホストマシン上でwebブラウザを開いて、`http(s)://localhost:8089`にアクセスしてください。\n\n--------\n[トップページに戻る](../../index.md)\n",
      "html": "<h1 id=\"wheel%E3%81%AE%E8%B5%B7%E5%8B%95%E6%96%B9%E6%B3%95\">WHEELの起動方法 <a class=\"heading-anchor-permalink\" href=\"#wheel%E3%81%AE%E8%B5%B7%E5%8B%95%E6%96%B9%E6%B3%95\">#</a></h1>\n<h2 id=\"%E4%BA%8B%E5%89%8D%E6%BA%96%E5%82%99\">事前準備 <a class=\"heading-anchor-permalink\" href=\"#%E4%BA%8B%E5%89%8D%E6%BA%96%E5%82%99\">#</a></h2>\n<p>WHEELの起動にはdockerを使用します。\n最新の <a href=\"https://www.docker.com/\">docker</a> を取得してください。</p>\n<h2 id=\"%E8%B5%B7%E5%8B%95%E6%96%B9%E6%B3%95\">起動方法 <a class=\"heading-anchor-permalink\" href=\"#%E8%B5%B7%E5%8B%95%E6%96%B9%E6%B3%95\">#</a></h2>\n<ol>\n<li>\n<p>任意の場所にディレクトリを作成します。(以降では、このディレクトリを<code>CONFIG_DIR</code>とします。)</p>\n</li>\n<li>\n<p><code>CONFIG_DIR</code>に以下の2つのファイルをダウンロードします。</p>\n<ul>\n<li><a href=\"https://raw.githubusercontent.com/RIKEN-RCCS/OPEN-WHEEL/master/server/app/config/jobScheduler.json\">jobScheduler.json</a></li>\n<li><a href=\"https://raw.githubusercontent.com/RIKEN-RCCS/OPEN-WHEEL/master/server/app/config/server.json\">server.json</a></li>\n</ul>\n</li>\n<li>\n<p>HTTPS通信用のサーバ証明書および鍵ファイルを、それぞれ<code>server.crt</code>, <code>server.key</code>という名前で<code>CONFIG_DIR</code>に格納します。\n自己証明書を使用する際は次のURLのドキュメントを参考にしてください。</p>\n<p><a href=\"https://letsencrypt.org/docs/certificates-for-localhost/\">https://letsencrypt.org/docs/certificates-for-localhost/</a></p>\n<p>また、起動時に環境変数 WHEEL_USE_HTTP=1を指定することで、httpでの通信を行なうこともできます。\nローカルネットワーク内での試用など、セキュリティ上の問題が無い環境でのみお使いください。</p>\n</li>\n<li>\n<p>ターミナルを起動し、以下のコマンドを入力します。</p>\n</li>\n</ol>\n<pre><code>&gt; docker run -d -v ${HOME}:/root -v CONFIG_DIR:/usr/src/server/app/config -p 8089:8089 tmkawanabe/wheel:latest\n</code></pre>\n<p>このとき、<code>CONFIG_DIR</code>は、ホストマシン上での絶対パスである必要があります。</p>\n<p>上記コマンドでは、</p>\n<ul>\n<li>プロジェクトファイルの作成先を${HOME}に指定しています</li>\n<li>WHHELのポート番号を8089に指定しています。</li>\n</ul>\n<p>WHEELサーバが起動したら、ホストマシン上でwebブラウザを開いて、<code>http(s)://localhost:8089</code>にアクセスしてください。</p>\n<hr>\n<p><a href=\"../../index.html\">トップページに戻る</a></p>\n",
      "id": 1
    },
    {
      "path": "2_tutorial/1_basic_tutorial/index.md",
      "url": "2_tutorial/1_basic_tutorial/index.html",
      "content": "# Hello WHEEL\n\n## チュートリアル(基礎編)について\n本チュートリアルでは、WHEELの基本的な機能のみを使ってワークフローを作成・実行することで\nWHEELの使い方を学んでいきます。\n\n### 1. 新規プロジェクトの作成\nWHEELでは、1つのワークフローの実行単位のことを __プロジェクト__ と呼びます。\nプロジェクトの中には、実際にプログラムを実行する __タスクコンポーネント__ を1つ以上作成し\nこれらの間で入出力ファイルをやりとりしたり、実行順序を制御することで1つのワークフローを構成します。\n\nまず初めに空のプロジェクトを作成しましょう。\n\n#### ブラウザを起動して home 画面へアクセス\nブラウザを起動して、WHEELサーバへ接続するとhome画面が表示されます。\n画面左上に表示されている __NEW__ ボタンをクリックしてください。\n\n![img](./img/home_screen.png \"Home画面\")\n\n\nディレクトリツリーが表示されるので、新規プロジェクトを作成するディレクトリを選択し(1)\nプロジェクト名を入力して(2) __CREATE__ ボタンをクリックしてください(3)\n![img](./img/new_project.png \"新規プロジェクト名入力ダイアログ\")\n\nプロジェクト名はディレクトリ名の一部として使われるため、アルファベット、数字および一部の記号のみしか使えません。\n\n#### プロジェクトを開く\n新しく作成したプロジェクトが一覧の中に表示されるので、プロジェクト名の左側にあるチェックボックスにチェックを入れて(1)\n__OPEN__ ボタンをクリックしてください(2)\n![img](./img/home_screen2.png \"Home画面2\")\n\n画面が遷移して、ワークフロー画面が表示されます。\n\n\n### 2. 最初のコンポーネントの追加\nワークフロー画面では、画面左側にあるパレットからワークフローの部品である __コンポーネント__ を\nドラッグ&ドロップすることでワークフローを作成します。\n\nここでは、設定されたプログラムを実行する __Taskコンポーネント__ を1つプロジェクトに追加してみましょう。\n\n#### Taskコンポーネントの追加\nまずはじめにTaskコンポーネント(1)をドラッグして、画面中央の黒い部分(2)にドロップしてください。\n![img](./img/workflow.png \"ワークフロー画面\")\n\nこれで、プロジェクトに1つ目のコンポーネントが追加されました。\n![img](./img/workflow2.png \"Taskコンポーネント追加後の画面\")\n\n\n続けてこのTaskコンポーネントの中で実行する処理を定義します。\n\n### 3. Taskコンポーネントのプロパティ設定\nTaskコンポーネントを含む全てのコンポーネントは、動作を規定する __プロパティ__ を設定することで\n初めてワークフローの部品として機能するようになります。\nTaskコンポーネントでは、実行したいプログラムを直接指定するのではなく、\nそのプログラムを呼び出すbashスクリプトを作成し、実行したいスクリプトを指定する必要があります。\n\nここではサンプルとして、echoコマンドを呼び出すだけの単純なシェルスクリプトを作成して実行します。\n\n#### シェルスクリプトの作成\nさきほど作成した、__task0__ と書かれた箱(1)をクリックすると画面右側にプロパティを設定するためのサブ画面(2)が表示されます。\n\n![img](./img/property_screen.png \"プロパティ画面\")\n\nプロパティ画面上で下にスクロールすると、最下段に __Files__ と書かれた行があります。(1)\n\n![img](./img/property_screen2.png \"ファイルエリア-close\")\n\nこの行をクリックすると、ファイル操作エリアが下側に展開されます。\nシェルスクリプトの元となる空ファイルを作成するために、__new file__ ボタン(1)をクリックしてください。\n\n![img](./img/property_screen3.png \"ファイルエリア-open\")\n\n\nファイル名を入力するダイアログが表示されるので、作成するシェルスクリプトの名前を入力(1)し、\n__OK__ ボタンをクリックしてください。(2)\n\n![img](./img/newfile_dialog.png \"新規作成ファイル名入力\")\n\n正常にファイルが作成できたら、ファイル操作エリアの下にファイル名が表示されるのでクリックして選択してください(1)\nワークフロー画面左上の __text editor__ ボタンをクリック(2)することで、このファイルを編集することができます。\n\n![img](./img/workflow3.png \"スクリプトファイル選択\")\n\nここでは、数値計算プログラムを実行する代わりにechoコマンドを用いて文字列を出力するシェルスクリプトを作成して実行します。\nテキストエディタ部分(1)に `echo Hello WHEEL` と入力して画面右上の __SAVE ALL FILES__ ボタン(2)をクリックします\n最後に画面左上の __graph view__ ボタン(3)をクリックして元の画面に戻ってください。\n\n![img](./img/text_editor.png \"スクリプト編集\")\n\n#### 実行スクリプトの指定\nプロパティサブ画面を表示し、__script__ とかかれたドロップダウンリストから、\nさきほど作成したスクリプトファイルを選択してください。\n\n![img](./img/property_screen4.png \"スクリプト指定\")\n\n最後に、画面右上の __save project__ ボタン(1)をクリックして作成したプロジェクトをsaveしましょう。\n\nWHEELでは、プロジェクトファイルの管理にgitを使っており、save処理を行なったタイミングで\nリポジトリにコミットされます。\n__revert project__ボタン(2)をクリックすると、直前にsaveした状態まで巻き戻すことができますが\nredo(元に戻す処理を取り止めること)はできませんので、注意してください。\n\n![img](./img/workflow4.png \"save および revert\")\n\n### 4. プロジェクトの実行\n続いて、作成したプロジェクトを実行してみましょう。\n__run project__ ボタン(1)をクリックすると、プロジェクトの実行が始まります。\n\n![img](./img/workflow5.png \"run project\")\n\n今回のプロジェクトでは、`echo`コマンドを使っているので、標準出力に文字が表示されます。\n画面下部の▽ ボタン(2)をクリックすると、WHEELのログ出力や、プロジェクト内で実行したコマンドの\n標準出力、標準エラー出力を表示するログ画面が表示されます。\n\nログ画面を開いた直後は __INFO__ タブが表示されていて、WHEELのログ出力見えます。\n標準出力に未読の出力がある時は、 __STDOUT__ タブ(1)が緑色になります。このタブをクリックすると、echoコマンドの出力が確認できます。\n\n![img](./img/log_screen.png \"ログ表示\")\n\nプロジェクトの実行が終了すると、画面上部のステータス表示が __FINISHED__ に変わります。もしプロジェクト内で実行したプログラムが正常に終了しなかった時は、 __FAILED__ となります。\n\n![img](./img/project_state.png \"プロジェクトのステータス\")\n\n### 5. プロジェクトの初期化\nプログラムによっては、実行後にファイルが出力されていたり、既存のファイルが書き換えられていることが\nあります。\nまた、WHEELはプロジェクト内の個々のコンポーネントの実行状態を管理しているため、\nプロジェクトの修正をしたり、再実行する時には一度実行開始前の状態に戻す必要があります。\n\n本チュートリアルでは、この後プロジェクトに修正を加えながら何回か再実行していくので\n画面上部にある __stop and clean project__ ボタンをクリックして、実行開始前の状態に戻してください。\n\n### 6. リモートホスト設定の作成\n最初のプロジェクトでは、ローカルホスト(WHEELを実行しているマシン)で全てのタスクを実行しました。\nWHEELは、sshでログインした先のマシン上でタスクを実行する機能があります。\n\nこの機能を使うためには、初めに接続先ホストの情報をWHEEL上で設定する必要があります。\n\nまず、画面右上のハンバーガーメニューをクリックしてください。\n\n![img](./img/workflow6.png \"hunburger menu\")\n\n表示されたメニュー内の __Remotehost editor__ をクリックすると別のタブでリモートホスト設定画面が表示されます。\n\n![img](./img/remotehost_editor_button.png \"リモートホストエディタリンク\")\n\n\n画面上部の __NEW REMOTE HOST SETTING__ ボタンをクリックすると新規ホスト設定ダイアログが表示されるので\n次の項目に、値を入力してください。\n\n- label\n- Hostname\n- User ID\n- Host work dir\n\n![img](./img/remotehost_editor.png \"リモートホストエディタ\")\n\n![img](./img/new_remotehost.png \"新規ホスト情報設定\")\n\nlabelはWHEELが接続先ホストを区別するための文字列で、大文字小文字が区別されます。\n\nHostname, UserIDは接続先のホスト名(IPアドレスでも可)とユーザIDです。\n\nHost work dirには接続先ホストでの作業ディレクトリを絶対パスで指定します。\nWHEELがリモートホストでプログラムを実行する時には、ここで指定したディレクトリの下に\nファイルを転送してから、実行します。\n\n通常は接続先ホストのホームディレクトリを指定しますが\nシステムによっては、容量制限やI/O性能の都合で他の領域を使う方が良い場合もあります。\n接続先システムの利用ガイド等を参照して適切なディレクトリを選択してください。\n\nまた、リモートホストへの接続に公開鍵認証を使う場合は、 __use public key authentication__\nのスイッチを有効にしてください。\n下側に、秘密鍵を指定する欄が表示されるので、秘密鍵のパスを入力するか、 __BROWSE__ ボタンをクリックして\nファイルを選択してください。\n\n### 7. リモートホスト上でのタスクの実行\nリモートホスト上でプログラムを実行する準備が整ったので、さきほどのタスクをリモートホストで実行してみましょう。\n\nワークフロー画面に戻って、task0コンポーネントをクリックしプロパティ画面を表示します。\n__host__ と書かれた欄をクリックすると、設定したremotehostの一覧が表示されるので、\nさきほど作成したリモートホストのラベルを選択してください。\n\n![img](./img/select_host.png \"リモートホスト設定\")\n\n__save__ ボタンをクリックすると準備完了です。ローカルホストで実行した時と同じく\n__run project__ ボタンをクリックするとプロジェクトの実行が始まりますが\nここでは、リモートホストに接続するためのパスワードを入力するダイアログが\n表示されます。\n\nパスワード認証での接続の場合はパスワードを、公開鍵認証での接続の場合は\n秘密鍵に設定したパスフレーズを入力して __OK__ ボタンをクリックしてください。\n\n![img](./img/password_dialog.png \"パスワード入力ダイアログ\")\n\nログ画面を開くと、実行終了時に __STDOU(SSH)__ の部分にechoコマンドの出力が表示されています。\n\n出力内容を確認したら、__stop and clean project__ ボタンをクリックしてプロジェクトを初期化してください。\n\n### 8. バッチシステム経由でのタスクの実行\n次は、同じ内容のワークフローをバッチシステム経由で実行してみます。\nまずは、リモートホストエディタを起動してください。\nさきほど登録したリモートホストが表示されているので、右端の鉛筆アイコンをクリックして\nホスト情報編集ダイアログを表示します\n\n![img](./img/remotehost_editor2.png \"リモートホストエディタ追加編集\")\n\nリモートホストで使われているジョブスケジューラの種類を、 __job scheduler__ (1) の欄から選んでください。\n現在WHEELが対応しているジョブスケジューラは以下の4種類です。\n\n- PBSPro\n- SLURM\n- TCS (Technical Computing Suite)\n- UGE (Univa Grid Engine)\n\n富岳では、TCSが採用されていますが他サイトとは一部挙動が違うため、富岳専用の設定(Fugaku)が用意されています。\nまた、PBSProは、ジョブスケジューラの設定で、実行終了したジョブの情報を保存しないものがあります。\nこの場合 __PBSPro__ ではなく __PBSProWithoutHistory__ を使ってください。\n\n続いて、使用可能なキュー名を __available queues__ の欄(2)にカンマ区切りで入力してください。\nデフォルトキューが設定されているシステムで、デフォルトキューのみを使う場合は\n空欄のままでも構いません。\n\n最後に、ジョブの同時投入本数に制限を行ないたい場合は、 __max number of jobs__ の欄(3) に入力してください。\n\n例えば、同時投入本数が10本に制限されているシステムでは11本目のジョブを投入しようとするとエラーになり\nジョブ投入が受け付けられません。WHEEL側で制限を行なうことでこのようなエラーの発生を抑制できます。\nただし、WHEELを使わずに投入されたジョブ数は数えられませんので、グループ単位での同時投入ジョブ数が\n制限されているような場合は、制限に抵触する可能性もあります。\n\n以上でリモートホスト設定の変更は終了です。\n\nワークフロー画面に戻って、再度task0のプロパティ画面を表示してください。\n\nバッチシステムを介してジョブを実行すると、標準出力の内容を取得する方法がシステムによって異なるので、\nさきほどのスクリプトを変更して、 `stdout.txt` というファイルにechoコマンドの結果を出力するように変更しましょう。\n\nプロパティ画面下部のFiles から `3. Taskコンポーネントのプロパティ設定` で作成したスクリプトを\n選択し、テキストエディタで開いてください。\n\nechoコマンドの行末に追記して `echo Hello WHEEL > stdout.txt` と変更してください。\n\n![img](./img/text_editor2.png \"スクリプト変更\")\n\n1回目のスクリプト作成時は、 __SAVE ALL FILES__ ボタンをクリックしてファイルを保存しましたが、\n今回は別の方法で保存してみましょう。\n\nファイル名が書かれたタブ部分をクリックすると、__save__ __close without save__ という2つのメニューが表示されます。\n\nここでは、 __save__ を選択してください。\n\n![img](./img/text_editor3.png \"ファイル毎の保存メニュー\")\n\n__close without save__ をクリックすると編集したテキストが破棄されてタブが閉じられます。\n\n今は、1ファイルしか開いていませんが複数ファイルを開いて編集し、一部のファイルのみを保存したい場合は\nこちらの方法で不要なファイルを破棄し、__SAVE ALL FILES__ ボタンで一括保存(または、必要なファイルをさらに個別に保存)してください。\n\nスクリプトの編集が終わったらグラフビュー画面に戻って、再びtask0のプロパティを編集します。\n\nまず、__use job scheduler__ スイッチ(1)を有効にしてください。\nジョブに関する設定を入力できるようになるので __queue__ (2) の欄から投入先のキューを選択してください。\n\n![img](./img/use_job_scheduler.png \"バッチ使用設定\")\n\n続いて、スクリプトが出力する __stdout.txt__ をダウンロードする設定を追加します。\nプロパティ画面の最上部にある __basic__ の右にある上向き矢印をクリックしてください。\n\n![img](./img/property_screen5.png \"property折り畳み\")\n\n上段の設定項目が折り畳まれて、全てのカテゴリが表示されるので、__remote file setting__ を\nクリックして開いてください。\n\n![img](./img/property_screen6.png \"remote file setting\")\n\nincludeの欄(1)に __stdout.txt__ と入力してエンターキーを押すか、\n右にある __+__ ボタン(2)をクリックしてください。\n\n![img](./img/property_screen7.png \"include設定\")\n\n設定が終了したら、プロジェクトをsaveして実行してください。\n\n実行終了後に、task0コンポーネントのプロパティから、 __stdout.txt__ を選択して\nテキストエディタを立ち上げてください。\n\n![img](./img/job_result.png \"ジョブ実行結果確認\")\n\nechoコマンドの実行結果がファイルに出力されています。\n\n![img](./img/job_result2.png \"ジョブ実行結果出力\")\n\n以上でバッチシステム経由でのタスク実行は終了です。次のチュートリアルのために\n__stop and clean project__ ボタンをクリックしてプロジェクトを初期化してください。\n\n### 9. 入出力ファイルの受け渡し\nこれまでは、タスクが1つしか無いワークフローを実行してきましたが\n実際のワークフローでは、先行するプログラムが出力したファイルを\n別のプログラムに渡して処理を行なうことがよくあります。\n\nここでは、WHEELのタスクコンポーネント間でファイルを受け渡す方法について学びましょう。\n\nまず、ワークフローに2つ目のタスクを追加してください。\n最初のタスクの名前を変更しておらずtask0のままにしていた場合、task1という名前のタスクが作成されます。\n\n![img](./img/workflow7.png \"2つ目のタスク\")\n\n次に、task0が実行結果として __stdout.txt__ というファイルを出力することを指定します。\ntask0のプロパティ画面を開いて下にスクロールすると、 __input/output files__ という行があります。\nこれをクリックして入力欄を表示し、__output files__に __stdout.txt__ を入力してください。\n\n![img](./img/output_files.png \"output file設定 入力\")\n\ntask0の箱の右下に __stdout.txt__ という表示が追加されます。\n\n![img](./img/output_files2.png \"output file設定 GUI\")\n\nこの右にある▶をドラッグすると線が伸びていくので、task1の上にドロップしてください。\n\n![img](./img/file_dependency.png \"file依存性設定\")\n\n\nこれで、task0が出力する __output.txt__ を受けとってtask1を実行するという設定ができました。\n\n実際には、まだtask1は未設定ですので、最初のタスクの時と同様に空ファイルを作成して\nスクリプトを作りましょう。\n\nスクリプトは `ls -l stdout.txt` としてtask0からファイルが渡ってきたか確認できるようにしてください。\n\nプロジェクトをsaveして実行すると、ログ出力に次のような出力が見えます\n\n![img](./img/file_dependency_log.png \"outputFileを含むプロジェクトのログ出力\")\n\nこの結果から分かるように、output fileに指定されたファイルは、後続のコンポーネントに\nシンボリックリンクとして渡されます。\n\n実際には、先行するタスクでソルバを実行して、実行結果ファイルを後続のポスト処理コンポーネントに渡したり\n先行するタスクでプリ処理を行なって、入力ファイルを後続のソルバコンポーネントに渡すといった使い方が考えられます。\n\nこの時、前後のコンポーネントで実行するホストが違っていても、WHEELが自動的にダウンロードして転送するので\nライセンスや、計算機アーキテクチャの都合でそれぞれの処理を別のシステムで実行\n同様のワークフローで実行することができます。\n\n\n以上でコンポーネント間のファイルの受け渡し方法のチュートリアル終了です。次のチュートリアルのために\n__stop and clean project__ ボタンをクリックしてプロジェクトを初期化してください。\n\n\n### 10. タスク実行順の制御\n前の章では、先行するコンポーネントが出力したファイル受けとってから、後続のコンポーネントを実行しました。\n\n実際のワークフローでは、ファイルの受け渡しは発生しないが、\nあるプログラムが終わってから、次のプログラムを実行する必要がある\nという状況があります。\n\nWHEELには、先行コンポーネントの終了を待ってから実行する機能があるので\nこの機能を使って2つのタスクの実行順を制御してみましょう。\n\n#### タスク内容の変更\nさきほどの、task0, task1の内容ではどちらが先に実行されたのか分かり難いので\nそれぞれのスクリプトを次のように変更してください。\n\ntask0\n```\nsleep 10\necho task0\n```\n\ntask1\n```\necho task1\n```\n\nまた、remotehostでの実行待ちなどが発生するのを避けるために、 __host__ を\n__localhost__ に変更してローカル環境で実行するように設定してください。\n\n続いて、stdout.txtは今回は使わないので、output fileの設定を削除します。\n\nまず、 __task0__ のプロパティ画面を開いて __input/output files__ の\n設定欄を表示させ、 __stdout.txt__ の右にあるゴミ箱アイコンをクリックしてください。\n\n![img](./img/output_files3.png \"outputFileの削除\")\n\n__output files__ から__stdout.txt__ が削除され、task1の __stdout.txt__ と接続された線も削除されます。\n\n![img](./img/output_files4.png \"outputFile削除後のワークフロー\")\n\ntask1のinput files には、__stdout.txt__ の指定が残っていますが、これも同様の操作で削除することができます。\nなお、線で結ばれていない input/output files の指定はワークフローの動作には影響しませんので、\n一時的に変更する場合などは、使わない設定を残したままでも問題ありません。\n\nこの状態で、一旦saveしてワークフローを実行してみましょう。\n今は実行順の制御を行なっていないので、task0とtask1はほぼ同時に実行されます。\nログ画面の __STDOUT__ タブを見るとtask1は実行開始直後に表示され\ntask0の方はsleep10 が入っているので10秒後に表示されるはずです。\n\n![img](./img/log_screen3.png \"実行順未指定時のログ\")\n\nでは、一回プロジェクトを初期化して、task0が先に実行されるようにしてみましょう。\n\ntask0の箱の下部にある▼をドラッグして、task1の箱の上部にある■にドロップしてください。\n両taskが緑の線で接続されます。\n\n![img](./img/workflow8.png \"実行順指定後のワークフロー\")\n\nこれで、task0の実行が終了してからtask1が実行されるようになりました。\n\nでは、プロジェクトをsaveして実行してみましょう。\n\nログ出力を見ると今度はtask0が表示されてからtask1が表示されているはずです。\n\n\n![img](./img/log_screen4.png \"実行順指定時のログ\")\n\n\nこれで基本編のチュートリアルは終了です。\n\n本チュートリアルでは扱わなかったWHEELの高度な機能について\n知りたい方は [応用編のチュートリアル](../2_advanced_tutorial/index.md) に進んでください。\n\nまた、個々の機能の詳細な内容については、[リファレンスマニュアル](../../3_reference_manual/index.md) をご参照ください。\n\n\n--------\n[リファレンスマニュアルのトップページに戻る](../readme.md)\n",
      "html": "<h1 id=\"hello-wheel\">Hello WHEEL <a class=\"heading-anchor-permalink\" href=\"#hello-wheel\">#</a></h1>\n<h2 id=\"%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB(%E5%9F%BA%E7%A4%8E%E7%B7%A8)%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">チュートリアル(基礎編)について <a class=\"heading-anchor-permalink\" href=\"#%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB(%E5%9F%BA%E7%A4%8E%E7%B7%A8)%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">#</a></h2>\n<p>本チュートリアルでは、WHEELの基本的な機能のみを使ってワークフローを作成・実行することで\nWHEELの使い方を学んでいきます。</p>\n<h3 id=\"1.-%E6%96%B0%E8%A6%8F%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90\">1. 新規プロジェクトの作成 <a class=\"heading-anchor-permalink\" href=\"#1.-%E6%96%B0%E8%A6%8F%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90\">#</a></h3>\n<p>WHEELでは、1つのワークフローの実行単位のことを <strong>プロジェクト</strong> と呼びます。\nプロジェクトの中には、実際にプログラムを実行する <strong>タスクコンポーネント</strong> を1つ以上作成し\nこれらの間で入出力ファイルをやりとりしたり、実行順序を制御することで1つのワークフローを構成します。</p>\n<p>まず初めに空のプロジェクトを作成しましょう。</p>\n<h4 id=\"%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%82%92%E8%B5%B7%E5%8B%95%E3%81%97%E3%81%A6-home-%E7%94%BB%E9%9D%A2%E3%81%B8%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9\">ブラウザを起動して home 画面へアクセス <a class=\"heading-anchor-permalink\" href=\"#%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%82%92%E8%B5%B7%E5%8B%95%E3%81%97%E3%81%A6-home-%E7%94%BB%E9%9D%A2%E3%81%B8%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9\">#</a></h4>\n<p>ブラウザを起動して、WHEELサーバへ接続するとhome画面が表示されます。\n画面左上に表示されている <strong>NEW</strong> ボタンをクリックしてください。</p>\n<p><img src=\"./img/home_screen.png\" alt=\"img\" title=\"Home画面\"></p>\n<p>ディレクトリツリーが表示されるので、新規プロジェクトを作成するディレクトリを選択し(1)\nプロジェクト名を入力して(2) <strong>CREATE</strong> ボタンをクリックしてください(3)\n<img src=\"./img/new_project.png\" alt=\"img\" title=\"新規プロジェクト名入力ダイアログ\"></p>\n<p>プロジェクト名はディレクトリ名の一部として使われるため、アルファベット、数字および一部の記号のみしか使えません。</p>\n<h4 id=\"%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E9%96%8B%E3%81%8F\">プロジェクトを開く <a class=\"heading-anchor-permalink\" href=\"#%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E9%96%8B%E3%81%8F\">#</a></h4>\n<p>新しく作成したプロジェクトが一覧の中に表示されるので、プロジェクト名の左側にあるチェックボックスにチェックを入れて(1)\n<strong>OPEN</strong> ボタンをクリックしてください(2)\n<img src=\"./img/home_screen2.png\" alt=\"img\" title=\"Home画面2\"></p>\n<p>画面が遷移して、ワークフロー画面が表示されます。</p>\n<h3 id=\"2.-%E6%9C%80%E5%88%9D%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%BF%BD%E5%8A%A0\">2. 最初のコンポーネントの追加 <a class=\"heading-anchor-permalink\" href=\"#2.-%E6%9C%80%E5%88%9D%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%BF%BD%E5%8A%A0\">#</a></h3>\n<p>ワークフロー画面では、画面左側にあるパレットからワークフローの部品である <strong>コンポーネント</strong> を\nドラッグ&amp;ドロップすることでワークフローを作成します。</p>\n<p>ここでは、設定されたプログラムを実行する <strong>Taskコンポーネント</strong> を1つプロジェクトに追加してみましょう。</p>\n<h4 id=\"task%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%BF%BD%E5%8A%A0\">Taskコンポーネントの追加 <a class=\"heading-anchor-permalink\" href=\"#task%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%BF%BD%E5%8A%A0\">#</a></h4>\n<p>まずはじめにTaskコンポーネント(1)をドラッグして、画面中央の黒い部分(2)にドロップしてください。\n<img src=\"./img/workflow.png\" alt=\"img\" title=\"ワークフロー画面\"></p>\n<p>これで、プロジェクトに1つ目のコンポーネントが追加されました。\n<img src=\"./img/workflow2.png\" alt=\"img\" title=\"Taskコンポーネント追加後の画面\"></p>\n<p>続けてこのTaskコンポーネントの中で実行する処理を定義します。</p>\n<h3 id=\"3.-task%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E3%83%97%E3%83%AD%E3%83%91%E3%83%86%E3%82%A3%E8%A8%AD%E5%AE%9A\">3. Taskコンポーネントのプロパティ設定 <a class=\"heading-anchor-permalink\" href=\"#3.-task%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E3%83%97%E3%83%AD%E3%83%91%E3%83%86%E3%82%A3%E8%A8%AD%E5%AE%9A\">#</a></h3>\n<p>Taskコンポーネントを含む全てのコンポーネントは、動作を規定する <strong>プロパティ</strong> を設定することで\n初めてワークフローの部品として機能するようになります。\nTaskコンポーネントでは、実行したいプログラムを直接指定するのではなく、\nそのプログラムを呼び出すbashスクリプトを作成し、実行したいスクリプトを指定する必要があります。</p>\n<p>ここではサンプルとして、echoコマンドを呼び出すだけの単純なシェルスクリプトを作成して実行します。</p>\n<h4 id=\"%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90\">シェルスクリプトの作成 <a class=\"heading-anchor-permalink\" href=\"#%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90\">#</a></h4>\n<p>さきほど作成した、<strong>task0</strong> と書かれた箱(1)をクリックすると画面右側にプロパティを設定するためのサブ画面(2)が表示されます。</p>\n<p><img src=\"./img/property_screen.png\" alt=\"img\" title=\"プロパティ画面\"></p>\n<p>プロパティ画面上で下にスクロールすると、最下段に <strong>Files</strong> と書かれた行があります。(1)</p>\n<p><img src=\"./img/property_screen2.png\" alt=\"img\" title=\"ファイルエリア-close\"></p>\n<p>この行をクリックすると、ファイル操作エリアが下側に展開されます。\nシェルスクリプトの元となる空ファイルを作成するために、<strong>new file</strong> ボタン(1)をクリックしてください。</p>\n<p><img src=\"./img/property_screen3.png\" alt=\"img\" title=\"ファイルエリア-open\"></p>\n<p>ファイル名を入力するダイアログが表示されるので、作成するシェルスクリプトの名前を入力(1)し、\n<strong>OK</strong> ボタンをクリックしてください。(2)</p>\n<p><img src=\"./img/newfile_dialog.png\" alt=\"img\" title=\"新規作成ファイル名入力\"></p>\n<p>正常にファイルが作成できたら、ファイル操作エリアの下にファイル名が表示されるのでクリックして選択してください(1)\nワークフロー画面左上の <strong>text editor</strong> ボタンをクリック(2)することで、このファイルを編集することができます。</p>\n<p><img src=\"./img/workflow3.png\" alt=\"img\" title=\"スクリプトファイル選択\"></p>\n<p>ここでは、数値計算プログラムを実行する代わりにechoコマンドを用いて文字列を出力するシェルスクリプトを作成して実行します。\nテキストエディタ部分(1)に <code>echo Hello WHEEL</code> と入力して画面右上の <strong>SAVE ALL FILES</strong> ボタン(2)をクリックします\n最後に画面左上の <strong>graph view</strong> ボタン(3)をクリックして元の画面に戻ってください。</p>\n<p><img src=\"./img/text_editor.png\" alt=\"img\" title=\"スクリプト編集\"></p>\n<h4 id=\"%E5%AE%9F%E8%A1%8C%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%81%AE%E6%8C%87%E5%AE%9A\">実行スクリプトの指定 <a class=\"heading-anchor-permalink\" href=\"#%E5%AE%9F%E8%A1%8C%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%81%AE%E6%8C%87%E5%AE%9A\">#</a></h4>\n<p>プロパティサブ画面を表示し、<strong>script</strong> とかかれたドロップダウンリストから、\nさきほど作成したスクリプトファイルを選択してください。</p>\n<p><img src=\"./img/property_screen4.png\" alt=\"img\" title=\"スクリプト指定\"></p>\n<p>最後に、画面右上の <strong>save project</strong> ボタン(1)をクリックして作成したプロジェクトをsaveしましょう。</p>\n<p>WHEELでは、プロジェクトファイルの管理にgitを使っており、save処理を行なったタイミングで\nリポジトリにコミットされます。\n__revert project__ボタン(2)をクリックすると、直前にsaveした状態まで巻き戻すことができますが\nredo(元に戻す処理を取り止めること)はできませんので、注意してください。</p>\n<p><img src=\"./img/workflow4.png\" alt=\"img\" title=\"save および revert\"></p>\n<h3 id=\"4.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%AE%9F%E8%A1%8C\">4. プロジェクトの実行 <a class=\"heading-anchor-permalink\" href=\"#4.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%AE%9F%E8%A1%8C\">#</a></h3>\n<p>続いて、作成したプロジェクトを実行してみましょう。\n<strong>run project</strong> ボタン(1)をクリックすると、プロジェクトの実行が始まります。</p>\n<p><img src=\"./img/workflow5.png\" alt=\"img\" title=\"run project\"></p>\n<p>今回のプロジェクトでは、<code>echo</code>コマンドを使っているので、標準出力に文字が表示されます。\n画面下部の▽ ボタン(2)をクリックすると、WHEELのログ出力や、プロジェクト内で実行したコマンドの\n標準出力、標準エラー出力を表示するログ画面が表示されます。</p>\n<p>ログ画面を開いた直後は <strong>INFO</strong> タブが表示されていて、WHEELのログ出力見えます。\n標準出力に未読の出力がある時は、 <strong>STDOUT</strong> タブ(1)が緑色になります。このタブをクリックすると、echoコマンドの出力が確認できます。</p>\n<p><img src=\"./img/log_screen.png\" alt=\"img\" title=\"ログ表示\"></p>\n<p>プロジェクトの実行が終了すると、画面上部のステータス表示が <strong>FINISHED</strong> に変わります。もしプロジェクト内で実行したプログラムが正常に終了しなかった時は、 <strong>FAILED</strong> となります。</p>\n<p><img src=\"./img/project_state.png\" alt=\"img\" title=\"プロジェクトのステータス\"></p>\n<h3 id=\"5.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%88%9D%E6%9C%9F%E5%8C%96\">5. プロジェクトの初期化 <a class=\"heading-anchor-permalink\" href=\"#5.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%88%9D%E6%9C%9F%E5%8C%96\">#</a></h3>\n<p>プログラムによっては、実行後にファイルが出力されていたり、既存のファイルが書き換えられていることが\nあります。\nまた、WHEELはプロジェクト内の個々のコンポーネントの実行状態を管理しているため、\nプロジェクトの修正をしたり、再実行する時には一度実行開始前の状態に戻す必要があります。</p>\n<p>本チュートリアルでは、この後プロジェクトに修正を加えながら何回か再実行していくので\n画面上部にある <strong>stop and clean project</strong> ボタンをクリックして、実行開始前の状態に戻してください。</p>\n<h3 id=\"6.-%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%9B%E3%82%B9%E3%83%88%E8%A8%AD%E5%AE%9A%E3%81%AE%E4%BD%9C%E6%88%90\">6. リモートホスト設定の作成 <a class=\"heading-anchor-permalink\" href=\"#6.-%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%9B%E3%82%B9%E3%83%88%E8%A8%AD%E5%AE%9A%E3%81%AE%E4%BD%9C%E6%88%90\">#</a></h3>\n<p>最初のプロジェクトでは、ローカルホスト(WHEELを実行しているマシン)で全てのタスクを実行しました。\nWHEELは、sshでログインした先のマシン上でタスクを実行する機能があります。</p>\n<p>この機能を使うためには、初めに接続先ホストの情報をWHEEL上で設定する必要があります。</p>\n<p>まず、画面右上のハンバーガーメニューをクリックしてください。</p>\n<p><img src=\"./img/workflow6.png\" alt=\"img\" title=\"hunburger menu\"></p>\n<p>表示されたメニュー内の <strong>Remotehost editor</strong> をクリックすると別のタブでリモートホスト設定画面が表示されます。</p>\n<p><img src=\"./img/remotehost_editor_button.png\" alt=\"img\" title=\"リモートホストエディタリンク\"></p>\n<p>画面上部の <strong>NEW REMOTE HOST SETTING</strong> ボタンをクリックすると新規ホスト設定ダイアログが表示されるので\n次の項目に、値を入力してください。</p>\n<ul>\n<li>label</li>\n<li>Hostname</li>\n<li>User ID</li>\n<li>Host work dir</li>\n</ul>\n<p><img src=\"./img/remotehost_editor.png\" alt=\"img\" title=\"リモートホストエディタ\"></p>\n<p><img src=\"./img/new_remotehost.png\" alt=\"img\" title=\"新規ホスト情報設定\"></p>\n<p>labelはWHEELが接続先ホストを区別するための文字列で、大文字小文字が区別されます。</p>\n<p>Hostname, UserIDは接続先のホスト名(IPアドレスでも可)とユーザIDです。</p>\n<p>Host work dirには接続先ホストでの作業ディレクトリを絶対パスで指定します。\nWHEELがリモートホストでプログラムを実行する時には、ここで指定したディレクトリの下に\nファイルを転送してから、実行します。</p>\n<p>通常は接続先ホストのホームディレクトリを指定しますが\nシステムによっては、容量制限やI/O性能の都合で他の領域を使う方が良い場合もあります。\n接続先システムの利用ガイド等を参照して適切なディレクトリを選択してください。</p>\n<p>また、リモートホストへの接続に公開鍵認証を使う場合は、 <strong>use public key authentication</strong>\nのスイッチを有効にしてください。\n下側に、秘密鍵を指定する欄が表示されるので、秘密鍵のパスを入力するか、 <strong>BROWSE</strong> ボタンをクリックして\nファイルを選択してください。</p>\n<h3 id=\"7.-%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%9B%E3%82%B9%E3%83%88%E4%B8%8A%E3%81%A7%E3%81%AE%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%AE%E5%AE%9F%E8%A1%8C\">7. リモートホスト上でのタスクの実行 <a class=\"heading-anchor-permalink\" href=\"#7.-%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%9B%E3%82%B9%E3%83%88%E4%B8%8A%E3%81%A7%E3%81%AE%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%AE%E5%AE%9F%E8%A1%8C\">#</a></h3>\n<p>リモートホスト上でプログラムを実行する準備が整ったので、さきほどのタスクをリモートホストで実行してみましょう。</p>\n<p>ワークフロー画面に戻って、task0コンポーネントをクリックしプロパティ画面を表示します。\n<strong>host</strong> と書かれた欄をクリックすると、設定したremotehostの一覧が表示されるので、\nさきほど作成したリモートホストのラベルを選択してください。</p>\n<p><img src=\"./img/select_host.png\" alt=\"img\" title=\"リモートホスト設定\"></p>\n<p><strong>save</strong> ボタンをクリックすると準備完了です。ローカルホストで実行した時と同じく\n<strong>run project</strong> ボタンをクリックするとプロジェクトの実行が始まりますが\nここでは、リモートホストに接続するためのパスワードを入力するダイアログが\n表示されます。</p>\n<p>パスワード認証での接続の場合はパスワードを、公開鍵認証での接続の場合は\n秘密鍵に設定したパスフレーズを入力して <strong>OK</strong> ボタンをクリックしてください。</p>\n<p><img src=\"./img/password_dialog.png\" alt=\"img\" title=\"パスワード入力ダイアログ\"></p>\n<p>ログ画面を開くと、実行終了時に <strong>STDOU(SSH)</strong> の部分にechoコマンドの出力が表示されています。</p>\n<p>出力内容を確認したら、<strong>stop and clean project</strong> ボタンをクリックしてプロジェクトを初期化してください。</p>\n<h3 id=\"8.-%E3%83%90%E3%83%83%E3%83%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E7%B5%8C%E7%94%B1%E3%81%A7%E3%81%AE%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%AE%E5%AE%9F%E8%A1%8C\">8. バッチシステム経由でのタスクの実行 <a class=\"heading-anchor-permalink\" href=\"#8.-%E3%83%90%E3%83%83%E3%83%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E7%B5%8C%E7%94%B1%E3%81%A7%E3%81%AE%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%AE%E5%AE%9F%E8%A1%8C\">#</a></h3>\n<p>次は、同じ内容のワークフローをバッチシステム経由で実行してみます。\nまずは、リモートホストエディタを起動してください。\nさきほど登録したリモートホストが表示されているので、右端の鉛筆アイコンをクリックして\nホスト情報編集ダイアログを表示します</p>\n<p><img src=\"./img/remotehost_editor2.png\" alt=\"img\" title=\"リモートホストエディタ追加編集\"></p>\n<p>リモートホストで使われているジョブスケジューラの種類を、 <strong>job scheduler</strong> (1) の欄から選んでください。\n現在WHEELが対応しているジョブスケジューラは以下の4種類です。</p>\n<ul>\n<li>PBSPro</li>\n<li>SLURM</li>\n<li>TCS (Technical Computing Suite)</li>\n<li>UGE (Univa Grid Engine)</li>\n</ul>\n<p>富岳では、TCSが採用されていますが他サイトとは一部挙動が違うため、富岳専用の設定(Fugaku)が用意されています。\nまた、PBSProは、ジョブスケジューラの設定で、実行終了したジョブの情報を保存しないものがあります。\nこの場合 <strong>PBSPro</strong> ではなく <strong>PBSProWithoutHistory</strong> を使ってください。</p>\n<p>続いて、使用可能なキュー名を <strong>available queues</strong> の欄(2)にカンマ区切りで入力してください。\nデフォルトキューが設定されているシステムで、デフォルトキューのみを使う場合は\n空欄のままでも構いません。</p>\n<p>最後に、ジョブの同時投入本数に制限を行ないたい場合は、 <strong>max number of jobs</strong> の欄(3) に入力してください。</p>\n<p>例えば、同時投入本数が10本に制限されているシステムでは11本目のジョブを投入しようとするとエラーになり\nジョブ投入が受け付けられません。WHEEL側で制限を行なうことでこのようなエラーの発生を抑制できます。\nただし、WHEELを使わずに投入されたジョブ数は数えられませんので、グループ単位での同時投入ジョブ数が\n制限されているような場合は、制限に抵触する可能性もあります。</p>\n<p>以上でリモートホスト設定の変更は終了です。</p>\n<p>ワークフロー画面に戻って、再度task0のプロパティ画面を表示してください。</p>\n<p>バッチシステムを介してジョブを実行すると、標準出力の内容を取得する方法がシステムによって異なるので、\nさきほどのスクリプトを変更して、 <code>stdout.txt</code> というファイルにechoコマンドの結果を出力するように変更しましょう。</p>\n<p>プロパティ画面下部のFiles から <code>3. Taskコンポーネントのプロパティ設定</code> で作成したスクリプトを\n選択し、テキストエディタで開いてください。</p>\n<p>echoコマンドの行末に追記して <code>echo Hello WHEEL &gt; stdout.txt</code> と変更してください。</p>\n<p><img src=\"./img/text_editor2.png\" alt=\"img\" title=\"スクリプト変更\"></p>\n<p>1回目のスクリプト作成時は、 <strong>SAVE ALL FILES</strong> ボタンをクリックしてファイルを保存しましたが、\n今回は別の方法で保存してみましょう。</p>\n<p>ファイル名が書かれたタブ部分をクリックすると、<strong>save</strong> <strong>close without save</strong> という2つのメニューが表示されます。</p>\n<p>ここでは、 <strong>save</strong> を選択してください。</p>\n<p><img src=\"./img/text_editor3.png\" alt=\"img\" title=\"ファイル毎の保存メニュー\"></p>\n<p><strong>close without save</strong> をクリックすると編集したテキストが破棄されてタブが閉じられます。</p>\n<p>今は、1ファイルしか開いていませんが複数ファイルを開いて編集し、一部のファイルのみを保存したい場合は\nこちらの方法で不要なファイルを破棄し、<strong>SAVE ALL FILES</strong> ボタンで一括保存(または、必要なファイルをさらに個別に保存)してください。</p>\n<p>スクリプトの編集が終わったらグラフビュー画面に戻って、再びtask0のプロパティを編集します。</p>\n<p>まず、<strong>use job scheduler</strong> スイッチ(1)を有効にしてください。\nジョブに関する設定を入力できるようになるので <strong>queue</strong> (2) の欄から投入先のキューを選択してください。</p>\n<p><img src=\"./img/use_job_scheduler.png\" alt=\"img\" title=\"バッチ使用設定\"></p>\n<p>続いて、スクリプトが出力する <strong>stdout.txt</strong> をダウンロードする設定を追加します。\nプロパティ画面の最上部にある <strong>basic</strong> の右にある上向き矢印をクリックしてください。</p>\n<p><img src=\"./img/property_screen5.png\" alt=\"img\" title=\"property折り畳み\"></p>\n<p>上段の設定項目が折り畳まれて、全てのカテゴリが表示されるので、<strong>remote file setting</strong> を\nクリックして開いてください。</p>\n<p><img src=\"./img/property_screen6.png\" alt=\"img\" title=\"remote file setting\"></p>\n<p>includeの欄(1)に <strong>stdout.txt</strong> と入力してエンターキーを押すか、\n右にある <strong>+</strong> ボタン(2)をクリックしてください。</p>\n<p><img src=\"./img/property_screen7.png\" alt=\"img\" title=\"include設定\"></p>\n<p>設定が終了したら、プロジェクトをsaveして実行してください。</p>\n<p>実行終了後に、task0コンポーネントのプロパティから、 <strong>stdout.txt</strong> を選択して\nテキストエディタを立ち上げてください。</p>\n<p><img src=\"./img/job_result.png\" alt=\"img\" title=\"ジョブ実行結果確認\"></p>\n<p>echoコマンドの実行結果がファイルに出力されています。</p>\n<p><img src=\"./img/job_result2.png\" alt=\"img\" title=\"ジョブ実行結果出力\"></p>\n<p>以上でバッチシステム経由でのタスク実行は終了です。次のチュートリアルのために\n<strong>stop and clean project</strong> ボタンをクリックしてプロジェクトを初期化してください。</p>\n<h3 id=\"9.-%E5%85%A5%E5%87%BA%E5%8A%9B%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%8F%97%E3%81%91%E6%B8%A1%E3%81%97\">9. 入出力ファイルの受け渡し <a class=\"heading-anchor-permalink\" href=\"#9.-%E5%85%A5%E5%87%BA%E5%8A%9B%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%8F%97%E3%81%91%E6%B8%A1%E3%81%97\">#</a></h3>\n<p>これまでは、タスクが1つしか無いワークフローを実行してきましたが\n実際のワークフローでは、先行するプログラムが出力したファイルを\n別のプログラムに渡して処理を行なうことがよくあります。</p>\n<p>ここでは、WHEELのタスクコンポーネント間でファイルを受け渡す方法について学びましょう。</p>\n<p>まず、ワークフローに2つ目のタスクを追加してください。\n最初のタスクの名前を変更しておらずtask0のままにしていた場合、task1という名前のタスクが作成されます。</p>\n<p><img src=\"./img/workflow7.png\" alt=\"img\" title=\"2つ目のタスク\"></p>\n<p>次に、task0が実行結果として <strong>stdout.txt</strong> というファイルを出力することを指定します。\ntask0のプロパティ画面を開いて下にスクロールすると、 <strong>input/output files</strong> という行があります。\nこれをクリックして入力欄を表示し、__output files__に <strong>stdout.txt</strong> を入力してください。</p>\n<p><img src=\"./img/output_files.png\" alt=\"img\" title=\"output file設定 入力\"></p>\n<p>task0の箱の右下に <strong>stdout.txt</strong> という表示が追加されます。</p>\n<p><img src=\"./img/output_files2.png\" alt=\"img\" title=\"output file設定 GUI\"></p>\n<p>この右にある▶をドラッグすると線が伸びていくので、task1の上にドロップしてください。</p>\n<p><img src=\"./img/file_dependency.png\" alt=\"img\" title=\"file依存性設定\"></p>\n<p>これで、task0が出力する <strong>output.txt</strong> を受けとってtask1を実行するという設定ができました。</p>\n<p>実際には、まだtask1は未設定ですので、最初のタスクの時と同様に空ファイルを作成して\nスクリプトを作りましょう。</p>\n<p>スクリプトは <code>ls -l stdout.txt</code> としてtask0からファイルが渡ってきたか確認できるようにしてください。</p>\n<p>プロジェクトをsaveして実行すると、ログ出力に次のような出力が見えます</p>\n<p><img src=\"./img/file_dependency_log.png\" alt=\"img\" title=\"outputFileを含むプロジェクトのログ出力\"></p>\n<p>この結果から分かるように、output fileに指定されたファイルは、後続のコンポーネントに\nシンボリックリンクとして渡されます。</p>\n<p>実際には、先行するタスクでソルバを実行して、実行結果ファイルを後続のポスト処理コンポーネントに渡したり\n先行するタスクでプリ処理を行なって、入力ファイルを後続のソルバコンポーネントに渡すといった使い方が考えられます。</p>\n<p>この時、前後のコンポーネントで実行するホストが違っていても、WHEELが自動的にダウンロードして転送するので\nライセンスや、計算機アーキテクチャの都合でそれぞれの処理を別のシステムで実行\n同様のワークフローで実行することができます。</p>\n<p>以上でコンポーネント間のファイルの受け渡し方法のチュートリアル終了です。次のチュートリアルのために\n<strong>stop and clean project</strong> ボタンをクリックしてプロジェクトを初期化してください。</p>\n<h3 id=\"10.-%E3%82%BF%E3%82%B9%E3%82%AF%E5%AE%9F%E8%A1%8C%E9%A0%86%E3%81%AE%E5%88%B6%E5%BE%A1\">10. タスク実行順の制御 <a class=\"heading-anchor-permalink\" href=\"#10.-%E3%82%BF%E3%82%B9%E3%82%AF%E5%AE%9F%E8%A1%8C%E9%A0%86%E3%81%AE%E5%88%B6%E5%BE%A1\">#</a></h3>\n<p>前の章では、先行するコンポーネントが出力したファイル受けとってから、後続のコンポーネントを実行しました。</p>\n<p>実際のワークフローでは、ファイルの受け渡しは発生しないが、\nあるプログラムが終わってから、次のプログラムを実行する必要がある\nという状況があります。</p>\n<p>WHEELには、先行コンポーネントの終了を待ってから実行する機能があるので\nこの機能を使って2つのタスクの実行順を制御してみましょう。</p>\n<h4 id=\"%E3%82%BF%E3%82%B9%E3%82%AF%E5%86%85%E5%AE%B9%E3%81%AE%E5%A4%89%E6%9B%B4\">タスク内容の変更 <a class=\"heading-anchor-permalink\" href=\"#%E3%82%BF%E3%82%B9%E3%82%AF%E5%86%85%E5%AE%B9%E3%81%AE%E5%A4%89%E6%9B%B4\">#</a></h4>\n<p>さきほどの、task0, task1の内容ではどちらが先に実行されたのか分かり難いので\nそれぞれのスクリプトを次のように変更してください。</p>\n<p>task0</p>\n<pre><code>sleep 10\necho task0\n</code></pre>\n<p>task1</p>\n<pre><code>echo task1\n</code></pre>\n<p>また、remotehostでの実行待ちなどが発生するのを避けるために、 <strong>host</strong> を\n<strong>localhost</strong> に変更してローカル環境で実行するように設定してください。</p>\n<p>続いて、stdout.txtは今回は使わないので、output fileの設定を削除します。</p>\n<p>まず、 <strong>task0</strong> のプロパティ画面を開いて <strong>input/output files</strong> の\n設定欄を表示させ、 <strong>stdout.txt</strong> の右にあるゴミ箱アイコンをクリックしてください。</p>\n<p><img src=\"./img/output_files3.png\" alt=\"img\" title=\"outputFileの削除\"></p>\n<p><strong>output files</strong> から__stdout.txt__ が削除され、task1の <strong>stdout.txt</strong> と接続された線も削除されます。</p>\n<p><img src=\"./img/output_files4.png\" alt=\"img\" title=\"outputFile削除後のワークフロー\"></p>\n<p>task1のinput files には、<strong>stdout.txt</strong> の指定が残っていますが、これも同様の操作で削除することができます。\nなお、線で結ばれていない input/output files の指定はワークフローの動作には影響しませんので、\n一時的に変更する場合などは、使わない設定を残したままでも問題ありません。</p>\n<p>この状態で、一旦saveしてワークフローを実行してみましょう。\n今は実行順の制御を行なっていないので、task0とtask1はほぼ同時に実行されます。\nログ画面の <strong>STDOUT</strong> タブを見るとtask1は実行開始直後に表示され\ntask0の方はsleep10 が入っているので10秒後に表示されるはずです。</p>\n<p><img src=\"./img/log_screen3.png\" alt=\"img\" title=\"実行順未指定時のログ\"></p>\n<p>では、一回プロジェクトを初期化して、task0が先に実行されるようにしてみましょう。</p>\n<p>task0の箱の下部にある▼をドラッグして、task1の箱の上部にある■にドロップしてください。\n両taskが緑の線で接続されます。</p>\n<p><img src=\"./img/workflow8.png\" alt=\"img\" title=\"実行順指定後のワークフロー\"></p>\n<p>これで、task0の実行が終了してからtask1が実行されるようになりました。</p>\n<p>では、プロジェクトをsaveして実行してみましょう。</p>\n<p>ログ出力を見ると今度はtask0が表示されてからtask1が表示されているはずです。</p>\n<p><img src=\"./img/log_screen4.png\" alt=\"img\" title=\"実行順指定時のログ\"></p>\n<p>これで基本編のチュートリアルは終了です。</p>\n<p>本チュートリアルでは扱わなかったWHEELの高度な機能について\n知りたい方は <a href=\"../2_advanced_tutorial/index.html\">応用編のチュートリアル</a> に進んでください。</p>\n<p>また、個々の機能の詳細な内容については、<a href=\"../../3_reference_manual/index.html\">リファレンスマニュアル</a> をご参照ください。</p>\n<hr>\n<p><a href=\"../readme.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 2
    },
    {
      "path": "2_tutorial/2_advanced_tutorial/index.md",
      "url": "2_tutorial/2_advanced_tutorial/index.html",
      "content": "# Advanced tutorial\n\n## 応用編チュートリアルについて\n本チュートリアルでは、基礎編では触れなかった機能を扱います。\n\n基礎編とは違い全ての項目は独立しています。\n個々に新規プロジェクトを作成してからチュートリアルを実行してください。\n\n### 1. 条件分岐\nワークフローの中で、ある処理の実行結果に応じて\n後続の処理を変えることがあります。\n\nWHEELでは、このような条件分岐を実現するために ifコンポーネントを用意しています。\n\n![img](./img/component_library_if.png \"ifコンポーネント\")\n\nここではifコンポーネントを使って、スクリプトの実行結果の成否に応じて\nそれぞれ異なるスクリプトを実行してみましょう。\n\nまず、新規プロジェクトを作成してください。\n続いて、ワークフローに、taskコンポーネントを2つとifコンポーネントを1つ追加してください。\n以降はそれぞれ、task0, task1, if0 という名前で呼びます。\n\n![img](./img/workflow_if.png \"コンポーネント配置後のワークフロー\")\n\n先に、if0から分岐した後で実行するtask0, task1を作成します。\n\nそれぞれのコンポーネントで新規ファイルを作成し、テキストエディタで次の内容を入力してください。\nまた、scriptプロパティに作成したファイルを指定しておいてください。\n\ntask0:\n\n```\necho task0\n```\n\ntask1:\n\n```\necho task1\n```\n\nそれぞれ、標準出力に対して __task0__ または __task1__ と出力します。\n\n続いて、ifコンポーネントの条件分岐を指定します。\nプロパティ画面を開いて、 `check.sh` という名前で新規ファイルを作成し\nこのファイルをテキストエディタで開いてください。\n\ncheck.shの戻り値が0であればif節、0以外であればelse節へと分岐するので\nまずは、\n```\nexit 0\n```\nとだけ記入して必ずif節を通るようにしてみましょう。\n\nコンポーネントのプロパティ画面に戻って __condition setting__ の行をクリックし\n__script name for condition check__ と書かれた覧に `check.sh` を指定してください。\n\n![img](./img/property_if.png \"ifコンポーネントのプロパティ\")\n\n最後に、if0の下に表示されている紫色の▼をtask0に、緑の▼をtask1に接続してください。\n\n緑のコネクタは、check.shの戻り値が0の時、紫色のコネクタは戻り値が0以外の時に\n進むコンポーネントを示します。\n\n![img](./img/workflow_if2.png \"接続完了時のワークフロー\")\n\nこのワークフローを実行すると、check.shは0を返すので、task1のみが実行され\nSTDOUTには `task1` とだけ表示されます。\n\n![img](./img/workflow_if_result.png \"ワークフロー実行結果\")\n\n一度、プロジェクトを初期化してcheck.shの内容を `exit 1` に変更して再度実行してみましょう。\n今度は、task0のみが実行され、STDOUTには `task0`とだけ表示されます。\n\n### 2. ループ\nワークフローの中で繰り返し同じ処理を実行することがあります。\n\nWHEELにはこのような時に使える、for(1)、while(2)、foreach(3)という\n3種類のループコンポーネントがあります。\n\n![img](./img/component_library_loop.png \"loopコンポーネント\")\n\n各コンポーネントの中には、入れ子したワークフローを定義することができ、\nこれらのコンポーネントに指定された条件を満たすまで、下位ワークフローを繰り返し実行します。\n\nそれぞれのコンポーネントでは次の方法で条件を指定できます。\n\n - for: 始値から終値までのカウントアップまたはカウントダウン\n - while: 指定されたシェルスクリプトまたはjavascriptの文を実行して戻り値が0(JSの場合はtrue)になるまで\n - foreach: 使用する値を全て列挙する\n\nここでは、代表例としてforコンポーネントを使って、1から10まで順に出力するワークフローを作りましょう。\n\n始めにプロジェクトにforコンポーネントを1つ追加してください。\n\nforコンポーネントのプロパティに __start__ __end__ __step__ という3つの数字を指定する欄があります。\nそれぞれ、 1、5、2 と指定してください。\n\n![img](./img/property_for.png \"forコンポーネントの設定値\")\n\n\n次に、forコンポーネントをダブルクリックしてください。\nこれで、forコンポーネント内のコンポーネントが表示された状態になりますが、\n今は何もコンポーネントが無いので表示されていません。\n\n![img](./img/graphview_for.png \"forコンポーネントの内部\")\n\nここに、taskコンポーネントを1つ追加してください。\nまた、taskコンポーネントに空のファイルを追加してscriptプロパティに指定してください\n\n![img](./img/graphview_for2.png \"子コンポーネントを追加した後のforコンポーネントの内部\")\n\n\nforコンポーネント内のtaskコンポーネントでは、ループ変数の値を示す `$WHEEL_CURRENT_INDEX` 環境変数が利用できます。\nスクリプトに指定したファイルをテキストエディタで開き、以下の行を記入してください。\n\n```\necho $WHEEL_CURRENT_INDEX\n```\n\n![img](./img/script_for.png \"forコンポーネント内で実行されるスクリプト\")\n\nプロジェクトを実行すると、標準出力に 1,3,5 と表示されます。\n\n![img](./img/result_for.png \"実行結果\")\n\nこの例で示したように、forコンポーネントのendプロパティとindex変数の値が等しい時も\n内部のコンポーネントは実行されます。\n\n\n### 3. パラメータスタディ\n計算機シミュレーションのワークフローでは、入力データのパラメータを\n一部変更して、同じ計算を繰り返し実行することがあります。\n\nWHEELには、このような処理をサポートするパラメータスタディコンポーネントがあります。\n\n![img](./img/component_library_ps.png \"psコンポーネント\")\n\nパラメータスタディコンポーネントの中には入れ子にしたワークフローを定義することができます。\n下位ワークフロー内の任意のファイルを指定されたパラメータ値で書き換えて実行するため同じ処理をパラメータを変えて複数回実行することができます。\n\nここでは、シェルスクリプト内書き換えて実行することで、\nechoコマンドに様々な引数を渡してみましょう。\n\n\n始めにプロジェクトに1つPSコンポーネントを追加してください。\n\n![img](./img/graphview_ps.png \"PSグラフビュー\")\n\n続いて、PSコンポーネントをダブルクリックしてPSコンポーネント内部を表示しtaskコンポーネントを1つ追加してください。\nまた、taskコンポーネント内に `run.sh` という空ファイルを追加してscriptプロパティに指定してください。\n\n`run.sh`の中には\n\n```\necho number\n```\n\nと書いてください。\n\n![img](./img/script_ps.png \"PS内で実行するスクリプト\")\n\nrun.shを保存したらグラフビューに戻り、\n画面上部に表示されている __tutorial_PS__ をクリックしてプロジェクトのrootコンポーネントに戻ります。\n\n![img](./img/component_tree_ps.png \"PS内で実行するスクリプト\")\n\nPSコンポーネントのプロパティ画面を開いてFilesエリアを表示し、parameterSetting.jsonをクリックして選択した状態で\nテキストエディタ画面へ移動します。\n\n画面左側は、これまでと同様のテキストエディタですが、画面右側に、パラメータスタディ用の設定を行なうための画面が表示されています。\n\n![img](./img/texteditor_with_ps_config.png \"PS内で実行するスクリプト\")\n\nまず、画面右上の __+Add New Target File__ ボタンをクリックしてください。\nコンポーネントツリー画面が表示されるので、 __task0__ をクリックし、ファイル名に __run.sh__ と入力して __OK__ ボタンをクリックしてください。\n\n![img](./img/select_target_file.png \"targetfile 選択ダイアログ\")\n\nテキストエディタ部に、さきほど作成したrun.shが表示されるので、`number`の部分をドラッグして選択してください。\n画面右側の __parameters__ と書かれた場所のすぐ下に __number__ と表示されます。\n\n![img](./img/select_parameter_field.png \"パラメータ置換フィールド選択状態\")\n\nこの状態で、 __+ Add New Parameter__ ボタンをクリックすると、 __number__ の部分に対するパラメータ設定を行うことができます。\nここでは、ドロップダウンリストを __list__ に変更し、 __foo__ __bar__ __baz__ の3つの値を入力してください。\n\n![img](./img/list_parameter_dialog.png \"listパラメータダイアログ\")\n\n\n最後に __SAVE__ ボタンをクリックすると、__number__ に対するパラメータ設定が登録され、\n__run.sh__ の __number__ の部分は、 __{{ number }}__ と書き換えられます。\n\n![img](./img/texteditor_ps2.png \"編集終了時のテキストエディタ\")\n\n実行時には、この部分が実際のパラメータ(foo, bar, baz)で置き換えられてそれぞれ実行されます。\n\n最後に、画面右上の __SAVE ALL FILES__ ボタンをクリックして編集結果を保存してください。\n\nプロジェクトを実行すると、STDOUTに foo, bar, baz とそれぞれechoコマンドの出力結果が表示されます。\n\n![img](./img/result_ps.png \"PS実行結果\")\n\n\n#### パラメータ置換に関する補足\nさきほどの、 __{{ number }}__ をtargetfileに指定したファイル内の別の場所に記載すれば、そちらも同様にパラメータに置換されます。\n\nまた、二重括弧の中には、フィルタを追加することができます。\n例えば __{{ number | upper }}__ とすればパラメータを大文字にすることができます。\n\n他にも __{{ \"true\" if number == \"foo\" else \"false\" }}__ とすれば、number がfooの時のみ \"true\"それ以外の時は\"false\" に置き換えられます。\n\n利用可能なフィルタはこちらをご参照ください\n\nhttps://mozilla.github.io/nunjucks/templating.html#builtin-filters\n\n\n### 4. 入力ファイル\nシミュレーションの内容によっては、プリプロセスはインタラクティブに実施したいが\nソルバー以降の処理はワークフローで自動的に実行したいというケースもあります。\n\nWHEELには、実行時にファイルをアップロードしてワークフローの __入力データ__ として\n扱うsourceコンポーネントが用意されています。\n\n![img](./img/component_library_source.png \"sourceコンポーネント\")\n\nここでは、ローカルPCで作成した任意のテキストファイルを\ncatコマンドで表示するワークフローを作成して、sourceコンポーネントについて学びましょう\n\nまずはじめに、プロジェクトにtaskコンポーネントとsourceコンポーネントを1つづつ追加してください。\n\nsourceコンポーネントのプロパティを開いて、upload settingの行をクリックし __upload on demand__ のスイッチを有効にしてください。\n自動的にsourceコンポーネントのoutputFileに __UPLOAD_ON_DEMAND__ と表示されます。\n\n続いて、taskコンポーネント内に `run.sh` という空ファイルを追加してscriptプロパティに指定してください。\nrun.shには次の内容を記載してください。\n\n```\ncat input.txt\n```\n\n最後にtaskコンポーネントのinputFileに __input.txt__ を追加し、sourceコンポーネントの __UPLOAD_ON_DEMAND__ と接続してください。\n\n実際に、入力ファイルとして使うためのテキストファイルをPC上に用意してください。\n\nプロジェトを実行すると、sourceコンポーネントのoutputfileとして使うファイルをアップロードするためのダイアログが表示されるので\nさきほど用意したファイルを指定してください。\nアップロードが完了すると、 __Drop file here__ と書かれた部分がアップロードされたファイル名に変更されます。\n\n![img](./img/upload_dialog.png \"sourceコンポーネントのアップロードダイアログ\")\n\n\nOKボタンをクリックするとプロジェクトの実行が再開され、catコマンドによってアップロードされたファイルの中身が\nSTDOUTに出力されます。\n\nなお、OKボタンをクリックするまでは、ファイルのアップロードは何度でもやり直すことができるので\n指定するファイルを間違えた時は再度アップロードすれば後から指定したファイルが使われます。\n\n\n### 5. 結果表示\nポストプロセスまで自動化されたワークフローでは、\n計算結果として画像ファイルを出力することがよくあります。\n\nWHEELには、代表的な画像ファイルをブラウザ上で表示するviewerコンポーネントが用意されています。\nこのコンポーネントを使うと、計算結果のファイルを毎回PCにダウンロードすることなく\n簡単に結果を確認することができます。\n\n![img](./img/component_library_viewer.png \"viewerコンポーネント\")\n\nここでは、事前に用意した画像ファイルをviewerコンポーネントに渡すワークフローを作成して\nviewerコンポーネントについて学びましょう。\n\nまずはじめに、プロジェクトにtaskコンポーネントとviewerコンポーネントを1つづつ追加してください。\n\n続いて、taskコンポーネント内に `run.sh` という空ファイルを追加してscriptプロパティに指定してください。\nrun.shには次の内容を記載してください。\n\n```\nls *\n```\n\nviewerコンポーネントで表示するための、画像データをtaskコンポーネントにアップロードし\noutputFileに、 __*.jpg__ のような形でファイル名を記述してください。\n1ファイルのみを表示する場合はファイル名をそのまま書いても構いません。\nまた、1つにまとめず複数のoutputFileを指定しても問題ありません。\n\n最後にviewerコンポーネントのinputFileに __./__ を追加しtaskコンポーネントのoutputFileと接続してください\n\nプロジェクトを実行すると、 __open viewer screen__ というダイアログが表示されるので\nOKボタンをクリックすると別のタブで画像ビューワーが表示されます。\n\n初期状態ではタイル表示になっていますが、表示された画像をクリックするとスライドショー状態になります。\nこの状態では、画像の拡大縮小などを行うことができます。\n\n### 6. ファイル保存\nWHEELでワークフローを実行した時に、作成される出力ファイルなどは\nプロジェクトを初期化した際に毎回削除されてしまいます。\n\n人間が介在して、結果の確認や設定の調整を行ないながら繰り返しワークフローを実行する時には\n毎回の実行時の結果を保存しておきたいこともあります。\n\nこのような時には、storageコンポーネントを使うとプロジェクトの初期化時にも削除されずに残すことができます。\n\n![img](./img/component_library_storage.png \"storageコンポーネント\")\n\nここでは、storageコンポーネントを使って、ファイルを保存しながら\n複数回プロジェクトの実行と初期化を繰り返して、全てのファイルが保存されることを確認しましょう。\n\nまずはじめに、プロジェクトにtaskコンポーネントとstorageコンポーネントを1つづつ追加してください。\n\n続いて、taskコンポーネント内に `run.sh` という空ファイルを追加してscriptプロパティに指定してください。\nrun.shには次の内容を記載してください。\n\n```\necho foo >foo.txt\n```\n\nまた、taskコンポーネントのoutputFileに __*.txt__ を追加してください。\nこのコンポーネントは __foo.txt__しか出力しませんが、これから出力ファイル名を書き換えながら\n何回かプロジェクトを実行するため、ファイル名を*で指定しています。\n\n次にstorageコンポーネントのプロパティ画面を開き __directory path__ の欄に\n__ /tmp __ と記述してください。また、inputFileに __./__ を指定してください。\n\n> もし、/tmpが存在しない、または/tmpに書き込み権限が無い場合は他の任意のディレクトリを指定してください。\n  ただし、プロジェクトファイルが保存されているディレクトリツリーの範囲外のパスを指定する必要があります。\n\n最後に、taskコンポーネントのoutputFileとstorageコンポーネントのintpuFileを接続してください。\n\nプロジェクトを実行すると、task0, storage0それぞれのコンポーネントの下に foo.txtが表示されます。\n\nプロジェクトを初期化すると、task0の下のfoo.txtは削除されますが、storage0の下のfoo.txtは残ります。\n\ntask0のrun.shを編集して、出力ファイル名をbar.txtに変更して再実行すると、storage0コンポーネント内に\nfoo.txt, bar.txtが表示されます。\n\nこのように、プロジェクトの初期化を行なってもstorageコンポーネント内に保存したファイルは\n保持されるので、リスタート計算用のファイルの保存などに活用することができます。\n\n\n\n### 7. バルクジョブ\n富岳を初めとした、富士通株式会社製の \"Technical Computing Suite\" ジョブスケジューラを\n採用したシステムでは、バルクジョブ機能を使用することができます。\n\nWHEELには、この機能をGUIから簡単に使うための bulkjobTask コンポーネントが用意されています。\n\n![img](./img/component_library_bulkjob.png \"bulkjobコンポーネント\")\n\nここではバルクジョブを用いてパラメータスタディと同じ内容のワークフローを作成してみましょう。\n\nはじめに、新規プロジェクトを作成し、builkjobTaskコンポーネントを1つ追加してください。\n\nデフォルトではlocalhostでの実行になっているので、プロパティのhostを変更して\nbulkjob機能が利用可能なリモートホストを指定してください。\n\nなお、実際に利用するホストで稼動しているジョブスケジューラが\nバルクジョブ機能をサポートしていても、remotehost設定で __use bulkjob__ を有効にしていないと\nバルクジョブ機能は使えませんので、ご注意ください。\n\n![img](./img/remotehost.png \"use bulkjobの設定\")\n\nプロパティ画面を開いて、 `run.sh` という名前で空ファイルを作成し\nテキストエディタを開いて `echo ${PJM_BULKNUM}` と記入してください。\nジョブ実行時には、`${PJM_BULKNUM}` の部分が設定したパラメータに置き換えられます。\n\nプロパティ画面に戻って、scriptに `run.sh` を設定してください。\n\n最後に、 __bulkjob setting__ の行をクリックしてパラメータを指定します。\nここでは、 __use parameter setting file for bulk number__ のチェックを外して\nstartに __0__ endに __5__ を指定してください。\n\n![img](./img/property_bulkjob.png \"bulknumの設定\")\n\n\n最後に、各サブジョブの標準出力を回収するために、__remote file setting__ の行をクリックして\n__include__ に `run.sh*` と指定してください。\n\n![img](./img/property_bulkjob2.png \"includeの設定\")\n\nプロジェクトの実行が完了すると、run.sh.xxxxx[`${PJM_BULKNUM}`].out という形式のファイル名で\n標準出力が、出力されているので、各`PJM_BULKNUM`とファイルに出力されたechoコマンドの出力が\n一致することを確認してください。\n\n\n### 8. ステップジョブ\n富岳を初めとした、富士通株式会社製の \"Technical Computing Suite\" ジョブスケジューラを\n採用したシステムでは、ステップジョブ機能を使用することができます。\n\nWHEELには、この機能をGUIから簡単に使うための stepJob および stepJobTask コンポーネントが\n用意されています。\n\n![img](./img/component_library_stepjob.png \"stepjobコンポーネント\")\n\nWHEELのステップジョブ機能は、stepJobコンポーネントの中にstepJobTaskコンポーネントを複数定義して\n依存関係を定義したものを、ジョブスケジューラのstepjob機能を用いて実行するものです。\n\nはじめに、新規プロジェクトを作成しstepJobコンポーネントを1つ追加してください。\n\nデフォルトではlocalhostでの実行になっているので、プロパティのhostを変更して\nstepjob機能が利用可能なリモートホストを指定してください。\n\n![img](./img/workflow_stepjob.png \"stepjobコンポーネントの設定\")\n\nなお、実際に利用するホストで稼動しているジョブスケジューラが\nステップジョブ機能をサポートしていても、remotehost設定で __use stepjob__ を有効にしていないと\nステップジョブ機能は使えませんので、ご注意ください。\n\n![img](./img/remotehost2.png \"use stepjobの設定\")\n\n\n続いて、__stepjob0__ をダブルクリックしてstepjob0コンポーネント以下を表示させてください。\n\nstepjob コンポーネント内には、stepjobTask コンポーネントしか配置できませんので\n画面が左側のコンポーネントライブラリ部分が切り替わってstepjobTask コンポーネントのみが表示された状態になります。\n\n![img](./img/component_library_stepjobTask.png \"stepjobコンポーネント内でのcomponent library\")\n\nここに、stepjobTaskコンポーネントを2つ追加してください。\n\nstepjobTask0とstepjobTask1という2つのコンポーネントができるので、\nそれぞれのコンポーネントに __run.sh__ という名前で空ファイルを作成し、\n__script__ プロパティに指定してください。\n\n![img](./img/property_stepjobTask.png \"stepjobtaskのプロパティ\")\n\nstepjobTask0のスクリプトには、次のように指定してください\n\n```\nexit 1\n```\n\nこれでstepjobTask0は毎回エラー終了するようになります。\n\nstepjobTask1のスクリプトは次のように指定してください\n\n```\necho stepjobTask1 > stdout.txt\n```\n\nまず、stepjobTask0とstepjobTask1の実行順を指定します。\nstepjobTask0の▼をドラッグしてstepjobTask1にドロップしてください\n\n線が接続され、stepjobTask1の左肩に表示されているアイコンの番号が1に変わります。\n\n![img](./img/workflow_stepjobTask.png \"依存関係指定後のワークフロー\")\n\n次に、stepjobTask1の実行条件を指定します。\nプロパティ画面の __stepjobtask setting__ の覧をクリックして開き\n__use dependency__ を有効に、__dependencyForm__ に  `sd=ec==1`\nと入力してください。\nこれで、stepjobTask1はstepjobTask0の戻り値が1の時のみ実行されます。\n\n![img](./img/property_stepjobTask2.png \"依存関係式\")\n\n最後にstepjobTask1が出力するファイルを回収するために、\n__remote file setting__ の行をクリックして開きincludeの欄に `stdout.txt` と入力してください。\n\n![img](./img/property_stepjobTask3.png \"include指定\")\n\nプロジェクトを実行すると、stepjobtask0がfaildとなりますが、\nstepjobTask1は実行され、stdout.txtの中に `stepjobTask1` と書かれています。\n\n一度、プロジェクトを初期化してから、stepjobTask1の __dependencyForm__ を\n`sd=ec==0` と変更して実行してください。\n\n今度は、stepjobTask0がfaildになった後、stepjobTask1は実行されずそのまま\nワークフロー全体が終了します。\n\nこれで、応用編のチュートリアルは終了です。\n\n実際にアプリケーションを動かすワークフローについて知りたい方は\n[実践編のチュートリアル](../3_application_tutorial/index.md ) に進んでください。\n\nまた、個々の機能の詳細な内容については、[リファレンスマニュアル](../../3_reference_manual/index.md) をご参照ください。\n\n\n--------\n[リファレンスマニュアルのトップページに戻る](../readme.md)\n",
      "html": "<h1 id=\"advanced-tutorial\">Advanced tutorial <a class=\"heading-anchor-permalink\" href=\"#advanced-tutorial\">#</a></h1>\n<h2 id=\"%E5%BF%9C%E7%94%A8%E7%B7%A8%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">応用編チュートリアルについて <a class=\"heading-anchor-permalink\" href=\"#%E5%BF%9C%E7%94%A8%E7%B7%A8%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">#</a></h2>\n<p>本チュートリアルでは、基礎編では触れなかった機能を扱います。</p>\n<p>基礎編とは違い全ての項目は独立しています。\n個々に新規プロジェクトを作成してからチュートリアルを実行してください。</p>\n<h3 id=\"1.-%E6%9D%A1%E4%BB%B6%E5%88%86%E5%B2%90\">1. 条件分岐 <a class=\"heading-anchor-permalink\" href=\"#1.-%E6%9D%A1%E4%BB%B6%E5%88%86%E5%B2%90\">#</a></h3>\n<p>ワークフローの中で、ある処理の実行結果に応じて\n後続の処理を変えることがあります。</p>\n<p>WHEELでは、このような条件分岐を実現するために ifコンポーネントを用意しています。</p>\n<p><img src=\"./img/component_library_if.png\" alt=\"img\" title=\"ifコンポーネント\"></p>\n<p>ここではifコンポーネントを使って、スクリプトの実行結果の成否に応じて\nそれぞれ異なるスクリプトを実行してみましょう。</p>\n<p>まず、新規プロジェクトを作成してください。\n続いて、ワークフローに、taskコンポーネントを2つとifコンポーネントを1つ追加してください。\n以降はそれぞれ、task0, task1, if0 という名前で呼びます。</p>\n<p><img src=\"./img/workflow_if.png\" alt=\"img\" title=\"コンポーネント配置後のワークフロー\"></p>\n<p>先に、if0から分岐した後で実行するtask0, task1を作成します。</p>\n<p>それぞれのコンポーネントで新規ファイルを作成し、テキストエディタで次の内容を入力してください。\nまた、scriptプロパティに作成したファイルを指定しておいてください。</p>\n<p>task0:</p>\n<pre><code>echo task0\n</code></pre>\n<p>task1:</p>\n<pre><code>echo task1\n</code></pre>\n<p>それぞれ、標準出力に対して <strong>task0</strong> または <strong>task1</strong> と出力します。</p>\n<p>続いて、ifコンポーネントの条件分岐を指定します。\nプロパティ画面を開いて、 <code>check.sh</code> という名前で新規ファイルを作成し\nこのファイルをテキストエディタで開いてください。</p>\n<p>check.shの戻り値が0であればif節、0以外であればelse節へと分岐するので\nまずは、</p>\n<pre><code>exit 0\n</code></pre>\n<p>とだけ記入して必ずif節を通るようにしてみましょう。</p>\n<p>コンポーネントのプロパティ画面に戻って <strong>condition setting</strong> の行をクリックし\n<strong>script name for condition check</strong> と書かれた覧に <code>check.sh</code> を指定してください。</p>\n<p><img src=\"./img/property_if.png\" alt=\"img\" title=\"ifコンポーネントのプロパティ\"></p>\n<p>最後に、if0の下に表示されている紫色の▼をtask0に、緑の▼をtask1に接続してください。</p>\n<p>緑のコネクタは、check.shの戻り値が0の時、紫色のコネクタは戻り値が0以外の時に\n進むコンポーネントを示します。</p>\n<p><img src=\"./img/workflow_if2.png\" alt=\"img\" title=\"接続完了時のワークフロー\"></p>\n<p>このワークフローを実行すると、check.shは0を返すので、task1のみが実行され\nSTDOUTには <code>task1</code> とだけ表示されます。</p>\n<p><img src=\"./img/workflow_if_result.png\" alt=\"img\" title=\"ワークフロー実行結果\"></p>\n<p>一度、プロジェクトを初期化してcheck.shの内容を <code>exit 1</code> に変更して再度実行してみましょう。\n今度は、task0のみが実行され、STDOUTには <code>task0</code>とだけ表示されます。</p>\n<h3 id=\"2.-%E3%83%AB%E3%83%BC%E3%83%97\">2. ループ <a class=\"heading-anchor-permalink\" href=\"#2.-%E3%83%AB%E3%83%BC%E3%83%97\">#</a></h3>\n<p>ワークフローの中で繰り返し同じ処理を実行することがあります。</p>\n<p>WHEELにはこのような時に使える、for(1)、while(2)、foreach(3)という\n3種類のループコンポーネントがあります。</p>\n<p><img src=\"./img/component_library_loop.png\" alt=\"img\" title=\"loopコンポーネント\"></p>\n<p>各コンポーネントの中には、入れ子したワークフローを定義することができ、\nこれらのコンポーネントに指定された条件を満たすまで、下位ワークフローを繰り返し実行します。</p>\n<p>それぞれのコンポーネントでは次の方法で条件を指定できます。</p>\n<ul>\n<li>for: 始値から終値までのカウントアップまたはカウントダウン</li>\n<li>while: 指定されたシェルスクリプトまたはjavascriptの文を実行して戻り値が0(JSの場合はtrue)になるまで</li>\n<li>foreach: 使用する値を全て列挙する</li>\n</ul>\n<p>ここでは、代表例としてforコンポーネントを使って、1から10まで順に出力するワークフローを作りましょう。</p>\n<p>始めにプロジェクトにforコンポーネントを1つ追加してください。</p>\n<p>forコンポーネントのプロパティに <strong>start</strong> <strong>end</strong> <strong>step</strong> という3つの数字を指定する欄があります。\nそれぞれ、 1、5、2 と指定してください。</p>\n<p><img src=\"./img/property_for.png\" alt=\"img\" title=\"forコンポーネントの設定値\"></p>\n<p>次に、forコンポーネントをダブルクリックしてください。\nこれで、forコンポーネント内のコンポーネントが表示された状態になりますが、\n今は何もコンポーネントが無いので表示されていません。</p>\n<p><img src=\"./img/graphview_for.png\" alt=\"img\" title=\"forコンポーネントの内部\"></p>\n<p>ここに、taskコンポーネントを1つ追加してください。\nまた、taskコンポーネントに空のファイルを追加してscriptプロパティに指定してください</p>\n<p><img src=\"./img/graphview_for2.png\" alt=\"img\" title=\"子コンポーネントを追加した後のforコンポーネントの内部\"></p>\n<p>forコンポーネント内のtaskコンポーネントでは、ループ変数の値を示す <code>$WHEEL_CURRENT_INDEX</code> 環境変数が利用できます。\nスクリプトに指定したファイルをテキストエディタで開き、以下の行を記入してください。</p>\n<pre><code>echo $WHEEL_CURRENT_INDEX\n</code></pre>\n<p><img src=\"./img/script_for.png\" alt=\"img\" title=\"forコンポーネント内で実行されるスクリプト\"></p>\n<p>プロジェクトを実行すると、標準出力に 1,3,5 と表示されます。</p>\n<p><img src=\"./img/result_for.png\" alt=\"img\" title=\"実行結果\"></p>\n<p>この例で示したように、forコンポーネントのendプロパティとindex変数の値が等しい時も\n内部のコンポーネントは実行されます。</p>\n<h3 id=\"3.-%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%82%B9%E3%82%BF%E3%83%87%E3%82%A3\">3. パラメータスタディ <a class=\"heading-anchor-permalink\" href=\"#3.-%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%82%B9%E3%82%BF%E3%83%87%E3%82%A3\">#</a></h3>\n<p>計算機シミュレーションのワークフローでは、入力データのパラメータを\n一部変更して、同じ計算を繰り返し実行することがあります。</p>\n<p>WHEELには、このような処理をサポートするパラメータスタディコンポーネントがあります。</p>\n<p><img src=\"./img/component_library_ps.png\" alt=\"img\" title=\"psコンポーネント\"></p>\n<p>パラメータスタディコンポーネントの中には入れ子にしたワークフローを定義することができます。\n下位ワークフロー内の任意のファイルを指定されたパラメータ値で書き換えて実行するため同じ処理をパラメータを変えて複数回実行することができます。</p>\n<p>ここでは、シェルスクリプト内書き換えて実行することで、\nechoコマンドに様々な引数を渡してみましょう。</p>\n<p>始めにプロジェクトに1つPSコンポーネントを追加してください。</p>\n<p><img src=\"./img/graphview_ps.png\" alt=\"img\" title=\"PSグラフビュー\"></p>\n<p>続いて、PSコンポーネントをダブルクリックしてPSコンポーネント内部を表示しtaskコンポーネントを1つ追加してください。\nまた、taskコンポーネント内に <code>run.sh</code> という空ファイルを追加してscriptプロパティに指定してください。</p>\n<p><code>run.sh</code>の中には</p>\n<pre><code>echo number\n</code></pre>\n<p>と書いてください。</p>\n<p><img src=\"./img/script_ps.png\" alt=\"img\" title=\"PS内で実行するスクリプト\"></p>\n<p>run.shを保存したらグラフビューに戻り、\n画面上部に表示されている <strong>tutorial_PS</strong> をクリックしてプロジェクトのrootコンポーネントに戻ります。</p>\n<p><img src=\"./img/component_tree_ps.png\" alt=\"img\" title=\"PS内で実行するスクリプト\"></p>\n<p>PSコンポーネントのプロパティ画面を開いてFilesエリアを表示し、parameterSetting.jsonをクリックして選択した状態で\nテキストエディタ画面へ移動します。</p>\n<p>画面左側は、これまでと同様のテキストエディタですが、画面右側に、パラメータスタディ用の設定を行なうための画面が表示されています。</p>\n<p><img src=\"./img/texteditor_with_ps_config.png\" alt=\"img\" title=\"PS内で実行するスクリプト\"></p>\n<p>まず、画面右上の <strong>+Add New Target File</strong> ボタンをクリックしてください。\nコンポーネントツリー画面が表示されるので、 <strong>task0</strong> をクリックし、ファイル名に <strong><a href=\"http://run.sh\">run.sh</a></strong> と入力して <strong>OK</strong> ボタンをクリックしてください。</p>\n<p><img src=\"./img/select_target_file.png\" alt=\"img\" title=\"targetfile 選択ダイアログ\"></p>\n<p>テキストエディタ部に、さきほど作成したrun.shが表示されるので、<code>number</code>の部分をドラッグして選択してください。\n画面右側の <strong>parameters</strong> と書かれた場所のすぐ下に <strong>number</strong> と表示されます。</p>\n<p><img src=\"./img/select_parameter_field.png\" alt=\"img\" title=\"パラメータ置換フィールド選択状態\"></p>\n<p>この状態で、 <strong>+ Add New Parameter</strong> ボタンをクリックすると、 <strong>number</strong> の部分に対するパラメータ設定を行うことができます。\nここでは、ドロップダウンリストを <strong>list</strong> に変更し、 <strong>foo</strong> <strong>bar</strong> <strong>baz</strong> の3つの値を入力してください。</p>\n<p><img src=\"./img/list_parameter_dialog.png\" alt=\"img\" title=\"listパラメータダイアログ\"></p>\n<p>最後に <strong>SAVE</strong> ボタンをクリックすると、<strong>number</strong> に対するパラメータ設定が登録され、\n<strong><a href=\"http://run.sh\">run.sh</a></strong> の <strong>number</strong> の部分は、 <strong>{{ number }}</strong> と書き換えられます。</p>\n<p><img src=\"./img/texteditor_ps2.png\" alt=\"img\" title=\"編集終了時のテキストエディタ\"></p>\n<p>実行時には、この部分が実際のパラメータ(foo, bar, baz)で置き換えられてそれぞれ実行されます。</p>\n<p>最後に、画面右上の <strong>SAVE ALL FILES</strong> ボタンをクリックして編集結果を保存してください。</p>\n<p>プロジェクトを実行すると、STDOUTに foo, bar, baz とそれぞれechoコマンドの出力結果が表示されます。</p>\n<p><img src=\"./img/result_ps.png\" alt=\"img\" title=\"PS実行結果\"></p>\n<h4 id=\"%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E7%BD%AE%E6%8F%9B%E3%81%AB%E9%96%A2%E3%81%99%E3%82%8B%E8%A3%9C%E8%B6%B3\">パラメータ置換に関する補足 <a class=\"heading-anchor-permalink\" href=\"#%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E7%BD%AE%E6%8F%9B%E3%81%AB%E9%96%A2%E3%81%99%E3%82%8B%E8%A3%9C%E8%B6%B3\">#</a></h4>\n<p>さきほどの、 <strong>{{ number }}</strong> をtargetfileに指定したファイル内の別の場所に記載すれば、そちらも同様にパラメータに置換されます。</p>\n<p>また、二重括弧の中には、フィルタを追加することができます。\n例えば <strong>{{ number | upper }}</strong> とすればパラメータを大文字にすることができます。</p>\n<p>他にも <strong>{{ “true” if number == “foo” else “false” }}</strong> とすれば、number がfooの時のみ “true&quot;それ以外の時は&quot;false” に置き換えられます。</p>\n<p>利用可能なフィルタはこちらをご参照ください</p>\n<p><a href=\"https://mozilla.github.io/nunjucks/templating.html#builtin-filters\">https://mozilla.github.io/nunjucks/templating.html#builtin-filters</a></p>\n<h3 id=\"4.-%E5%85%A5%E5%8A%9B%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB\">4. 入力ファイル <a class=\"heading-anchor-permalink\" href=\"#4.-%E5%85%A5%E5%8A%9B%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB\">#</a></h3>\n<p>シミュレーションの内容によっては、プリプロセスはインタラクティブに実施したいが\nソルバー以降の処理はワークフローで自動的に実行したいというケースもあります。</p>\n<p>WHEELには、実行時にファイルをアップロードしてワークフローの <strong>入力データ</strong> として\n扱うsourceコンポーネントが用意されています。</p>\n<p><img src=\"./img/component_library_source.png\" alt=\"img\" title=\"sourceコンポーネント\"></p>\n<p>ここでは、ローカルPCで作成した任意のテキストファイルを\ncatコマンドで表示するワークフローを作成して、sourceコンポーネントについて学びましょう</p>\n<p>まずはじめに、プロジェクトにtaskコンポーネントとsourceコンポーネントを1つづつ追加してください。</p>\n<p>sourceコンポーネントのプロパティを開いて、upload settingの行をクリックし <strong>upload on demand</strong> のスイッチを有効にしてください。\n自動的にsourceコンポーネントのoutputFileに <strong>UPLOAD_ON_DEMAND</strong> と表示されます。</p>\n<p>続いて、taskコンポーネント内に <code>run.sh</code> という空ファイルを追加してscriptプロパティに指定してください。\nrun.shには次の内容を記載してください。</p>\n<pre><code>cat input.txt\n</code></pre>\n<p>最後にtaskコンポーネントのinputFileに <strong>input.txt</strong> を追加し、sourceコンポーネントの <strong>UPLOAD_ON_DEMAND</strong> と接続してください。</p>\n<p>実際に、入力ファイルとして使うためのテキストファイルをPC上に用意してください。</p>\n<p>プロジェトを実行すると、sourceコンポーネントのoutputfileとして使うファイルをアップロードするためのダイアログが表示されるので\nさきほど用意したファイルを指定してください。\nアップロードが完了すると、 <strong>Drop file here</strong> と書かれた部分がアップロードされたファイル名に変更されます。</p>\n<p><img src=\"./img/upload_dialog.png\" alt=\"img\" title=\"sourceコンポーネントのアップロードダイアログ\"></p>\n<p>OKボタンをクリックするとプロジェクトの実行が再開され、catコマンドによってアップロードされたファイルの中身が\nSTDOUTに出力されます。</p>\n<p>なお、OKボタンをクリックするまでは、ファイルのアップロードは何度でもやり直すことができるので\n指定するファイルを間違えた時は再度アップロードすれば後から指定したファイルが使われます。</p>\n<h3 id=\"5.-%E7%B5%90%E6%9E%9C%E8%A1%A8%E7%A4%BA\">5. 結果表示 <a class=\"heading-anchor-permalink\" href=\"#5.-%E7%B5%90%E6%9E%9C%E8%A1%A8%E7%A4%BA\">#</a></h3>\n<p>ポストプロセスまで自動化されたワークフローでは、\n計算結果として画像ファイルを出力することがよくあります。</p>\n<p>WHEELには、代表的な画像ファイルをブラウザ上で表示するviewerコンポーネントが用意されています。\nこのコンポーネントを使うと、計算結果のファイルを毎回PCにダウンロードすることなく\n簡単に結果を確認することができます。</p>\n<p><img src=\"./img/component_library_viewer.png\" alt=\"img\" title=\"viewerコンポーネント\"></p>\n<p>ここでは、事前に用意した画像ファイルをviewerコンポーネントに渡すワークフローを作成して\nviewerコンポーネントについて学びましょう。</p>\n<p>まずはじめに、プロジェクトにtaskコンポーネントとviewerコンポーネントを1つづつ追加してください。</p>\n<p>続いて、taskコンポーネント内に <code>run.sh</code> という空ファイルを追加してscriptプロパティに指定してください。\nrun.shには次の内容を記載してください。</p>\n<pre><code>ls *\n</code></pre>\n<p>viewerコンポーネントで表示するための、画像データをtaskコンポーネントにアップロードし\noutputFileに、 <strong>*.jpg</strong> のような形でファイル名を記述してください。\n1ファイルのみを表示する場合はファイル名をそのまま書いても構いません。\nまた、1つにまとめず複数のoutputFileを指定しても問題ありません。</p>\n<p>最後にviewerコンポーネントのinputFileに <strong>./</strong> を追加しtaskコンポーネントのoutputFileと接続してください</p>\n<p>プロジェクトを実行すると、 <strong>open viewer screen</strong> というダイアログが表示されるので\nOKボタンをクリックすると別のタブで画像ビューワーが表示されます。</p>\n<p>初期状態ではタイル表示になっていますが、表示された画像をクリックするとスライドショー状態になります。\nこの状態では、画像の拡大縮小などを行うことができます。</p>\n<h3 id=\"6.-%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E4%BF%9D%E5%AD%98\">6. ファイル保存 <a class=\"heading-anchor-permalink\" href=\"#6.-%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E4%BF%9D%E5%AD%98\">#</a></h3>\n<p>WHEELでワークフローを実行した時に、作成される出力ファイルなどは\nプロジェクトを初期化した際に毎回削除されてしまいます。</p>\n<p>人間が介在して、結果の確認や設定の調整を行ないながら繰り返しワークフローを実行する時には\n毎回の実行時の結果を保存しておきたいこともあります。</p>\n<p>このような時には、storageコンポーネントを使うとプロジェクトの初期化時にも削除されずに残すことができます。</p>\n<p><img src=\"./img/component_library_storage.png\" alt=\"img\" title=\"storageコンポーネント\"></p>\n<p>ここでは、storageコンポーネントを使って、ファイルを保存しながら\n複数回プロジェクトの実行と初期化を繰り返して、全てのファイルが保存されることを確認しましょう。</p>\n<p>まずはじめに、プロジェクトにtaskコンポーネントとstorageコンポーネントを1つづつ追加してください。</p>\n<p>続いて、taskコンポーネント内に <code>run.sh</code> という空ファイルを追加してscriptプロパティに指定してください。\nrun.shには次の内容を記載してください。</p>\n<pre><code>echo foo &gt;foo.txt\n</code></pre>\n<p>また、taskコンポーネントのoutputFileに <strong>*.txt</strong> を追加してください。\nこのコンポーネントは __foo.txt__しか出力しませんが、これから出力ファイル名を書き換えながら\n何回かプロジェクトを実行するため、ファイル名を*で指定しています。</p>\n<p>次にstorageコンポーネントのプロパティ画面を開き <strong>directory path</strong> の欄に\n__ /tmp __ と記述してください。また、inputFileに <strong>./</strong> を指定してください。</p>\n<blockquote>\n<p>もし、/tmpが存在しない、または/tmpに書き込み権限が無い場合は他の任意のディレクトリを指定してください。\nただし、プロジェクトファイルが保存されているディレクトリツリーの範囲外のパスを指定する必要があります。</p>\n</blockquote>\n<p>最後に、taskコンポーネントのoutputFileとstorageコンポーネントのintpuFileを接続してください。</p>\n<p>プロジェクトを実行すると、task0, storage0それぞれのコンポーネントの下に foo.txtが表示されます。</p>\n<p>プロジェクトを初期化すると、task0の下のfoo.txtは削除されますが、storage0の下のfoo.txtは残ります。</p>\n<p>task0のrun.shを編集して、出力ファイル名をbar.txtに変更して再実行すると、storage0コンポーネント内に\nfoo.txt, bar.txtが表示されます。</p>\n<p>このように、プロジェクトの初期化を行なってもstorageコンポーネント内に保存したファイルは\n保持されるので、リスタート計算用のファイルの保存などに活用することができます。</p>\n<h3 id=\"7.-%E3%83%90%E3%83%AB%E3%82%AF%E3%82%B8%E3%83%A7%E3%83%96\">7. バルクジョブ <a class=\"heading-anchor-permalink\" href=\"#7.-%E3%83%90%E3%83%AB%E3%82%AF%E3%82%B8%E3%83%A7%E3%83%96\">#</a></h3>\n<p>富岳を初めとした、富士通株式会社製の “Technical Computing Suite” ジョブスケジューラを\n採用したシステムでは、バルクジョブ機能を使用することができます。</p>\n<p>WHEELには、この機能をGUIから簡単に使うための bulkjobTask コンポーネントが用意されています。</p>\n<p><img src=\"./img/component_library_bulkjob.png\" alt=\"img\" title=\"bulkjobコンポーネント\"></p>\n<p>ここではバルクジョブを用いてパラメータスタディと同じ内容のワークフローを作成してみましょう。</p>\n<p>はじめに、新規プロジェクトを作成し、builkjobTaskコンポーネントを1つ追加してください。</p>\n<p>デフォルトではlocalhostでの実行になっているので、プロパティのhostを変更して\nbulkjob機能が利用可能なリモートホストを指定してください。</p>\n<p>なお、実際に利用するホストで稼動しているジョブスケジューラが\nバルクジョブ機能をサポートしていても、remotehost設定で <strong>use bulkjob</strong> を有効にしていないと\nバルクジョブ機能は使えませんので、ご注意ください。</p>\n<p><img src=\"./img/remotehost.png\" alt=\"img\" title=\"use bulkjobの設定\"></p>\n<p>プロパティ画面を開いて、 <code>run.sh</code> という名前で空ファイルを作成し\nテキストエディタを開いて <code>echo ${PJM_BULKNUM}</code> と記入してください。\nジョブ実行時には、<code>${PJM_BULKNUM}</code> の部分が設定したパラメータに置き換えられます。</p>\n<p>プロパティ画面に戻って、scriptに <code>run.sh</code> を設定してください。</p>\n<p>最後に、 <strong>bulkjob setting</strong> の行をクリックしてパラメータを指定します。\nここでは、 <strong>use parameter setting file for bulk number</strong> のチェックを外して\nstartに <strong>0</strong> endに <strong>5</strong> を指定してください。</p>\n<p><img src=\"./img/property_bulkjob.png\" alt=\"img\" title=\"bulknumの設定\"></p>\n<p>最後に、各サブジョブの標準出力を回収するために、<strong>remote file setting</strong> の行をクリックして\n<strong>include</strong> に <code>run.sh*</code> と指定してください。</p>\n<p><img src=\"./img/property_bulkjob2.png\" alt=\"img\" title=\"includeの設定\"></p>\n<p>プロジェクトの実行が完了すると、run.sh.xxxxx[<code>${PJM_BULKNUM}</code>].out という形式のファイル名で\n標準出力が、出力されているので、各<code>PJM_BULKNUM</code>とファイルに出力されたechoコマンドの出力が\n一致することを確認してください。</p>\n<h3 id=\"8.-%E3%82%B9%E3%83%86%E3%83%83%E3%83%97%E3%82%B8%E3%83%A7%E3%83%96\">8. ステップジョブ <a class=\"heading-anchor-permalink\" href=\"#8.-%E3%82%B9%E3%83%86%E3%83%83%E3%83%97%E3%82%B8%E3%83%A7%E3%83%96\">#</a></h3>\n<p>富岳を初めとした、富士通株式会社製の “Technical Computing Suite” ジョブスケジューラを\n採用したシステムでは、ステップジョブ機能を使用することができます。</p>\n<p>WHEELには、この機能をGUIから簡単に使うための stepJob および stepJobTask コンポーネントが\n用意されています。</p>\n<p><img src=\"./img/component_library_stepjob.png\" alt=\"img\" title=\"stepjobコンポーネント\"></p>\n<p>WHEELのステップジョブ機能は、stepJobコンポーネントの中にstepJobTaskコンポーネントを複数定義して\n依存関係を定義したものを、ジョブスケジューラのstepjob機能を用いて実行するものです。</p>\n<p>はじめに、新規プロジェクトを作成しstepJobコンポーネントを1つ追加してください。</p>\n<p>デフォルトではlocalhostでの実行になっているので、プロパティのhostを変更して\nstepjob機能が利用可能なリモートホストを指定してください。</p>\n<p><img src=\"./img/workflow_stepjob.png\" alt=\"img\" title=\"stepjobコンポーネントの設定\"></p>\n<p>なお、実際に利用するホストで稼動しているジョブスケジューラが\nステップジョブ機能をサポートしていても、remotehost設定で <strong>use stepjob</strong> を有効にしていないと\nステップジョブ機能は使えませんので、ご注意ください。</p>\n<p><img src=\"./img/remotehost2.png\" alt=\"img\" title=\"use stepjobの設定\"></p>\n<p>続いて、<strong>stepjob0</strong> をダブルクリックしてstepjob0コンポーネント以下を表示させてください。</p>\n<p>stepjob コンポーネント内には、stepjobTask コンポーネントしか配置できませんので\n画面が左側のコンポーネントライブラリ部分が切り替わってstepjobTask コンポーネントのみが表示された状態になります。</p>\n<p><img src=\"./img/component_library_stepjobTask.png\" alt=\"img\" title=\"stepjobコンポーネント内でのcomponent library\"></p>\n<p>ここに、stepjobTaskコンポーネントを2つ追加してください。</p>\n<p>stepjobTask0とstepjobTask1という2つのコンポーネントができるので、\nそれぞれのコンポーネントに <strong><a href=\"http://run.sh\">run.sh</a></strong> という名前で空ファイルを作成し、\n<strong>script</strong> プロパティに指定してください。</p>\n<p><img src=\"./img/property_stepjobTask.png\" alt=\"img\" title=\"stepjobtaskのプロパティ\"></p>\n<p>stepjobTask0のスクリプトには、次のように指定してください</p>\n<pre><code>exit 1\n</code></pre>\n<p>これでstepjobTask0は毎回エラー終了するようになります。</p>\n<p>stepjobTask1のスクリプトは次のように指定してください</p>\n<pre><code>echo stepjobTask1 &gt; stdout.txt\n</code></pre>\n<p>まず、stepjobTask0とstepjobTask1の実行順を指定します。\nstepjobTask0の▼をドラッグしてstepjobTask1にドロップしてください</p>\n<p>線が接続され、stepjobTask1の左肩に表示されているアイコンの番号が1に変わります。</p>\n<p><img src=\"./img/workflow_stepjobTask.png\" alt=\"img\" title=\"依存関係指定後のワークフロー\"></p>\n<p>次に、stepjobTask1の実行条件を指定します。\nプロパティ画面の <strong>stepjobtask setting</strong> の覧をクリックして開き\n<strong>use dependency</strong> を有効に、<strong>dependencyForm</strong> に  <code>sd=ec==1</code>\nと入力してください。\nこれで、stepjobTask1はstepjobTask0の戻り値が1の時のみ実行されます。</p>\n<p><img src=\"./img/property_stepjobTask2.png\" alt=\"img\" title=\"依存関係式\"></p>\n<p>最後にstepjobTask1が出力するファイルを回収するために、\n<strong>remote file setting</strong> の行をクリックして開きincludeの欄に <code>stdout.txt</code> と入力してください。</p>\n<p><img src=\"./img/property_stepjobTask3.png\" alt=\"img\" title=\"include指定\"></p>\n<p>プロジェクトを実行すると、stepjobtask0がfaildとなりますが、\nstepjobTask1は実行され、stdout.txtの中に <code>stepjobTask1</code> と書かれています。</p>\n<p>一度、プロジェクトを初期化してから、stepjobTask1の <strong>dependencyForm</strong> を\n<code>sd=ec==0</code> と変更して実行してください。</p>\n<p>今度は、stepjobTask0がfaildになった後、stepjobTask1は実行されずそのまま\nワークフロー全体が終了します。</p>\n<p>これで、応用編のチュートリアルは終了です。</p>\n<p>実際にアプリケーションを動かすワークフローについて知りたい方は\n<a href=\"../3_application_tutorial/index.html\">実践編のチュートリアル</a> に進んでください。</p>\n<p>また、個々の機能の詳細な内容については、<a href=\"../../3_reference_manual/index.html\">リファレンスマニュアル</a> をご参照ください。</p>\n<hr>\n<p><a href=\"../readme.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 3
    },
    {
      "path": "2_tutorial/3_application_tutorial/1_OpenFOAM_cavity/index.md",
      "url": "2_tutorial/3_application_tutorial/1_OpenFOAM_cavity/index.html",
      "content": "# OpenFOAMを利用したcavityケースの解析ワークフロー\n本章では、WHEELを用いた計算事例として「OpenFOAMを利用したcavityケースの解析ワークフロー」を紹介します。\n\n目次\n1. 解析概要\n1. ワークフローの作成\n1. ワークフローの実行\n1. 解析結果の確認\n\n## 1. 解析概要\nこの章で扱うモデルはCFDソフトウェアの基礎的な検証として有名な \"cavity\"モデルです。\n上端の壁が水平方向に一定速度で動き、引きずられるように内部の流体が動くようなモデルの解析を行ないます。\n\n![img](./img/cavity.png \"cavity\")\n\nOpenFOAMの配布物には例題として、このモデルを用いる解析用のデータが含まれているので\nそのファイルを用いて計算を実行します。\n\n## 2. ワークフローの作成\n新規プロジェクトを作成し、始めに3つのTaskコンポーネントを追加してください。\n\n各コンポーネントのプロパティ画面から、名前をそれぞれ __preprocess__ __solve__ __extract__ に変更してください。\n\n### preprocess コンポーネントの設定\n__preprocess__ コンポーネントに、\n__run.sh__  という名前で新規ファイルを作成し次の内容を記入してください。\n\n```\n. /vol0004/apps/oss/spack-v0.17.0/share/spack/setup-env.sh\n\nspack load 'openfoam@2012%fj@4.8.0'\n\necho $FOAM_TUTORIALS\ncp -r ${FOAM_TUTORIALS}/incompressible/icoFoam/cavity/cavity ./\nmv decomposeParDict cavity/system/\n\ncd cavity\nblockMesh\ndecomposePar\n```\n\nこのスクリプトでは、OpenFOAMのシステムディレクトリから\ncavityケースをコピーした後、blockMeshによるメッシュ生成、decomposeParによる\n領域分割を行ないます。\n\nコンポーネントのプロパティ画面を開いて以下の4項目を設定してください。\n\n- script: run.sh\n- host: fugaku\n- useJobScheduler: 有効\n- outputFiles: cavity\n\n以上で __preprocess__ の設定は終了です。\n\n### solveコンポーネントの設定\n__solve__ コンポーネントに\n__run.sh__  という名前で新規ファイルを作成し次の内容を記入してください。\n\n```\n. /vol0004/apps/oss/spack-v0.17.0/share/spack/setup-env.sh\n\nspack load 'openfoam@2012%fj@4.8.0'\n\ncd  cavity\nmpiexec -np 4 icoFoam -parallel > ./log.icoFoam 2>&1\nreconstructPar\ntouch result.foam\n\ncd ../\ntar cfzh  cavity.tgz ./cavity/\n```\n\nこのスクリプトでは、 __preprocess__ コンポーネントで作成した入力データを用いて\nicoFoamを用いた解析を実施します。\nまた、paraviewでの可視化のために後処理を行ない、結果ファイルを圧縮しています。\n\nコンポーネントのプロパティ画面を開いて、以下の4項目を設定してください。\n\n- script: run.sh\n- host: fugaku\n- useJobScheduler: 有効\n- outputFiles: cavity.tgz\n\n### extractコンポーネントの設定\n__extract__ コンポーネントに\n__run.sh__  という名前で新規ファイルを作成し次の内容を記入してください。\n\n```\ntar xfz cavity.tgz\n```\n\nこのスクリプトは、 __solve__ コンポーネントの出力結果を展開し、paraviewを起動する準備をします。\n\n最後にコンポーネントのプロパティを開いて、scriptに __run.sh__ を設定してください。\n\n### ファイル依存関係の設定\n__preprocess__ のoutputFileに設定した `cavity` を __solve__ コンポーネントにドロップして接続してください。\nまた、__solve__ コンポーネントのoutputFileに設定した `cavity.tgz` を __extract__ コンポーネントにドロップして接続してください。\n\n以上でワークフローの作成は完了です。\n\n\n## 3. プロジェクトの実行\n__run__ ボタンをクリックして、プロジェクトを実行してください。\n初めに、富岳へのログインに必要な秘密鍵のパスワードが聞かれますが、それ移行はワークフローの終了まで操作は不要です。\n\n## 4. 解析結果の確認\n\n解析結果の確認を行います。\n\n__extract__ コンポーネントのプロパティ画面を開いてFilesエリアを表示し\n`cavity` ディレクトリを開いてください。\nその下に `result.foam` ファイルが表示されるので、これをクリックして選択し\nshareボタンをクリックしてください。\n\n![img](./img/file_share_button.png \"ファイル共有ボタン\")\n\n__result.foam__ ファイルのパスが表示されるので、\nコピーボタンをクリックしてコピーしこのファイル名を引数に\nparaviewを起動してください。\n\n![img](./img/file_share_dialog.png \"ファイル共有ダイアログ\")\n\n\n### 解析結果\n\n参考として流速ベクトルの可視化結果を記載します。\n\n![img](./img/cavity_result.png \"流速ベクトル\")\n\n\n以上で、cavityケースの実行ワークフローは終了です。\n",
      "html": "<h1 id=\"openfoam%E3%82%92%E5%88%A9%E7%94%A8%E3%81%97%E3%81%9Fcavity%E3%82%B1%E3%83%BC%E3%82%B9%E3%81%AE%E8%A7%A3%E6%9E%90%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC\">OpenFOAMを利用したcavityケースの解析ワークフロー <a class=\"heading-anchor-permalink\" href=\"#openfoam%E3%82%92%E5%88%A9%E7%94%A8%E3%81%97%E3%81%9Fcavity%E3%82%B1%E3%83%BC%E3%82%B9%E3%81%AE%E8%A7%A3%E6%9E%90%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC\">#</a></h1>\n<p>本章では、WHEELを用いた計算事例として「OpenFOAMを利用したcavityケースの解析ワークフロー」を紹介します。</p>\n<p>目次</p>\n<ol>\n<li>解析概要</li>\n<li>ワークフローの作成</li>\n<li>ワークフローの実行</li>\n<li>解析結果の確認</li>\n</ol>\n<h2 id=\"1.-%E8%A7%A3%E6%9E%90%E6%A6%82%E8%A6%81\">1. 解析概要 <a class=\"heading-anchor-permalink\" href=\"#1.-%E8%A7%A3%E6%9E%90%E6%A6%82%E8%A6%81\">#</a></h2>\n<p>この章で扱うモデルはCFDソフトウェアの基礎的な検証として有名な &quot;cavity&quot;モデルです。\n上端の壁が水平方向に一定速度で動き、引きずられるように内部の流体が動くようなモデルの解析を行ないます。</p>\n<p><img src=\"./img/cavity.png\" alt=\"img\" title=\"cavity\"></p>\n<p>OpenFOAMの配布物には例題として、このモデルを用いる解析用のデータが含まれているので\nそのファイルを用いて計算を実行します。</p>\n<h2 id=\"2.-%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC%E3%81%AE%E4%BD%9C%E6%88%90\">2. ワークフローの作成 <a class=\"heading-anchor-permalink\" href=\"#2.-%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC%E3%81%AE%E4%BD%9C%E6%88%90\">#</a></h2>\n<p>新規プロジェクトを作成し、始めに3つのTaskコンポーネントを追加してください。</p>\n<p>各コンポーネントのプロパティ画面から、名前をそれぞれ <strong>preprocess</strong> <strong>solve</strong> <strong>extract</strong> に変更してください。</p>\n<h3 id=\"preprocess-%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">preprocess コンポーネントの設定 <a class=\"heading-anchor-permalink\" href=\"#preprocess-%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">#</a></h3>\n<p><strong>preprocess</strong> コンポーネントに、\n<strong><a href=\"http://run.sh\">run.sh</a></strong>  という名前で新規ファイルを作成し次の内容を記入してください。</p>\n<pre><code>. /vol0004/apps/oss/spack-v0.17.0/share/spack/setup-env.sh\n\nspack load 'openfoam@2012%fj@4.8.0'\n\necho $FOAM_TUTORIALS\ncp -r ${FOAM_TUTORIALS}/incompressible/icoFoam/cavity/cavity ./\nmv decomposeParDict cavity/system/\n\ncd cavity\nblockMesh\ndecomposePar\n</code></pre>\n<p>このスクリプトでは、OpenFOAMのシステムディレクトリから\ncavityケースをコピーした後、blockMeshによるメッシュ生成、decomposeParによる\n領域分割を行ないます。</p>\n<p>コンポーネントのプロパティ画面を開いて以下の4項目を設定してください。</p>\n<ul>\n<li>script: <a href=\"http://run.sh\">run.sh</a></li>\n<li>host: fugaku</li>\n<li>useJobScheduler: 有効</li>\n<li>outputFiles: cavity</li>\n</ul>\n<p>以上で <strong>preprocess</strong> の設定は終了です。</p>\n<h3 id=\"solve%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">solveコンポーネントの設定 <a class=\"heading-anchor-permalink\" href=\"#solve%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">#</a></h3>\n<p><strong>solve</strong> コンポーネントに\n<strong><a href=\"http://run.sh\">run.sh</a></strong>  という名前で新規ファイルを作成し次の内容を記入してください。</p>\n<pre><code>. /vol0004/apps/oss/spack-v0.17.0/share/spack/setup-env.sh\n\nspack load 'openfoam@2012%fj@4.8.0'\n\ncd  cavity\nmpiexec -np 4 icoFoam -parallel &gt; ./log.icoFoam 2&gt;&amp;1\nreconstructPar\ntouch result.foam\n\ncd ../\ntar cfzh  cavity.tgz ./cavity/\n</code></pre>\n<p>このスクリプトでは、 <strong>preprocess</strong> コンポーネントで作成した入力データを用いて\nicoFoamを用いた解析を実施します。\nまた、paraviewでの可視化のために後処理を行ない、結果ファイルを圧縮しています。</p>\n<p>コンポーネントのプロパティ画面を開いて、以下の4項目を設定してください。</p>\n<ul>\n<li>script: <a href=\"http://run.sh\">run.sh</a></li>\n<li>host: fugaku</li>\n<li>useJobScheduler: 有効</li>\n<li>outputFiles: cavity.tgz</li>\n</ul>\n<h3 id=\"extract%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">extractコンポーネントの設定 <a class=\"heading-anchor-permalink\" href=\"#extract%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">#</a></h3>\n<p><strong>extract</strong> コンポーネントに\n<strong><a href=\"http://run.sh\">run.sh</a></strong>  という名前で新規ファイルを作成し次の内容を記入してください。</p>\n<pre><code>tar xfz cavity.tgz\n</code></pre>\n<p>このスクリプトは、 <strong>solve</strong> コンポーネントの出力結果を展開し、paraviewを起動する準備をします。</p>\n<p>最後にコンポーネントのプロパティを開いて、scriptに <strong><a href=\"http://run.sh\">run.sh</a></strong> を設定してください。</p>\n<h3 id=\"%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E4%BE%9D%E5%AD%98%E9%96%A2%E4%BF%82%E3%81%AE%E8%A8%AD%E5%AE%9A\">ファイル依存関係の設定 <a class=\"heading-anchor-permalink\" href=\"#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E4%BE%9D%E5%AD%98%E9%96%A2%E4%BF%82%E3%81%AE%E8%A8%AD%E5%AE%9A\">#</a></h3>\n<p><strong>preprocess</strong> のoutputFileに設定した <code>cavity</code> を <strong>solve</strong> コンポーネントにドロップして接続してください。\nまた、<strong>solve</strong> コンポーネントのoutputFileに設定した <code>cavity.tgz</code> を <strong>extract</strong> コンポーネントにドロップして接続してください。</p>\n<p>以上でワークフローの作成は完了です。</p>\n<h2 id=\"3.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%AE%9F%E8%A1%8C\">3. プロジェクトの実行 <a class=\"heading-anchor-permalink\" href=\"#3.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%AE%9F%E8%A1%8C\">#</a></h2>\n<p><strong>run</strong> ボタンをクリックして、プロジェクトを実行してください。\n初めに、富岳へのログインに必要な秘密鍵のパスワードが聞かれますが、それ移行はワークフローの終了まで操作は不要です。</p>\n<h2 id=\"4.-%E8%A7%A3%E6%9E%90%E7%B5%90%E6%9E%9C%E3%81%AE%E7%A2%BA%E8%AA%8D\">4. 解析結果の確認 <a class=\"heading-anchor-permalink\" href=\"#4.-%E8%A7%A3%E6%9E%90%E7%B5%90%E6%9E%9C%E3%81%AE%E7%A2%BA%E8%AA%8D\">#</a></h2>\n<p>解析結果の確認を行います。</p>\n<p><strong>extract</strong> コンポーネントのプロパティ画面を開いてFilesエリアを表示し\n<code>cavity</code> ディレクトリを開いてください。\nその下に <code>result.foam</code> ファイルが表示されるので、これをクリックして選択し\nshareボタンをクリックしてください。</p>\n<p><img src=\"./img/file_share_button.png\" alt=\"img\" title=\"ファイル共有ボタン\"></p>\n<p><strong>result.foam</strong> ファイルのパスが表示されるので、\nコピーボタンをクリックしてコピーしこのファイル名を引数に\nparaviewを起動してください。</p>\n<p><img src=\"./img/file_share_dialog.png\" alt=\"img\" title=\"ファイル共有ダイアログ\"></p>\n<h3 id=\"%E8%A7%A3%E6%9E%90%E7%B5%90%E6%9E%9C\">解析結果 <a class=\"heading-anchor-permalink\" href=\"#%E8%A7%A3%E6%9E%90%E7%B5%90%E6%9E%9C\">#</a></h3>\n<p>参考として流速ベクトルの可視化結果を記載します。</p>\n<p><img src=\"./img/cavity_result.png\" alt=\"img\" title=\"流速ベクトル\"></p>\n<p>以上で、cavityケースの実行ワークフローは終了です。</p>\n",
      "id": 4
    },
    {
      "path": "2_tutorial/3_application_tutorial/2_OpenFOAM_PS/index.md",
      "url": "2_tutorial/3_application_tutorial/2_OpenFOAM_PS/index.html",
      "content": "# OpenFOAMを利用したパラメトリックスタディ解析ワークフロー\n本章では、WHEELを用いた計算事例として「OpenFOAMを利用したパラメトリックスタディ解析ワークフロー」を紹介します。\n\n3次元CADで作成した分配菅モデルに対して、intletの流速を対象としたパラメータスタディを行ないます。\n\n目次\n1. 解析概要\n1. WHEELによるワークフローの作成\n　1. Parameter Study コンポーネント\n　2. Task コンポーネント\n1. ジョブの投入\n1. 解析結果の確認\n\n## 1. 解析概要\n本事例で使用する解析対象モデルは、分配菅モデルです。\n\n#### 解析モデル D50-d10\n\n![img](./img/model.png \"model\")\n\ninletから流入した流体がoutletから出ていく解析を実施します。\n\n事前に[こちら](https://....)のファイルをダウンロードして展開しておいてください。\nアーカイブ内には次の3つのファイルが含まれます。\n\n- __pipe.unv__ メッシュ\n- __U__        流速の初期条件ファイル\n- __D50-d10.tgz__ ケースファイル\n\nなお、メッシュはCADモデルを元に、「SALOME-MECA」を用いて作成し\nIdeas universal形式でメッシュデータをエキスポートしたものです。\n\n## 2. ワークフロー作成\n新規プロジェクトを作成し、taskコンポーネントを2つとPSコンポーネントを1つ\n追加してください。\n1つ目のtaskコンポーネントの名前は __convert__、2つ目のtaskコンポーネントの名前は\n__extractとしてください。\n\nまた、PSコンポーネント内部にtaskコンポーネントを1つ追加し、\n__solve__ という名前にしてください。\n\n### convertコンポーネントの設定\n__convert__ コンポーネントのファイルエリアを開き、事前にダウンロードした\n__pipe.unv__ をアップロードしてください。\n\nまた、__run.sh__  という名前で新規ファイルを作成し次の内容を記入してください。\n\n```\n. /vol0004/apps/oss/spack-v0.17.0/share/spack/setup-env.sh\n\nspack load 'openfoam@2012%fj@4.8.0'\n\nideasUnvToFoam pipe.unv\n```\n\nこのスクリプトでは、Ideas universal形式のメッシュファイルを\nOpenFOAM形式へと変換します。\n\n正常に終了すると __constant/polyMesh__ ディレクトリに次のファイルが\n生成されます。\n\n- boundary\n- owner\n- faces\n- neighbor\n- points\n\nコンポーネントのプロパティ画面を開いて、以下の4項目を設定してください\n\n- script: run.sh\n- host: fugaku\n- useJobScheduler: 有効\n- outputFiles: constant\n\n### solveコンポーネントの設定\n__solve__ コンポーネントのファイルエリアを開き、事前にダウンロードした\nケースファイルをアップロードしてください。\nまた、__run.sh__  という名前で新規ファイルを作成し次の内容を記入してください。\n\n```\n. /vol0004/apps/oss/spack-v0.17.0/share/spack/setup-env.sh\n\nspack load 'openfoam@2012%fj@4.8.0'\n\ntar xvzf D50-d10.tgz\nmv ./U ./D50-d10/0\ncd ./D50-d10\n\ndecomposePar\nmpiexec -n 12 simpleFoam -parallel\nreconstructPar\ntouch result.foam\n\ncd ..\ntar cvzf D50-d10.tar.gz D50-d10\n```\n\nコンポーネントのプロパティ画面を開いて、以下の3項目を設定してください\n\n- script: run.sh\n- host: fugaku\n- useJobScheduler: 有効\n\n\n### PSコンポーネントの設定\nPSコンポーネントをクリックし、__output files__ に `results` を追加してください。\n\nファイルエリア内のある __parameterSetting.json__\nファイルを選択した状態でテキストエディタを開いてPS設定モードにします。\n\n__Add New Target File__ ボタンをクリックして __solve__ コンポーネント内の\n__U__ を対象にします。\n\n![img](./img/PS_target_file.png \"ターゲットファイルの指定\")\n\n左ペインに __U__ ファイルが開かれるので boundaryField -> inlet -> value の行\nにある、 __uniform (5 0 0);__ のうち __5__ の部分を\nマウスで選択してください。\n\n右ペインの __parameters__ と書かれた部分の下のテキストフィールドに\n__5__ と表示されます。\n\n![img](./img/PS_param.png \"パラメータ置き換え部分の選択\")\n\nこの状態で、 __Add New Parameter__ ボタンをクリックしてinletの流速に設定する値を\n入力します。\nここでは、5 m/sから7m/sまで1m/s刻みでパラメータスタディを行なうので\nmin=5, max=7, step=1 を設定してください。\n\n![img](./img/PS_U_setting.png \"パラメータ置き換え部分の選択\")\n\n最後に __solve__ コンポーネントの実行結果を回収する設定を追加します。\n\n__Add New Gather Setting__ ボタンをクリックしてgather設定ダイアログを表示し\nsolveを選択した状態で、 __srcName__ に `D50-d10.tar.gz` __dstName__に\n`results/{{ U }}/D50-d10.tar.gz` と入力してください。\n\n![img](./img/PS_gather_setting.png \"PS結果ファイル回収設定\")\n\n以上で、PS設定ファイルの編集は完了です。画面右上の __SAVE ALL FILES__ ボタンを\nクリックして編集内容を保存してください。\n\n### extractコンポーネントの設定\n__extract__ コンポーネントに\n__run.sh__  という名前で新規ファイルを作成し次の内容を記入してください。\n\n```\nfor i in results/*\n  do\n    pushd $i\n    tar xfz  D50-d10.tar.gz\n    popd\n  enddo\n```\n\nこのスクリプトは、 __solve__ コンポーネントの出力結果を順に展開し、\nparaviewを起動する準備をします。\n\n最後にコンポーネントのプロパティを開いて、scriptに __run.sh__ を設定してください。\n\n\n### ファイル依存関係の設定\n__convert__ のoutputFileに設定した、`constatnt` をPSコンポーネントに\nドロップして接続してください。\n\nまた、PSコンポーネントのoutputFileに設定した `results` を\n__extract__ コンポーネントにドロップして接続してください。\n\n以上でワークフローの作成は完了です。\n\n## 3. プロジェクトの実行\n__run__ ボタンをクリックして、プロジェクトを実行してください。\n初めに、富岳へのログインに必要な秘密鍵のパスワードが聞かれますが、それ移行はワークフローの終了まで操作は不要です。\n\n## 4. 解析結果の確認\n\n解析結果の確認を行います。\n\n__extract__ コンポーネントのプロパティ画面を開いてFilesエリアを表示し\n\n`results`ディレクトリ -> 流入速度のディレクトリ と辿っていってください。\nその下に `result.foam` ファイルが表示されるので、これをクリックして選択し\nshareボタンをクリックしてください。\n\n![img](./img/file_share_button.png \"ファイル共有ボタン\")\n\n__result.foam__ ファイルのパスが表示されるので、\nコピーボタンをクリックしてコピーしこのファイル名を引数に\nこのファイル名を引数にparaviewを起動してください。\n\n![img](./img/file_share_dialog.png \"ファイル共有ダイアログ\")\n\n\n\n### 解析結果\n流入速度、5[m/s], 6[m/s], 7[m/s] の各\n\n**流入速度5[m/s]** の解析結果において、分配菅の断面図に **速度 U** を、ベクトルで **圧力 p** を表示した結果は以下になります。\n\n##### 流入速度5[m/s]\n\n![img](./img/result_5.png \"流入速度5m/s結果\")\n\n同様に、**流入速度6[m/s]**、**流入速度7[m/s]** の結果を示します。\n\n##### 流入速度6[m/s]\n\n![img](./img/result_6.png \"流入速度6m/s結果\")\n\n##### 流入速度7[m/s]\n\n![img](./img/result_7.png \"流入速度7m/s結果\")\n\n\nOpenFOAMを利用したパラメトリックスタディ解析ワークフロー例は以上になります。\n",
      "html": "<h1 id=\"openfoam%E3%82%92%E5%88%A9%E7%94%A8%E3%81%97%E3%81%9F%E3%83%91%E3%83%A9%E3%83%A1%E3%83%88%E3%83%AA%E3%83%83%E3%82%AF%E3%82%B9%E3%82%BF%E3%83%87%E3%82%A3%E8%A7%A3%E6%9E%90%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC\">OpenFOAMを利用したパラメトリックスタディ解析ワークフロー <a class=\"heading-anchor-permalink\" href=\"#openfoam%E3%82%92%E5%88%A9%E7%94%A8%E3%81%97%E3%81%9F%E3%83%91%E3%83%A9%E3%83%A1%E3%83%88%E3%83%AA%E3%83%83%E3%82%AF%E3%82%B9%E3%82%BF%E3%83%87%E3%82%A3%E8%A7%A3%E6%9E%90%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC\">#</a></h1>\n<p>本章では、WHEELを用いた計算事例として「OpenFOAMを利用したパラメトリックスタディ解析ワークフロー」を紹介します。</p>\n<p>3次元CADで作成した分配菅モデルに対して、intletの流速を対象としたパラメータスタディを行ないます。</p>\n<p>目次</p>\n<ol>\n<li>解析概要</li>\n<li>WHEELによるワークフローの作成\n　1. Parameter Study コンポーネント\n　2. Task コンポーネント</li>\n<li>ジョブの投入</li>\n<li>解析結果の確認</li>\n</ol>\n<h2 id=\"1.-%E8%A7%A3%E6%9E%90%E6%A6%82%E8%A6%81\">1. 解析概要 <a class=\"heading-anchor-permalink\" href=\"#1.-%E8%A7%A3%E6%9E%90%E6%A6%82%E8%A6%81\">#</a></h2>\n<p>本事例で使用する解析対象モデルは、分配菅モデルです。</p>\n<h4 id=\"%E8%A7%A3%E6%9E%90%E3%83%A2%E3%83%87%E3%83%AB-d50-d10\">解析モデル D50-d10 <a class=\"heading-anchor-permalink\" href=\"#%E8%A7%A3%E6%9E%90%E3%83%A2%E3%83%87%E3%83%AB-d50-d10\">#</a></h4>\n<p><img src=\"./img/model.png\" alt=\"img\" title=\"model\"></p>\n<p>inletから流入した流体がoutletから出ていく解析を実施します。</p>\n<p>事前に<a href=\"https://....\">こちら</a>のファイルをダウンロードして展開しておいてください。\nアーカイブ内には次の3つのファイルが含まれます。</p>\n<ul>\n<li><strong>pipe.unv</strong> メッシュ</li>\n<li><strong>U</strong>        流速の初期条件ファイル</li>\n<li><strong>D50-d10.tgz</strong> ケースファイル</li>\n</ul>\n<p>なお、メッシュはCADモデルを元に、「SALOME-MECA」を用いて作成し\nIdeas universal形式でメッシュデータをエキスポートしたものです。</p>\n<h2 id=\"2.-%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC%E4%BD%9C%E6%88%90\">2. ワークフロー作成 <a class=\"heading-anchor-permalink\" href=\"#2.-%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC%E4%BD%9C%E6%88%90\">#</a></h2>\n<p>新規プロジェクトを作成し、taskコンポーネントを2つとPSコンポーネントを1つ\n追加してください。\n1つ目のtaskコンポーネントの名前は <strong>convert</strong>、2つ目のtaskコンポーネントの名前は\n__extractとしてください。</p>\n<p>また、PSコンポーネント内部にtaskコンポーネントを1つ追加し、\n<strong>solve</strong> という名前にしてください。</p>\n<h3 id=\"convert%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">convertコンポーネントの設定 <a class=\"heading-anchor-permalink\" href=\"#convert%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">#</a></h3>\n<p><strong>convert</strong> コンポーネントのファイルエリアを開き、事前にダウンロードした\n<strong>pipe.unv</strong> をアップロードしてください。</p>\n<p>また、<strong><a href=\"http://run.sh\">run.sh</a></strong>  という名前で新規ファイルを作成し次の内容を記入してください。</p>\n<pre><code>. /vol0004/apps/oss/spack-v0.17.0/share/spack/setup-env.sh\n\nspack load 'openfoam@2012%fj@4.8.0'\n\nideasUnvToFoam pipe.unv\n</code></pre>\n<p>このスクリプトでは、Ideas universal形式のメッシュファイルを\nOpenFOAM形式へと変換します。</p>\n<p>正常に終了すると <strong>constant/polyMesh</strong> ディレクトリに次のファイルが\n生成されます。</p>\n<ul>\n<li>boundary</li>\n<li>owner</li>\n<li>faces</li>\n<li>neighbor</li>\n<li>points</li>\n</ul>\n<p>コンポーネントのプロパティ画面を開いて、以下の4項目を設定してください</p>\n<ul>\n<li>script: <a href=\"http://run.sh\">run.sh</a></li>\n<li>host: fugaku</li>\n<li>useJobScheduler: 有効</li>\n<li>outputFiles: constant</li>\n</ul>\n<h3 id=\"solve%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">solveコンポーネントの設定 <a class=\"heading-anchor-permalink\" href=\"#solve%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">#</a></h3>\n<p><strong>solve</strong> コンポーネントのファイルエリアを開き、事前にダウンロードした\nケースファイルをアップロードしてください。\nまた、<strong><a href=\"http://run.sh\">run.sh</a></strong>  という名前で新規ファイルを作成し次の内容を記入してください。</p>\n<pre><code>. /vol0004/apps/oss/spack-v0.17.0/share/spack/setup-env.sh\n\nspack load 'openfoam@2012%fj@4.8.0'\n\ntar xvzf D50-d10.tgz\nmv ./U ./D50-d10/0\ncd ./D50-d10\n\ndecomposePar\nmpiexec -n 12 simpleFoam -parallel\nreconstructPar\ntouch result.foam\n\ncd ..\ntar cvzf D50-d10.tar.gz D50-d10\n</code></pre>\n<p>コンポーネントのプロパティ画面を開いて、以下の3項目を設定してください</p>\n<ul>\n<li>script: <a href=\"http://run.sh\">run.sh</a></li>\n<li>host: fugaku</li>\n<li>useJobScheduler: 有効</li>\n</ul>\n<h3 id=\"ps%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">PSコンポーネントの設定 <a class=\"heading-anchor-permalink\" href=\"#ps%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">#</a></h3>\n<p>PSコンポーネントをクリックし、<strong>output files</strong> に <code>results</code> を追加してください。</p>\n<p>ファイルエリア内のある <strong>parameterSetting.json</strong>\nファイルを選択した状態でテキストエディタを開いてPS設定モードにします。</p>\n<p><strong>Add New Target File</strong> ボタンをクリックして <strong>solve</strong> コンポーネント内の\n<strong>U</strong> を対象にします。</p>\n<p><img src=\"./img/PS_target_file.png\" alt=\"img\" title=\"ターゲットファイルの指定\"></p>\n<p>左ペインに <strong>U</strong> ファイルが開かれるので boundaryField -&gt; inlet -&gt; value の行\nにある、 <strong>uniform (5 0 0);</strong> のうち <strong>5</strong> の部分を\nマウスで選択してください。</p>\n<p>右ペインの <strong>parameters</strong> と書かれた部分の下のテキストフィールドに\n<strong>5</strong> と表示されます。</p>\n<p><img src=\"./img/PS_param.png\" alt=\"img\" title=\"パラメータ置き換え部分の選択\"></p>\n<p>この状態で、 <strong>Add New Parameter</strong> ボタンをクリックしてinletの流速に設定する値を\n入力します。\nここでは、5 m/sから7m/sまで1m/s刻みでパラメータスタディを行なうので\nmin=5, max=7, step=1 を設定してください。</p>\n<p><img src=\"./img/PS_U_setting.png\" alt=\"img\" title=\"パラメータ置き換え部分の選択\"></p>\n<p>最後に <strong>solve</strong> コンポーネントの実行結果を回収する設定を追加します。</p>\n<p><strong>Add New Gather Setting</strong> ボタンをクリックしてgather設定ダイアログを表示し\nsolveを選択した状態で、 <strong>srcName</strong> に <code>D50-d10.tar.gz</code> __dstName__に\n<code>results/{{ U }}/D50-d10.tar.gz</code> と入力してください。</p>\n<p><img src=\"./img/PS_gather_setting.png\" alt=\"img\" title=\"PS結果ファイル回収設定\"></p>\n<p>以上で、PS設定ファイルの編集は完了です。画面右上の <strong>SAVE ALL FILES</strong> ボタンを\nクリックして編集内容を保存してください。</p>\n<h3 id=\"extract%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">extractコンポーネントの設定 <a class=\"heading-anchor-permalink\" href=\"#extract%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">#</a></h3>\n<p><strong>extract</strong> コンポーネントに\n<strong><a href=\"http://run.sh\">run.sh</a></strong>  という名前で新規ファイルを作成し次の内容を記入してください。</p>\n<pre><code>for i in results/*\n  do\n    pushd $i\n    tar xfz  D50-d10.tar.gz\n    popd\n  enddo\n</code></pre>\n<p>このスクリプトは、 <strong>solve</strong> コンポーネントの出力結果を順に展開し、\nparaviewを起動する準備をします。</p>\n<p>最後にコンポーネントのプロパティを開いて、scriptに <strong><a href=\"http://run.sh\">run.sh</a></strong> を設定してください。</p>\n<h3 id=\"%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E4%BE%9D%E5%AD%98%E9%96%A2%E4%BF%82%E3%81%AE%E8%A8%AD%E5%AE%9A\">ファイル依存関係の設定 <a class=\"heading-anchor-permalink\" href=\"#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E4%BE%9D%E5%AD%98%E9%96%A2%E4%BF%82%E3%81%AE%E8%A8%AD%E5%AE%9A\">#</a></h3>\n<p><strong>convert</strong> のoutputFileに設定した、<code>constatnt</code> をPSコンポーネントに\nドロップして接続してください。</p>\n<p>また、PSコンポーネントのoutputFileに設定した <code>results</code> を\n<strong>extract</strong> コンポーネントにドロップして接続してください。</p>\n<p>以上でワークフローの作成は完了です。</p>\n<h2 id=\"3.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%AE%9F%E8%A1%8C\">3. プロジェクトの実行 <a class=\"heading-anchor-permalink\" href=\"#3.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%AE%9F%E8%A1%8C\">#</a></h2>\n<p><strong>run</strong> ボタンをクリックして、プロジェクトを実行してください。\n初めに、富岳へのログインに必要な秘密鍵のパスワードが聞かれますが、それ移行はワークフローの終了まで操作は不要です。</p>\n<h2 id=\"4.-%E8%A7%A3%E6%9E%90%E7%B5%90%E6%9E%9C%E3%81%AE%E7%A2%BA%E8%AA%8D\">4. 解析結果の確認 <a class=\"heading-anchor-permalink\" href=\"#4.-%E8%A7%A3%E6%9E%90%E7%B5%90%E6%9E%9C%E3%81%AE%E7%A2%BA%E8%AA%8D\">#</a></h2>\n<p>解析結果の確認を行います。</p>\n<p><strong>extract</strong> コンポーネントのプロパティ画面を開いてFilesエリアを表示し</p>\n<p><code>results</code>ディレクトリ -&gt; 流入速度のディレクトリ と辿っていってください。\nその下に <code>result.foam</code> ファイルが表示されるので、これをクリックして選択し\nshareボタンをクリックしてください。</p>\n<p><img src=\"./img/file_share_button.png\" alt=\"img\" title=\"ファイル共有ボタン\"></p>\n<p><strong>result.foam</strong> ファイルのパスが表示されるので、\nコピーボタンをクリックしてコピーしこのファイル名を引数に\nこのファイル名を引数にparaviewを起動してください。</p>\n<p><img src=\"./img/file_share_dialog.png\" alt=\"img\" title=\"ファイル共有ダイアログ\"></p>\n<h3 id=\"%E8%A7%A3%E6%9E%90%E7%B5%90%E6%9E%9C\">解析結果 <a class=\"heading-anchor-permalink\" href=\"#%E8%A7%A3%E6%9E%90%E7%B5%90%E6%9E%9C\">#</a></h3>\n<p>流入速度、5[m/s], 6[m/s], 7[m/s] の各</p>\n<p><strong>流入速度5[m/s]</strong> の解析結果において、分配菅の断面図に <strong>速度 U</strong> を、ベクトルで <strong>圧力 p</strong> を表示した結果は以下になります。</p>\n<h5 id=\"%E6%B5%81%E5%85%A5%E9%80%9F%E5%BA%A65%5Bm%2Fs%5D\">流入速度5[m/s] <a class=\"heading-anchor-permalink\" href=\"#%E6%B5%81%E5%85%A5%E9%80%9F%E5%BA%A65%5Bm%2Fs%5D\">#</a></h5>\n<p><img src=\"./img/result_5.png\" alt=\"img\" title=\"流入速度5m/s結果\"></p>\n<p>同様に、<strong>流入速度6[m/s]</strong>、<strong>流入速度7[m/s]</strong> の結果を示します。</p>\n<h5 id=\"%E6%B5%81%E5%85%A5%E9%80%9F%E5%BA%A66%5Bm%2Fs%5D\">流入速度6[m/s] <a class=\"heading-anchor-permalink\" href=\"#%E6%B5%81%E5%85%A5%E9%80%9F%E5%BA%A66%5Bm%2Fs%5D\">#</a></h5>\n<p><img src=\"./img/result_6.png\" alt=\"img\" title=\"流入速度6m/s結果\"></p>\n<h5 id=\"%E6%B5%81%E5%85%A5%E9%80%9F%E5%BA%A67%5Bm%2Fs%5D\">流入速度7[m/s] <a class=\"heading-anchor-permalink\" href=\"#%E6%B5%81%E5%85%A5%E9%80%9F%E5%BA%A67%5Bm%2Fs%5D\">#</a></h5>\n<p><img src=\"./img/result_7.png\" alt=\"img\" title=\"流入速度7m/s結果\"></p>\n<p>OpenFOAMを利用したパラメトリックスタディ解析ワークフロー例は以上になります。</p>\n",
      "id": 5
    },
    {
      "path": "2_tutorial/3_application_tutorial/3_TensorFlow_mnist/index.md",
      "url": "2_tutorial/3_application_tutorial/3_TensorFlow_mnist/index.html",
      "content": "# TensorFlowを利用したMNISTデータ解析ワークフロー\n本章では、WHEELを用いた計算事例として「TensorFlowを利用したMNISTデータの解析ワークフロー」を紹介します。\n\n目次\n1. MNISTデータについて\n1. NN(Neural Network)について\n1. kerasについて\n1. ワークフローの作成\n1. ジョブの投入\n1. 解析結果の確認\n\n## 1. ワークフロー概要\n本事例では、富岳上でTensorFlow利用して、\nMNISTデータを用いた手書き数字画像学習モデルの作成と\n推論を行ないます。\n\nMNISTデータとは手書き数字画像60000枚とテスト画像10000枚を集めた画像データセットのことであり、\nニューラルネットワークを学習するうえで非常に便利な画像のデータセットとして著名です。\nデータセットの中身は以下のような構造になっています。\n```\nMNISTデータ\n　├ 学習用データ (60,000個)\n　│ 　├ 画像データ\n　│ 　└ ラベルデータ(正解データ)\n　│\n　└ 検証用データ (10,000個)\n　　 　├ 画像データ\n　　 　└ ラベルデータ（正解データ）\n```\n各画像データに対して正解データであるラベルデータが一つずつ与えられています。\n\n\n## 2. NN(Neural Network)について\n\nここでは、MNISTデータを解析する際に使用するNNという手法について説明します。\nNNとは、ニューラルネットワークの略で、人間の脳内にある神経細胞（ニューロン）とそのつながり、つまり神経回路網を人工ニューロンという数式的なモデルで表現したものです。\n入力層、出力層、隠れ層から構成されていて、層と層の間には、ニューロン同士のつながりの強さを示す「重み」があります。\n\n![img](./img/NN.PNG \"ニューラルネットワークについて\")\n\n画像より特徴を抽出して、ノードの重みを更新していき学習させていきます。\n本事例では、MNISTのデータセットを用いたので28*28ピクセルの入力から0~9の数字のどれかという出力を出すために入力層を784ノード、出力層を10ノードとしています。\n\n## 3. ワークフロー作成\n新規プロジェクトを作成し、taskコンポーネントを2つ追加してください。\nそれぞれのコンポーネントの名前は __train__ __estimate__としてください。\n\n### trainコンポーネントの設定\n__trainコンポーネントに\n__run.sh__  という名前で新規ファイルを作成し次の内容を記入してください。\n\n```\n#PJM --rsc-list \"elapse=01:00:00\"\n#PJM -L \"node=1\"\n#PJM -x PJM_LLIO_GFSCACHE=/vol0004\n\n\nexport PATH=/home/apps/oss/TensorFlow-2.2.0/bin:$PATH\nexport LD_LIBRARY_PATH=/home/apps/oss/TensorFlow-2.2.0/lib:$LD_LIBRARY_PATH\n\ncat  <<EOF >kerasMnist.py\nfrom tensorflow import keras\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, InputLayer\nfrom tensorflow.keras.optimizers import RMSprop\n\nprint('download data')\n# load mnist data\n(x_train, y_train), (x_test, y_test) = mnist.load_data()\nprint('download done')\n\n# set input data\nx_train  = x_train.reshape(60000, 784)\nx_test   = x_test.reshape(10000, 784)\nx_train  = x_train.astype('float32')\nx_test   = x_test.astype('float32')\nx_train /= 255\nx_test  /= 255\ny_train  = keras.utils.to_categorical(y_train, 10)\ny_test   = keras.utils.to_categorical(y_test, 10)\n\n# create model\nmodel = Sequential()\nmodel.add(InputLayer(input_shape=(784,)))\nmodel.add(Dense(10, activation='softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='rmsprop', metrics=['accuracy'])\n\n\n# train model\nprint('start learning')\nepochs = 20\nbatch_size = 128\nhistory = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=1, validation_data=(x_test, y_test))\n\n# save weights\nprint('save weights')\nmodel.save_weights('param.hdf5')\nEOF\n\npython kerasMnist.py > learn.log\n\n```\n\nコンポーネントのプロパティ画面を開いて、以下の5項目を設定してください\n\n- script: run.sh\n- host: fugaku\n- useJobScheduler: 有効\n- outputFile: param.hdf5\n- include learn.log\n\n### estimateコンポーネントの設定\n__estimateコンポーネントに\n__run.sh__  という名前で新規ファイルを作成し次の内容を記入してください。\n\n```\n#PJM --rsc-list \"elapse=01:00:00\"\n#PJM -L \"node=1\"\n#PJM -x PJM_LLIO_GFSCACHE=/vol0004\n\n\nexport PATH=/home/apps/oss/TensorFlow-2.2.0/bin:$PATH\nexport LD_LIBRARY_PATH=/home/apps/oss/TensorFlow-2.2.0/lib:$LD_LIBRARY_PATH\n\ncat  <<EOF >kerasMnist.py\nfrom tensorflow import keras\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, InputLayer\nfrom tensorflow.keras.optimizers import RMSprop\n\nprint('download data')\n# load mnist data\n(x_train, y_train), (x_test, y_test) = mnist.load_data()\nprint('download done')\n\n# set input data\nx_test   = x_test.reshape(10000, 784)\nx_test   = x_test.astype('float32')\nx_test  /= 255\ny_test   = keras.utils.to_categorical(y_test, 10)\n\n# create model\nmodel = Sequential()\nmodel.add(InputLayer(input_shape=(784,)))\nmodel.add(Dense(10, activation='softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='rmsprop', metrics=['accuracy'])\n\n# load weights\nprint('loadweights')\nmodel.load_weights('param.hdf5')\n\n# eval model\nprint('eval')\nscore = model.evaluate(x_test, y_test, verbose=1)\nprint()\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nEOF\n\npython kerasMnist.py > eval.log\n```\n\nコンポーネントのプロパティ画面を開いて、以下の4項目を設定してください\n\n- script: run.sh\n- host: fugaku\n- useJobScheduler: 有効\n- include: eval.log\n\n## 5. 実行結果の確認\n\n解析結果の確認を行います。\n実行完了後、リモートタスクに作成された「log.kerasMNIST」,「log.kerasMNISTEval」ファイルより以下の結果を確認することができます。\n```\n・\n・\n・\n('Test loss:', 0.27075190788507464)\n('Test accuracy:', 0.927)\n```\n\n用語の意味は以下の通りとなっています。\n\n| プロパティ名 | 設定値 |\n| ---- | ---- |\n| Test loss | 学習用データを与えた時の損失値。小さくなればなるほど正しい結果を表せています |\n| Test accuracy | 検証用データの正答率。1に近いほど検証用データにおいて精度が高いことを表しています |\n\naccuracyが「0.927」すなわち検証用データにおいて精度92.7%の学習モデルが作成されたことが確認できます。\nTensorFlowを利用したMNISTデータ解析ワークフロー例は以上になります。\n",
      "html": "<h1 id=\"tensorflow%E3%82%92%E5%88%A9%E7%94%A8%E3%81%97%E3%81%9Fmnist%E3%83%87%E3%83%BC%E3%82%BF%E8%A7%A3%E6%9E%90%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC\">TensorFlowを利用したMNISTデータ解析ワークフロー <a class=\"heading-anchor-permalink\" href=\"#tensorflow%E3%82%92%E5%88%A9%E7%94%A8%E3%81%97%E3%81%9Fmnist%E3%83%87%E3%83%BC%E3%82%BF%E8%A7%A3%E6%9E%90%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC\">#</a></h1>\n<p>本章では、WHEELを用いた計算事例として「TensorFlowを利用したMNISTデータの解析ワークフロー」を紹介します。</p>\n<p>目次</p>\n<ol>\n<li>MNISTデータについて</li>\n<li>NN(Neural Network)について</li>\n<li>kerasについて</li>\n<li>ワークフローの作成</li>\n<li>ジョブの投入</li>\n<li>解析結果の確認</li>\n</ol>\n<h2 id=\"1.-%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC%E6%A6%82%E8%A6%81\">1. ワークフロー概要 <a class=\"heading-anchor-permalink\" href=\"#1.-%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC%E6%A6%82%E8%A6%81\">#</a></h2>\n<p>本事例では、富岳上でTensorFlow利用して、\nMNISTデータを用いた手書き数字画像学習モデルの作成と\n推論を行ないます。</p>\n<p>MNISTデータとは手書き数字画像60000枚とテスト画像10000枚を集めた画像データセットのことであり、\nニューラルネットワークを学習するうえで非常に便利な画像のデータセットとして著名です。\nデータセットの中身は以下のような構造になっています。</p>\n<pre><code>MNISTデータ\n　├ 学習用データ (60,000個)\n　│ 　├ 画像データ\n　│ 　└ ラベルデータ(正解データ)\n　│\n　└ 検証用データ (10,000個)\n　　 　├ 画像データ\n　　 　└ ラベルデータ（正解データ）\n</code></pre>\n<p>各画像データに対して正解データであるラベルデータが一つずつ与えられています。</p>\n<h2 id=\"2.-nn(neural-network)%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">2. NN(Neural Network)について <a class=\"heading-anchor-permalink\" href=\"#2.-nn(neural-network)%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">#</a></h2>\n<p>ここでは、MNISTデータを解析する際に使用するNNという手法について説明します。\nNNとは、ニューラルネットワークの略で、人間の脳内にある神経細胞（ニューロン）とそのつながり、つまり神経回路網を人工ニューロンという数式的なモデルで表現したものです。\n入力層、出力層、隠れ層から構成されていて、層と層の間には、ニューロン同士のつながりの強さを示す「重み」があります。</p>\n<p><img src=\"./img/NN.PNG\" alt=\"img\" title=\"ニューラルネットワークについて\"></p>\n<p>画像より特徴を抽出して、ノードの重みを更新していき学習させていきます。\n本事例では、MNISTのデータセットを用いたので28*28ピクセルの入力から0~9の数字のどれかという出力を出すために入力層を784ノード、出力層を10ノードとしています。</p>\n<h2 id=\"3.-%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC%E4%BD%9C%E6%88%90\">3. ワークフロー作成 <a class=\"heading-anchor-permalink\" href=\"#3.-%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC%E4%BD%9C%E6%88%90\">#</a></h2>\n<p>新規プロジェクトを作成し、taskコンポーネントを2つ追加してください。\nそれぞれのコンポーネントの名前は <strong>train</strong> __estimate__としてください。</p>\n<h3 id=\"train%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">trainコンポーネントの設定 <a class=\"heading-anchor-permalink\" href=\"#train%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">#</a></h3>\n<p>__trainコンポーネントに\n<strong><a href=\"http://run.sh\">run.sh</a></strong>  という名前で新規ファイルを作成し次の内容を記入してください。</p>\n<pre><code>#PJM --rsc-list &quot;elapse=01:00:00&quot;\n#PJM -L &quot;node=1&quot;\n#PJM -x PJM_LLIO_GFSCACHE=/vol0004\n\n\nexport PATH=/home/apps/oss/TensorFlow-2.2.0/bin:$PATH\nexport LD_LIBRARY_PATH=/home/apps/oss/TensorFlow-2.2.0/lib:$LD_LIBRARY_PATH\n\ncat  &lt;&lt;EOF &gt;kerasMnist.py\nfrom tensorflow import keras\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, InputLayer\nfrom tensorflow.keras.optimizers import RMSprop\n\nprint('download data')\n# load mnist data\n(x_train, y_train), (x_test, y_test) = mnist.load_data()\nprint('download done')\n\n# set input data\nx_train  = x_train.reshape(60000, 784)\nx_test   = x_test.reshape(10000, 784)\nx_train  = x_train.astype('float32')\nx_test   = x_test.astype('float32')\nx_train /= 255\nx_test  /= 255\ny_train  = keras.utils.to_categorical(y_train, 10)\ny_test   = keras.utils.to_categorical(y_test, 10)\n\n# create model\nmodel = Sequential()\nmodel.add(InputLayer(input_shape=(784,)))\nmodel.add(Dense(10, activation='softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='rmsprop', metrics=['accuracy'])\n\n\n# train model\nprint('start learning')\nepochs = 20\nbatch_size = 128\nhistory = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=1, validation_data=(x_test, y_test))\n\n# save weights\nprint('save weights')\nmodel.save_weights('param.hdf5')\nEOF\n\npython kerasMnist.py &gt; learn.log\n\n</code></pre>\n<p>コンポーネントのプロパティ画面を開いて、以下の5項目を設定してください</p>\n<ul>\n<li>script: <a href=\"http://run.sh\">run.sh</a></li>\n<li>host: fugaku</li>\n<li>useJobScheduler: 有効</li>\n<li>outputFile: param.hdf5</li>\n<li>include learn.log</li>\n</ul>\n<h3 id=\"estimate%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">estimateコンポーネントの設定 <a class=\"heading-anchor-permalink\" href=\"#estimate%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A8%AD%E5%AE%9A\">#</a></h3>\n<p>__estimateコンポーネントに\n<strong><a href=\"http://run.sh\">run.sh</a></strong>  という名前で新規ファイルを作成し次の内容を記入してください。</p>\n<pre><code>#PJM --rsc-list &quot;elapse=01:00:00&quot;\n#PJM -L &quot;node=1&quot;\n#PJM -x PJM_LLIO_GFSCACHE=/vol0004\n\n\nexport PATH=/home/apps/oss/TensorFlow-2.2.0/bin:$PATH\nexport LD_LIBRARY_PATH=/home/apps/oss/TensorFlow-2.2.0/lib:$LD_LIBRARY_PATH\n\ncat  &lt;&lt;EOF &gt;kerasMnist.py\nfrom tensorflow import keras\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Dropout, InputLayer\nfrom tensorflow.keras.optimizers import RMSprop\n\nprint('download data')\n# load mnist data\n(x_train, y_train), (x_test, y_test) = mnist.load_data()\nprint('download done')\n\n# set input data\nx_test   = x_test.reshape(10000, 784)\nx_test   = x_test.astype('float32')\nx_test  /= 255\ny_test   = keras.utils.to_categorical(y_test, 10)\n\n# create model\nmodel = Sequential()\nmodel.add(InputLayer(input_shape=(784,)))\nmodel.add(Dense(10, activation='softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='rmsprop', metrics=['accuracy'])\n\n# load weights\nprint('loadweights')\nmodel.load_weights('param.hdf5')\n\n# eval model\nprint('eval')\nscore = model.evaluate(x_test, y_test, verbose=1)\nprint()\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\nEOF\n\npython kerasMnist.py &gt; eval.log\n</code></pre>\n<p>コンポーネントのプロパティ画面を開いて、以下の4項目を設定してください</p>\n<ul>\n<li>script: <a href=\"http://run.sh\">run.sh</a></li>\n<li>host: fugaku</li>\n<li>useJobScheduler: 有効</li>\n<li>include: eval.log</li>\n</ul>\n<h2 id=\"5.-%E5%AE%9F%E8%A1%8C%E7%B5%90%E6%9E%9C%E3%81%AE%E7%A2%BA%E8%AA%8D\">5. 実行結果の確認 <a class=\"heading-anchor-permalink\" href=\"#5.-%E5%AE%9F%E8%A1%8C%E7%B5%90%E6%9E%9C%E3%81%AE%E7%A2%BA%E8%AA%8D\">#</a></h2>\n<p>解析結果の確認を行います。\n実行完了後、リモートタスクに作成された「log.kerasMNIST」,「log.kerasMNISTEval」ファイルより以下の結果を確認することができます。</p>\n<pre><code>・\n・\n・\n('Test loss:', 0.27075190788507464)\n('Test accuracy:', 0.927)\n</code></pre>\n<p>用語の意味は以下の通りとなっています。</p>\n<table>\n<thead>\n<tr>\n<th>プロパティ名</th>\n<th>設定値</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Test loss</td>\n<td>学習用データを与えた時の損失値。小さくなればなるほど正しい結果を表せています</td>\n</tr>\n<tr>\n<td>Test accuracy</td>\n<td>検証用データの正答率。1に近いほど検証用データにおいて精度が高いことを表しています</td>\n</tr>\n</tbody>\n</table>\n<p>accuracyが「0.927」すなわち検証用データにおいて精度92.7%の学習モデルが作成されたことが確認できます。\nTensorFlowを利用したMNISTデータ解析ワークフロー例は以上になります。</p>\n",
      "id": 6
    },
    {
      "path": "2_tutorial/3_application_tutorial/index.md",
      "url": "2_tutorial/3_application_tutorial/index.html",
      "content": "# Application tutorial\n\n## 実践編チュートリアルについて\n実践編チュートリアルでは、富岳を利用してOpenFOAM, TensorFlowといった\nアプリケーションを使ったワークフローを作成、実行します。\n\n全てのチュートリアルにおいて、リモートホストとして __fugaku__ という名前で\n富岳にアクセスできることを前提としていますので、\n事前に富岳のリモートホスト設定を作成してから、チュートリアルを始めてください。\n\nリモートホスト設定の作成方法については、[基礎編](../1_basic_tutorial/index.md) の6章をご参照ください。\n\n[OpenFOAMを利用したcavityケースの解析ワークフロー](1_OpenFOAM_cavity/index.md)\n\n[OpenFOAMを利用したパラメトリックスタディ解析ワークフロー](2_OpenFOAM_PS/index.md)\n\n[TensorFlowを利用したMNISTデータ解析ワークフロー](3_TensorFlow_mnist/index.md)\n",
      "html": "<h1 id=\"application-tutorial\">Application tutorial <a class=\"heading-anchor-permalink\" href=\"#application-tutorial\">#</a></h1>\n<h2 id=\"%E5%AE%9F%E8%B7%B5%E7%B7%A8%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">実践編チュートリアルについて <a class=\"heading-anchor-permalink\" href=\"#%E5%AE%9F%E8%B7%B5%E7%B7%A8%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">#</a></h2>\n<p>実践編チュートリアルでは、富岳を利用してOpenFOAM, TensorFlowといった\nアプリケーションを使ったワークフローを作成、実行します。</p>\n<p>全てのチュートリアルにおいて、リモートホストとして <strong>fugaku</strong> という名前で\n富岳にアクセスできることを前提としていますので、\n事前に富岳のリモートホスト設定を作成してから、チュートリアルを始めてください。</p>\n<p>リモートホスト設定の作成方法については、<a href=\"../1_basic_tutorial/index.html\">基礎編</a> の6章をご参照ください。</p>\n<p><a href=\"1_OpenFOAM_cavity/index.html\">OpenFOAMを利用したcavityケースの解析ワークフロー</a></p>\n<p><a href=\"2_OpenFOAM_PS/index.html\">OpenFOAMを利用したパラメトリックスタディ解析ワークフロー</a></p>\n<p><a href=\"3_TensorFlow_mnist/index.html\">TensorFlowを利用したMNISTデータ解析ワークフロー</a></p>\n",
      "id": 7
    },
    {
      "path": "2_tutorial/index.md",
      "url": "2_tutorial/index.html",
      "content": "# WHEEL チュートリアル\n\n本チュートリアルは3段階に分かれています。\n\n初めてWHEELを使う方はまず基礎編をご覧ください。\nワークフロー作成に必須の機能を順に解説しています。\n\n[基礎編](1_basic_tutorial/index.md)\n\n[応用編](2_advanced_tutorial/index.md)\n\n[実践編](3_application_tutorial/index.md)\n\nまた、旧バージョンのWHEELを使ったものですがビデオ資料も以下のURLで公開されています。\n\n[基本編 日本語](https://youtu.be/1sh_XA6o7Zw)\n\n[応用編 日本語](https://youtu.be/1c-88BGdhPM)\n\n[基本編 英語](https://youtu.be/10FP6lnVISk)\n\n[応用編 英語](https://youtu.be/XR-zGcDhR50)\n\n--------\n[トップページに戻る](../index.md)\n",
      "html": "<h1 id=\"wheel-%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB\">WHEEL チュートリアル <a class=\"heading-anchor-permalink\" href=\"#wheel-%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB\">#</a></h1>\n<p>本チュートリアルは3段階に分かれています。</p>\n<p>初めてWHEELを使う方はまず基礎編をご覧ください。\nワークフロー作成に必須の機能を順に解説しています。</p>\n<p><a href=\"1_basic_tutorial/index.html\">基礎編</a></p>\n<p><a href=\"2_advanced_tutorial/index.html\">応用編</a></p>\n<p><a href=\"3_application_tutorial/index.html\">実践編</a></p>\n<p>また、旧バージョンのWHEELを使ったものですがビデオ資料も以下のURLで公開されています。</p>\n<p><a href=\"https://youtu.be/1sh_XA6o7Zw\">基本編 日本語</a></p>\n<p><a href=\"https://youtu.be/1c-88BGdhPM\">応用編 日本語</a></p>\n<p><a href=\"https://youtu.be/10FP6lnVISk\">基本編 英語</a></p>\n<p><a href=\"https://youtu.be/XR-zGcDhR50\">応用編 英語</a></p>\n<hr>\n<p><a href=\"../index.html\">トップページに戻る</a></p>\n",
      "id": 8
    },
    {
      "path": "3_reference_manual/1_home_screen/index.md",
      "url": "3_reference_manual/1_home_screen/index.html",
      "content": "# プロジェクトの作成と編集\n新規プロジェクトの作成や既存プロジェクトの編集はホーム画面で行います。\nホーム画面の構成は以下のようになっています。\n\n![img](./img/home.png \"home\")\n1. Open ボタン                : 既存プロジェクトを開く\n1. New ボタン                 : 新規プロジェクトの作成\n1. Remove from list ボタン    : 画面下部のプロジェクト一覧に表示されているプロジェクトを表示しないようにする\n1. Remove ボタン              : プロジェクトの削除\n1. batch mode スイッチ        : 複数プロジェクトの一括削除モードへの切り替えスイッチ\n1. ナビゲーションドロワー     : ユーザガイド、リモートホスト設定画面へのリンクを含むドロアーを開く\n1. プロジェクト一覧表示エリア : 過去に開いたプロジェクトのリスト\n\nプロジェクト一覧表示エリアには、以下の項目が表示されます。\n- 名前\n- 説明文\n- プロジェクトファイルのルートディレクトリパス\n- 作成日\n- 更新日\n- 実行状況\n\n\n## 1. 新規プロジェクトの作成\n次の手順で新規プロジェクトを作成します。\n\n1. [New] ボタンをクリックし、新規プロジェクト作成ダイアログを表示させる\n1. ダイアログ下部のディレクトリツリーでプロジェクトデータ作成場所を選択する\n1. プロジェクト名を入力する\n1. [CREATE] ボタンをクリックする\n\n![img](./img/new.png \"new\")\n\n新規プロジェクトが作成されると、プロジェクト一覧に表示されるので次の「プロジェクトを開く」の手順に沿って\nワークフロー画面に遷移してください。\n\n## 2. プロジェクトを開く\n次の手順で、プロジェクトを開いてワークフロー画面に遷移します。\n1. プロジェクト一覧表示エリアで開きたいプロジェクト名の左にあるチェックボックスをクリックして選択します。\n1. [OPEN] ボタンをクリックするとワークフロー画面に遷移します。\n\n![img](./img/open.png \"open\")\n\n## 3. プロジェクト名の変更\nプロジェクト一覧表示部分のプロジェクト名をクリックすると、プロジェクト名変更ダイアログが表示されます。\nプロジェクト名を編集してenterキーを押下するとプロジェクト名が変更されます。\n\n![img](./img/changeName.png \"changeName\")\n\nなお、プロジェクト名はディレクトリ名の一部として使われるため同名のディレクトリが既に存在する場合などは、末尾に.1,\n(.1も使われている時は.2 .3・・・と順次大きい数値)を追加した名前に変更されます\n\n## 4. プロジェクトの削除\n次の手順でプロジェクトを削除します。\n1. プロジェクト一覧表示エリアで削除したいプロジェクト名の左にあるチェックボックスをクリックして選択します。\n1. [REMOVE] ボタンをクリックすると選択したプロジェクトが削除されます。\n   この時、代わりに [REMOVE FROM LIST] ボタンをクリックすると、\n   プロジェクト一覧表示からは削除されますが、プロジェクトの実体となるファイルはサーバ側に残したままにできます。\n\n## 5. 複数プロジェクトの一括削除\n[batch mode] スイッチを有効にすると、複数のプロジェクトを選択できるようになり\nこの状態で、[REMOVE]または[REMOVE FROM LIST] ボタンをクリックすると複数プロジェクトを\n一括で削除することができます。\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90%E3%81%A8%E7%B7%A8%E9%9B%86\">プロジェクトの作成と編集 <a class=\"heading-anchor-permalink\" href=\"#%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90%E3%81%A8%E7%B7%A8%E9%9B%86\">#</a></h1>\n<p>新規プロジェクトの作成や既存プロジェクトの編集はホーム画面で行います。\nホーム画面の構成は以下のようになっています。</p>\n<p><img src=\"./img/home.png\" alt=\"img\" title=\"home\"></p>\n<ol>\n<li>Open ボタン                : 既存プロジェクトを開く</li>\n<li>New ボタン                 : 新規プロジェクトの作成</li>\n<li>Remove from list ボタン    : 画面下部のプロジェクト一覧に表示されているプロジェクトを表示しないようにする</li>\n<li>Remove ボタン              : プロジェクトの削除</li>\n<li>batch mode スイッチ        : 複数プロジェクトの一括削除モードへの切り替えスイッチ</li>\n<li>ナビゲーションドロワー     : ユーザガイド、リモートホスト設定画面へのリンクを含むドロアーを開く</li>\n<li>プロジェクト一覧表示エリア : 過去に開いたプロジェクトのリスト</li>\n</ol>\n<p>プロジェクト一覧表示エリアには、以下の項目が表示されます。</p>\n<ul>\n<li>名前</li>\n<li>説明文</li>\n<li>プロジェクトファイルのルートディレクトリパス</li>\n<li>作成日</li>\n<li>更新日</li>\n<li>実行状況</li>\n</ul>\n<h2 id=\"1.-%E6%96%B0%E8%A6%8F%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90\">1. 新規プロジェクトの作成 <a class=\"heading-anchor-permalink\" href=\"#1.-%E6%96%B0%E8%A6%8F%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90\">#</a></h2>\n<p>次の手順で新規プロジェクトを作成します。</p>\n<ol>\n<li>[New] ボタンをクリックし、新規プロジェクト作成ダイアログを表示させる</li>\n<li>ダイアログ下部のディレクトリツリーでプロジェクトデータ作成場所を選択する</li>\n<li>プロジェクト名を入力する</li>\n<li>[CREATE] ボタンをクリックする</li>\n</ol>\n<p><img src=\"./img/new.png\" alt=\"img\" title=\"new\"></p>\n<p>新規プロジェクトが作成されると、プロジェクト一覧に表示されるので次の「プロジェクトを開く」の手順に沿って\nワークフロー画面に遷移してください。</p>\n<h2 id=\"2.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E9%96%8B%E3%81%8F\">2. プロジェクトを開く <a class=\"heading-anchor-permalink\" href=\"#2.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E9%96%8B%E3%81%8F\">#</a></h2>\n<p>次の手順で、プロジェクトを開いてワークフロー画面に遷移します。</p>\n<ol>\n<li>プロジェクト一覧表示エリアで開きたいプロジェクト名の左にあるチェックボックスをクリックして選択します。</li>\n<li>[OPEN] ボタンをクリックするとワークフロー画面に遷移します。</li>\n</ol>\n<p><img src=\"./img/open.png\" alt=\"img\" title=\"open\"></p>\n<h2 id=\"3.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E5%90%8D%E3%81%AE%E5%A4%89%E6%9B%B4\">3. プロジェクト名の変更 <a class=\"heading-anchor-permalink\" href=\"#3.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E5%90%8D%E3%81%AE%E5%A4%89%E6%9B%B4\">#</a></h2>\n<p>プロジェクト一覧表示部分のプロジェクト名をクリックすると、プロジェクト名変更ダイアログが表示されます。\nプロジェクト名を編集してenterキーを押下するとプロジェクト名が変更されます。</p>\n<p><img src=\"./img/changeName.png\" alt=\"img\" title=\"changeName\"></p>\n<p>なお、プロジェクト名はディレクトリ名の一部として使われるため同名のディレクトリが既に存在する場合などは、末尾に.1,\n(.1も使われている時は.2 .3・・・と順次大きい数値)を追加した名前に変更されます</p>\n<h2 id=\"4.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%89%8A%E9%99%A4\">4. プロジェクトの削除 <a class=\"heading-anchor-permalink\" href=\"#4.-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%89%8A%E9%99%A4\">#</a></h2>\n<p>次の手順でプロジェクトを削除します。</p>\n<ol>\n<li>プロジェクト一覧表示エリアで削除したいプロジェクト名の左にあるチェックボックスをクリックして選択します。</li>\n<li>[REMOVE] ボタンをクリックすると選択したプロジェクトが削除されます。\nこの時、代わりに [REMOVE FROM LIST] ボタンをクリックすると、\nプロジェクト一覧表示からは削除されますが、プロジェクトの実体となるファイルはサーバ側に残したままにできます。</li>\n</ol>\n<h2 id=\"5.-%E8%A4%87%E6%95%B0%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%B8%80%E6%8B%AC%E5%89%8A%E9%99%A4\">5. 複数プロジェクトの一括削除 <a class=\"heading-anchor-permalink\" href=\"#5.-%E8%A4%87%E6%95%B0%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%B8%80%E6%8B%AC%E5%89%8A%E9%99%A4\">#</a></h2>\n<p>[batch mode] スイッチを有効にすると、複数のプロジェクトを選択できるようになり\nこの状態で、[REMOVE]または[REMOVE FROM LIST] ボタンをクリックすると複数プロジェクトを\n一括で削除することができます。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 9
    },
    {
      "path": "3_reference_manual/2_remotehost_screen/index.md",
      "url": "3_reference_manual/2_remotehost_screen/index.html",
      "content": "# リモートホストの登録\nワークフロー内でWHEELサーバ外の計算環境（以下、リモートホスト）を用いる場合、対象とするリモートホストにSSH接続し処理を実行します。\nWHEELでは、ワークフロー画面（Taskコンポーネント）にて使用するリモートホストの情報及びリモートホストに登録されているユーザ情報をリモートホスト登録画面にて設定します。\n\n## リモートホスト登録画面への移動\nリモートホスト登録画面は、画面右上のハンバーガーメニューをクリックした時に表示されるリンクを\nクリックすると表示されます\n\n![img](./img/hanberger.png \"hanberger.png\")\n![img](./img/drawer.png \"drawer.png\")\n\n\n## リモートホスト登録画面\nリモートホスト登録画面の構成は以下のようになっています。\n![img](./img/remotehost.png \"remotehost\")\n\n1. タイトル　：ホーム画面遷移ボタン\n1. 新規リモートホスト登録ボタン：リモートホストへの接続情報を新しく作成します\n1. 新規クラウド設定登録ボタン  ：クラウド上にクラスタを構成する設定を新しく作成します\n1. リモートホストリスト：登録済みリモートホスト情報\n    1. テストボタン: 設定した接続情報でリモートホストにアクセスできるかどうかを確認します\n    1. 編集ボタン  : 入力済の接続情報を編集します\n    1. 削除ボタン  : 入力済の接続情報を削除します\n\n### 新規リモートホスト登録画面\n新規リモートホスト登録ボタンをクリックすると次の画面が表示されます。\n\n![img](./img/new_remotehost.png \"new_remotehost\")\n\nフォームの各部には次の情報を設定してください。\n\n|||\n|----------|---------------------------------|\n|label| 接続情報を区別するための一意な文字列|\n|Hostname| 接続先のホスト名(IPアドレスでも可)|\n|Port number| 接続先のポート番号|\n|User ID| ログインに使用するユーザ名|\n|Host work dir| 接続先で、実行に使うディレクトリの最上位のパス|\n|use public key authentication| on にすると公開鍵認証が、offにするとパスワード認証が使われます。|\n|private key path|秘密鍵のファイルパス(use public key...がonの時のみ表示されます |\n|job scheduler|リモートホストで使われているジョブサーバ|\n|max number of jobs|同時に投入するジョブの最大値|\n|available queues|リモートホスト上で利用可能なキューの名前。カンマ区切りで記載してください|\n|use bulkjob|(富岳のみ)バルクジョブを使えるサイトかどうか|\n|use stepjob|(富岳のみ)ステップジョブを使えるサイトかどうか|\n|shared host|ストレージを共用している他のリモートホストのラベル|\n|shared path on shared host|shared host上でHost work dirへアクセスするためのパス|\n\n`Advanced settings`の右にある▽をクリックすると、詳細設定の入力フォームが開きます。\n\n![img](./img/new_remotehost_advance.png \"new_remotehost_advance\")\n\n|||\n|----------|---------------------------------|\n| connection renewal interval(min.) | sshを定期的に再接続する時の間隔 [分]<br> 0の時(デフォルト)は再接続しない|\n| connection renewal delay(sec.) | 再接続時の待ち時間[秒] （デフォルト値 0）|\n| status check interval(sec.) | ジョブ投入後のステータス確認を行う間隔[秒]（デフォルト値 10）|\n| max number of status check error allowed | ステータス確認の失敗を何回まで許容するか|\n| interval time between each executions | 1つのジョブ実行が終わった後、次のジョブを実行するまでの待ち時間[秒] |\n| timeout during handhake phase(msec.) | sshのハンドシェイク時の待ち時間[ミリ秒]|\n| interval time between keep alive packet(msec.) | sshクライアントがkeep alive packetを投げる間隔[ミリ秒]|\n\n必要な情報を入力し、OKボタンをクリックするとリモートホスト接続設定が保存されます。\n\n### Cloud\n詳細は[Cloud(AWS)インスタンス利用方法](../../../doc/Cloud.md)を参照ください\n\n新規クラウド設定登録ボタンをクリックすると次の画面が表示されます。\n\n![img](./img/new_cloud.png \"new_cloud\")\n\nフォームの各部には次の情報を設定してください。\n\n||||\n|----|----|----|\n| Label | リモートホスト識別ラベル | 重複不可 * |\n| Cloud service provider | クラウドサービスプロバイダー名 | 現バージョン(ver2.1.0)では、「aws」のみ対応 * |\n| OS | OS名 | 現バージョン(ver2.1.0)では、「ubuntu16」のみ対応 * |\n| region | インスタンスを起動するリージョン | *  ex. ap-northeast-1 |\n| numNodes | 起動するノード数 | * |\n| InstanceType | 起動するインスタンスタイプ | * ex. t2.micro |\n| rootVolume | rootのEBSボリューム | 起動するインスタンスにアタッチされるrootのEBSボリュームのサイズ（デフォルト値 8 [GB]） |\n| shareStorage | 共有ストレージの利用設定 |（デフォルト値 利用する）|\n| mpi | MPI | ー |\n| compiler | コンパイラ | ー |\n| playbook | 起動時に実行されるplaybook | ー |\n| additionalParams | aws-sdkのEC2.runInstancesに渡すことのできる設定値 | access keyおよび secret access key等を設定可能 |\n| additionalParamsForHead | additionalParamsのうちヘッドノードのみに適用する値 | ー |\n| JobScheduler | WHEELに登録されているジョブスケジューラ名 | app/config/jobSceduler.jsonに定義されているジョブスケジューラ名を設定する <br> ただし、インスタンスにジョブスケジューラがインストールされている必要がある。<br> ジョブスケジューラ「PBSPro」を設定した場合、WHEELが起動するクラスタにPBSProをインストールする|\n| Max Job | ジョブ投入制限数 | 接続先リモートホストから同時に投入できる最大ジョブ数（デフォルト値 5）|\n| Queue | Queue名 | 接続先ホストからジョブを投入する時に使えるキュー、カンマ区切りで複数入力可（ex. A, B, C）|\n\n`Advance settings` の項目はリモートホストと同じです。\n\n必要な情報を入力し、OKボタンをクリックするとクラウド設定が登録されます。\n\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%9B%E3%82%B9%E3%83%88%E3%81%AE%E7%99%BB%E9%8C%B2\">リモートホストの登録 <a class=\"heading-anchor-permalink\" href=\"#%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%9B%E3%82%B9%E3%83%88%E3%81%AE%E7%99%BB%E9%8C%B2\">#</a></h1>\n<p>ワークフロー内でWHEELサーバ外の計算環境（以下、リモートホスト）を用いる場合、対象とするリモートホストにSSH接続し処理を実行します。\nWHEELでは、ワークフロー画面（Taskコンポーネント）にて使用するリモートホストの情報及びリモートホストに登録されているユーザ情報をリモートホスト登録画面にて設定します。</p>\n<h2 id=\"%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%9B%E3%82%B9%E3%83%88%E7%99%BB%E9%8C%B2%E7%94%BB%E9%9D%A2%E3%81%B8%E3%81%AE%E7%A7%BB%E5%8B%95\">リモートホスト登録画面への移動 <a class=\"heading-anchor-permalink\" href=\"#%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%9B%E3%82%B9%E3%83%88%E7%99%BB%E9%8C%B2%E7%94%BB%E9%9D%A2%E3%81%B8%E3%81%AE%E7%A7%BB%E5%8B%95\">#</a></h2>\n<p>リモートホスト登録画面は、画面右上のハンバーガーメニューをクリックした時に表示されるリンクを\nクリックすると表示されます</p>\n<p><img src=\"./img/hanberger.png\" alt=\"img\" title=\"hanberger.png\">\n<img src=\"./img/drawer.png\" alt=\"img\" title=\"drawer.png\"></p>\n<h2 id=\"%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%9B%E3%82%B9%E3%83%88%E7%99%BB%E9%8C%B2%E7%94%BB%E9%9D%A2\">リモートホスト登録画面 <a class=\"heading-anchor-permalink\" href=\"#%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%9B%E3%82%B9%E3%83%88%E7%99%BB%E9%8C%B2%E7%94%BB%E9%9D%A2\">#</a></h2>\n<p>リモートホスト登録画面の構成は以下のようになっています。\n<img src=\"./img/remotehost.png\" alt=\"img\" title=\"remotehost\"></p>\n<ol>\n<li>タイトル　：ホーム画面遷移ボタン</li>\n<li>新規リモートホスト登録ボタン：リモートホストへの接続情報を新しく作成します</li>\n<li>新規クラウド設定登録ボタン  ：クラウド上にクラスタを構成する設定を新しく作成します</li>\n<li>リモートホストリスト：登録済みリモートホスト情報\n<ol>\n<li>テストボタン: 設定した接続情報でリモートホストにアクセスできるかどうかを確認します</li>\n<li>編集ボタン  : 入力済の接続情報を編集します</li>\n<li>削除ボタン  : 入力済の接続情報を削除します</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"%E6%96%B0%E8%A6%8F%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%9B%E3%82%B9%E3%83%88%E7%99%BB%E9%8C%B2%E7%94%BB%E9%9D%A2\">新規リモートホスト登録画面 <a class=\"heading-anchor-permalink\" href=\"#%E6%96%B0%E8%A6%8F%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%9B%E3%82%B9%E3%83%88%E7%99%BB%E9%8C%B2%E7%94%BB%E9%9D%A2\">#</a></h3>\n<p>新規リモートホスト登録ボタンをクリックすると次の画面が表示されます。</p>\n<p><img src=\"./img/new_remotehost.png\" alt=\"img\" title=\"new_remotehost\"></p>\n<p>フォームの各部には次の情報を設定してください。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>label</td>\n<td>接続情報を区別するための一意な文字列</td>\n</tr>\n<tr>\n<td>Hostname</td>\n<td>接続先のホスト名(IPアドレスでも可)</td>\n</tr>\n<tr>\n<td>Port number</td>\n<td>接続先のポート番号</td>\n</tr>\n<tr>\n<td>User ID</td>\n<td>ログインに使用するユーザ名</td>\n</tr>\n<tr>\n<td>Host work dir</td>\n<td>接続先で、実行に使うディレクトリの最上位のパス</td>\n</tr>\n<tr>\n<td>use public key authentication</td>\n<td>on にすると公開鍵認証が、offにするとパスワード認証が使われます。</td>\n</tr>\n<tr>\n<td>private key path</td>\n<td>秘密鍵のファイルパス(use public key…がonの時のみ表示されます</td>\n</tr>\n<tr>\n<td>job scheduler</td>\n<td>リモートホストで使われているジョブサーバ</td>\n</tr>\n<tr>\n<td>max number of jobs</td>\n<td>同時に投入するジョブの最大値</td>\n</tr>\n<tr>\n<td>available queues</td>\n<td>リモートホスト上で利用可能なキューの名前。カンマ区切りで記載してください</td>\n</tr>\n<tr>\n<td>use bulkjob</td>\n<td>(富岳のみ)バルクジョブを使えるサイトかどうか</td>\n</tr>\n<tr>\n<td>use stepjob</td>\n<td>(富岳のみ)ステップジョブを使えるサイトかどうか</td>\n</tr>\n<tr>\n<td>shared host</td>\n<td>ストレージを共用している他のリモートホストのラベル</td>\n</tr>\n<tr>\n<td>shared path on shared host</td>\n<td>shared host上でHost work dirへアクセスするためのパス</td>\n</tr>\n</tbody>\n</table>\n<p><code>Advanced settings</code>の右にある▽をクリックすると、詳細設定の入力フォームが開きます。</p>\n<p><img src=\"./img/new_remotehost_advance.png\" alt=\"img\" title=\"new_remotehost_advance\"></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>connection renewal interval(min.)</td>\n<td>sshを定期的に再接続する時の間隔 [分]<br> 0の時(デフォルト)は再接続しない</td>\n</tr>\n<tr>\n<td>connection renewal delay(sec.)</td>\n<td>再接続時の待ち時間[秒] （デフォルト値 0）</td>\n</tr>\n<tr>\n<td>status check interval(sec.)</td>\n<td>ジョブ投入後のステータス確認を行う間隔[秒]（デフォルト値 10）</td>\n</tr>\n<tr>\n<td>max number of status check error allowed</td>\n<td>ステータス確認の失敗を何回まで許容するか</td>\n</tr>\n<tr>\n<td>interval time between each executions</td>\n<td>1つのジョブ実行が終わった後、次のジョブを実行するまでの待ち時間[秒]</td>\n</tr>\n<tr>\n<td>timeout during handhake phase(msec.)</td>\n<td>sshのハンドシェイク時の待ち時間[ミリ秒]</td>\n</tr>\n<tr>\n<td>interval time between keep alive packet(msec.)</td>\n<td>sshクライアントがkeep alive packetを投げる間隔[ミリ秒]</td>\n</tr>\n</tbody>\n</table>\n<p>必要な情報を入力し、OKボタンをクリックするとリモートホスト接続設定が保存されます。</p>\n<h3 id=\"cloud\">Cloud <a class=\"heading-anchor-permalink\" href=\"#cloud\">#</a></h3>\n<p>詳細は<a href=\"../../../doc/Cloud.html\">Cloud(AWS)インスタンス利用方法</a>を参照ください</p>\n<p>新規クラウド設定登録ボタンをクリックすると次の画面が表示されます。</p>\n<p><img src=\"./img/new_cloud.png\" alt=\"img\" title=\"new_cloud\"></p>\n<p>フォームの各部には次の情報を設定してください。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Label</td>\n<td>リモートホスト識別ラベル</td>\n<td>重複不可 *</td>\n</tr>\n<tr>\n<td>Cloud service provider</td>\n<td>クラウドサービスプロバイダー名</td>\n<td>現バージョン(ver2.1.0)では、「aws」のみ対応 *</td>\n</tr>\n<tr>\n<td>OS</td>\n<td>OS名</td>\n<td>現バージョン(ver2.1.0)では、「ubuntu16」のみ対応 *</td>\n</tr>\n<tr>\n<td>region</td>\n<td>インスタンスを起動するリージョン</td>\n<td>*  ex. ap-northeast-1</td>\n</tr>\n<tr>\n<td>numNodes</td>\n<td>起動するノード数</td>\n<td>*</td>\n</tr>\n<tr>\n<td>InstanceType</td>\n<td>起動するインスタンスタイプ</td>\n<td>* ex. t2.micro</td>\n</tr>\n<tr>\n<td>rootVolume</td>\n<td>rootのEBSボリューム</td>\n<td>起動するインスタンスにアタッチされるrootのEBSボリュームのサイズ（デフォルト値 8 [GB]）</td>\n</tr>\n<tr>\n<td>shareStorage</td>\n<td>共有ストレージの利用設定</td>\n<td>（デフォルト値 利用する）</td>\n</tr>\n<tr>\n<td>mpi</td>\n<td>MPI</td>\n<td>ー</td>\n</tr>\n<tr>\n<td>compiler</td>\n<td>コンパイラ</td>\n<td>ー</td>\n</tr>\n<tr>\n<td>playbook</td>\n<td>起動時に実行されるplaybook</td>\n<td>ー</td>\n</tr>\n<tr>\n<td>additionalParams</td>\n<td>aws-sdkのEC2.runInstancesに渡すことのできる設定値</td>\n<td>access keyおよび secret access key等を設定可能</td>\n</tr>\n<tr>\n<td>additionalParamsForHead</td>\n<td>additionalParamsのうちヘッドノードのみに適用する値</td>\n<td>ー</td>\n</tr>\n<tr>\n<td>JobScheduler</td>\n<td>WHEELに登録されているジョブスケジューラ名</td>\n<td>app/config/jobSceduler.jsonに定義されているジョブスケジューラ名を設定する <br> ただし、インスタンスにジョブスケジューラがインストールされている必要がある。<br> ジョブスケジューラ「PBSPro」を設定した場合、WHEELが起動するクラスタにPBSProをインストールする</td>\n</tr>\n<tr>\n<td>Max Job</td>\n<td>ジョブ投入制限数</td>\n<td>接続先リモートホストから同時に投入できる最大ジョブ数（デフォルト値 5）</td>\n</tr>\n<tr>\n<td>Queue</td>\n<td>Queue名</td>\n<td>接続先ホストからジョブを投入する時に使えるキュー、カンマ区切りで複数入力可（ex. A, B, C）</td>\n</tr>\n</tbody>\n</table>\n<p><code>Advance settings</code> の項目はリモートホストと同じです。</p>\n<p>必要な情報を入力し、OKボタンをクリックするとクラウド設定が登録されます。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 10
    },
    {
      "path": "3_reference_manual/3_workflow_screen/1_graphview.md",
      "url": "3_reference_manual/3_workflow_screen/1_graphview.html",
      "content": "# 1. グラフビュー画面\n本章では、グラフビュー画面の機能について説明します。\n\nワークフローの作成・実行方法の具体例は、[チュートリアル](../../3_WHEEL_tutorial/index.md)をご参照ください\n\nグラフビュー画面は以下のように構成されています。\n\n![img](./img/workflow_graphview.png \"workflow_graghview\")\n\n 1. タイトル　　　　　　　　　　　　　：ホーム画面遷移ボタン\n 2. プロジェクト名　　　　　　　　　　：ワークフロー編集中のプロジェクト名\n 3. 状態表示エリア　　　　　　　　　　：プロジェクトのstate（実行状態）表示\n 4. 編集日時表示エリア　　　　　　　　：プロジェクトの作成、更新日時\n 5. ワークフロー画面切替ボタン　　　　：グラフビュー、リストビュー、テキストエディタの切替ボタン\n 6. プロジェクト操作ボタンエリア　　　：プロジェクトの実行、停止、クリーンボタン\n 7. プロジェクト編集ボタンエリア　　　：プロジェクトの保存、変更の破棄ボタン\n 8. 階層表示・遷移ボタン　　　　　　　：現在表示中のプロジェクトディレクトリの階層表示\n 9. 環境変数エディタ表示ボタン　　　　：ワークフロー作成用のライブラリ表示用ボタン\n10. コンポーネントライブラリ　　　　　：ワークフローの構成要素であるコンポーネントを追加するためのパレット\n11. ログ表示ボタン　　　　　　　　　　：ワークフローの作成、実行に関するログ表示用ボタン\n\n次に各エリア、ボタンの詳細について説明します。\n\n### 状態表示エリア\n状態表示エリアは、プロジェクト全体の進行状態によって以下の状態を示します。\n\n1. not-started：プロジェクト実行前\n\n![img](./img/not-started.png \"not_started\")\n\n2. running    ：プロジェクト実行中\n\n![img](./img/running.png \"running\")\n\n3. finished   ：プロジェクト終了(正常終了)\n\n![img](./img/finished.png \"finished\")\n\n4. failed     ：プロジェクト終了(エラー発生)\n\n![img](./img/failed.png \"failed\")\n\n5. holding     : 投入済ジョブ確認中\n\n![img](./img/holding.png \"holding\")\n\n6. unknonw     : プロジェクトの状態不明\n\n![img](./img/unknown.png \"unknown\")\n\n### 操作ボタンエリア\nこのエリアには、プロジェクトの実行に関わるボタンが表示されます。\n\n![img](./img/project_control_btn.png \"control_button_area\")\n\n1. run ボタン：プロジェクトの実行開始\n1. stop ボタン：プロジェクトの実行を停止し実行前の状態に戻す\n1. clean：プロジェクトの実行中に生成されたファイルなどを削除し、実行開始前の状態に戻す\n\n### 保存ボタンエリア\nこのエリアには編集したプロジェクトの保存に関わるボタンが表示されます。\n\n![img](./img/project_save.png \"save_button_area\")\n\n1. save ボタン：プロジェクトを保存する\n1. revert ボタン：プロジェクトを直前の保存状態に戻す\n\nWHEELでは、gitを用いたファイル管理を行っております。\nグラフビュー画面上での編集内容はサーバサイドのファイルにすぐに反映されますが\nSAVEボタンをクリックするまではgitリポジトリには登録されません。\nrevertボタンをクリックすると最後にコミットしてから後に行なった変更を全て破棄して\nリポジトリに最後にコミットした時の状態に戻します\n\ngit操作の詳細については開発者向けドキュメント[詳細設計書](../../../doc/design/design.md)をご確認ください。\n\n\n### 画面表示切替ボタン\n初期表示のグラフビュー画面から、listビューおよびテキストエディタ画面へ遷移するためのボタンです\n\n![img](./img/change_view.png \"change_view_area\")\n\n1. graph view ボタン\n2. list view ボタン\n3. テキストエディタボタン\n\nテキストエディタへの遷移は、\nファイルの選択状態やプロジェクトの選択状態によって制限されており、\n遷移できない時はボタンがクリックできない状態になっています。\n\n\n### 階層表示・遷移ボタン\nワークフローはコンポーネントの階層構造を持ちますが、\nグラフビュー画面では同一階層のコンポーネントしか同時に表示できません。\n\n階層表示部には現在表示中のコンポーネントが、プロジェクトのルートコンポーネントから\nどのような階層を降りてきた位置に存在するのか表示します。\n\n![img](./img/breadcrumbs.png \"breadcrumbs\")\n\nまた、階層表示部の左端にある、ツリー表示ボタンをクリックすると\nプロジェクト全体の階層構造が表示されます。\n\n![img](./img/component_tree.png \"component_tree\")\n\nどちらの表示でも、コンポーネントをクリックすると、表示されているコンポーネントに表示が切り替わります。\n\n### 環境変数エディタ表示ボタン\nこのボタンをクリックすると\nプロジェクト内で実行されるシェルスクリプトなどで使える環境変数を\n設定するための画面が表示されます。\n\n![img](./img/environment_variables_editor.png \"environment_variables_editor\")\n\n- name欄に環境変数名、value欄に値を入力して[+]ボタンをクリックすると、新しく環境変数を追加することができます。\n- 環境変数、値ともに表示領域をクリックすることで変更することができます。\n- 右端に表示されているゴミ箱アイコンをクリックすることで設定済の環境変数を削除できます。\n\n設定を変更した後は、[SAVE] ボタンをクリックすることで変更内容が実際に反映されます。\n変更を破棄して終了する場合は [CANCEL] ボタンをクリックしてください。\n\n### ワークフロー作成用エリア\n現在表示中のコンポーネントが持つ子コンポーネントが表示されています。\n初期状態ではプロジェクトのルートコンポーネントの直接の子コンポーネントが表示されています。\n\nこの領域に、コンポーネントライブラリから、ドラッグ&ドロップすることでプロジェクトにコンポーネントを追加します。\n\n表示されているコンポーネントをダブルクリックすることで、\nそのコンポーネントの下位コンポーネントを表示するように切り替わります。\n\n上位コンポーネントへの切り替えは、前述の階層表示部またはコンポーネントツリーを使ってください。\n\n表示されているコンポーネントをシングルクリックすると\nそのコンポーネントの設定値(プロパティ)を編集する領域が表示されます。\n\n![img](./img/component_property.png \"component_property\")\n\n1. closeボタン : プロパティ表示を閉じます\n2. cleanボタン : コンポーネント(もしあれば下位コンポーネントも)の状態を最新の保存状態に巻き戻します\n3. deleteボタン: コンポーネントを削除します\n4. 詳細表示ボタン: プロパティの設定項目の表示/非表示をグループ毎に切り替えます\n\nコンポーネントの種類毎にこの領域に表示される内容は異なります。\nプロパティへの設定内容は[コンポーネント](../4_component/00_common.md)の章をご参照ください\n\n### ファイル操作エリア\nコンポーネントのプロパティを表示した状態で、Filesグループの `4 詳細表示ボタン`を\nクリックすると、次のようなファイル操作エリアが表示されます。\n\n![img](./img/file_area.png \"file area\")\n\n1. ファイル操作ボタン: コンポーネント内のファイル、ディレクトリを操作するボタンです。詳細は後述\n2. ファイル表示エリア: コンポーネント内のファイル、ディレクトリをツリー形式で表示します。\n3. closeボタン: ファイル操作エリアの表示/非表示を切り替えます。\n\nファイル表示エリアには、選択中のコンポーネントディレクトリ以下に存在するファイル、ディレクトリのうち、wheelが使うメタデータファイルや、下位コンポーネントのディレクトリ以外のものが表示されます。\n\nディレクトリおよびディレクトリへのシンボリックリンクの左側に表示されている三角形アイコンをクリックすることで、さらにそのディレクトリ内のファイル等を表示することができます。\n\nファイルやディレクトリのうち、連番で構成されるもの(例えば、file1, file2, file3といったもの)が\n表示対象に含まれている時は、図中の`seq_dir*`や`seq_file*`のような形で1行にまとめて表示されます。\n\nこれらの行の左側に表示されている三角形アイコンをクリックすると、ディレクトリと同じような形で元の連番ファイル/ディレクトリが個々に表示されます。\n\nファイル表示エリアにファイルをドロップすると、コンポーネントディレクトリの直下にファイルをアップロードすることができます。\n\n#### ファイル操作ボタン\nファイル操作エリア上部には、ファイルの操作を行うためのボタンが並んで表示されています。\n\n![img](./img/file_area_button.png \"file area button\")\n\n1. 新規ディレクトリ作成: 表示されている階層に新規ディレクトリを作成します。\n2. 新規ファイル作成: 表示されている階層に新規の空ファイルを作成します\n3. リネーム: 選択中のファイル、ディレクトリ等をリネームします。\n4. 削除: 選択中のファイル、ディレクトリ等を削除します。\n5. アップロード: 表示されている階層にファイルをアップロードします。\n6. ダウンロード: 選択中のファイル、ディレクトリをダウンロードします\n7. 共有: 選択中のファイル、ディレクトリのパスを表示します。\n\n選択中のファイル、ディレクトリを対象とする操作は、非対応の時はボタンが無効化されます。\n\n共有ボタンをクリックすると、次のようなダイアログが表示されます。\n\n![img](./img/share_file.png \"share file dialogue\")\n\n表示されているパスの右にあるアイコンをクリックすると、クリップボードにコピーされるので\n別のアプリへファイルを渡す時などにお使いください。\n\n例えば、jupyterlabであれば、`http(s)://<server:port>/<lab-location>/lab/tree/path/to/notebook.ipynb` といった形式で指定したipynbファイルを開くことができます。ただし、WHEELからコピーされるファイルは絶対パスですが、ここで指定するパス(`path/to/notebook.ipynb`)はワークスペースのrootからの相対パスである必要があります。\n詳細は、jupyterlabのドキュメントをご参照ください。\n\n[File Navigation with tree](https://jupyterlab.readthedocs.io/en/stable/user/urls.html)\n\n\n### ログ表示ボタン\nワークフローの作成時や実行時等に出力されるログを表示します。\n\nボタンをクリックすると、次のようなログ表示エリアが表れます。\n\n![img](./img/log_screen.png \"log_screen\")\n\nログ表示は内容に応じて複数のタブにそれぞれ出力されます。\n\n1. Info：エラー、ワーニングなどの重大な情報と、プロジェクトの実行状況や操作に関する一般的な情報\n1. Stdout：ローカルホストで実行されたtaskの標準出力\n1. Stderr：ローカルホストで実行されたtaskの標準エラー出力\n1. Stdout(SSH)：リモートホストで実行されたtaskの標準出力\n1. Stderr(SSH)：リモートホストで実行されたtaskの標準エラー出力\n\nラベルの色は次の意味を現わします。\n- 青: 現在表示中\n- 緑: 新規情報があり、未表示\n- 灰: 非表示中\n\n[CLEAR ALL LOG] ボタンをクリックすると、それまでに表示された全てのログが消去されます。\n\n最上部の△ボタンをクリックするとログ表示部が下部に折り畳まれます。\n\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"1.-%E3%82%B0%E3%83%A9%E3%83%95%E3%83%93%E3%83%A5%E3%83%BC%E7%94%BB%E9%9D%A2\">1. グラフビュー画面 <a class=\"heading-anchor-permalink\" href=\"#1.-%E3%82%B0%E3%83%A9%E3%83%95%E3%83%93%E3%83%A5%E3%83%BC%E7%94%BB%E9%9D%A2\">#</a></h1>\n<p>本章では、グラフビュー画面の機能について説明します。</p>\n<p>ワークフローの作成・実行方法の具体例は、<a href=\"../../3_WHEEL_tutorial/index.html\">チュートリアル</a>をご参照ください</p>\n<p>グラフビュー画面は以下のように構成されています。</p>\n<p><img src=\"./img/workflow_graphview.png\" alt=\"img\" title=\"workflow_graghview\"></p>\n<ol>\n<li>タイトル　　　　　　　　　　　　　：ホーム画面遷移ボタン</li>\n<li>プロジェクト名　　　　　　　　　　：ワークフロー編集中のプロジェクト名</li>\n<li>状態表示エリア　　　　　　　　　　：プロジェクトのstate（実行状態）表示</li>\n<li>編集日時表示エリア　　　　　　　　：プロジェクトの作成、更新日時</li>\n<li>ワークフロー画面切替ボタン　　　　：グラフビュー、リストビュー、テキストエディタの切替ボタン</li>\n<li>プロジェクト操作ボタンエリア　　　：プロジェクトの実行、停止、クリーンボタン</li>\n<li>プロジェクト編集ボタンエリア　　　：プロジェクトの保存、変更の破棄ボタン</li>\n<li>階層表示・遷移ボタン　　　　　　　：現在表示中のプロジェクトディレクトリの階層表示</li>\n<li>環境変数エディタ表示ボタン　　　　：ワークフロー作成用のライブラリ表示用ボタン</li>\n<li>コンポーネントライブラリ　　　　　：ワークフローの構成要素であるコンポーネントを追加するためのパレット</li>\n<li>ログ表示ボタン　　　　　　　　　　：ワークフローの作成、実行に関するログ表示用ボタン</li>\n</ol>\n<p>次に各エリア、ボタンの詳細について説明します。</p>\n<h3 id=\"%E7%8A%B6%E6%85%8B%E8%A1%A8%E7%A4%BA%E3%82%A8%E3%83%AA%E3%82%A2\">状態表示エリア <a class=\"heading-anchor-permalink\" href=\"#%E7%8A%B6%E6%85%8B%E8%A1%A8%E7%A4%BA%E3%82%A8%E3%83%AA%E3%82%A2\">#</a></h3>\n<p>状態表示エリアは、プロジェクト全体の進行状態によって以下の状態を示します。</p>\n<ol>\n<li>not-started：プロジェクト実行前</li>\n</ol>\n<p><img src=\"./img/not-started.png\" alt=\"img\" title=\"not_started\"></p>\n<ol start=\"2\">\n<li>running    ：プロジェクト実行中</li>\n</ol>\n<p><img src=\"./img/running.png\" alt=\"img\" title=\"running\"></p>\n<ol start=\"3\">\n<li>finished   ：プロジェクト終了(正常終了)</li>\n</ol>\n<p><img src=\"./img/finished.png\" alt=\"img\" title=\"finished\"></p>\n<ol start=\"4\">\n<li>failed     ：プロジェクト終了(エラー発生)</li>\n</ol>\n<p><img src=\"./img/failed.png\" alt=\"img\" title=\"failed\"></p>\n<ol start=\"5\">\n<li>holding     : 投入済ジョブ確認中</li>\n</ol>\n<p><img src=\"./img/holding.png\" alt=\"img\" title=\"holding\"></p>\n<ol start=\"6\">\n<li>unknonw     : プロジェクトの状態不明</li>\n</ol>\n<p><img src=\"./img/unknown.png\" alt=\"img\" title=\"unknown\"></p>\n<h3 id=\"%E6%93%8D%E4%BD%9C%E3%83%9C%E3%82%BF%E3%83%B3%E3%82%A8%E3%83%AA%E3%82%A2\">操作ボタンエリア <a class=\"heading-anchor-permalink\" href=\"#%E6%93%8D%E4%BD%9C%E3%83%9C%E3%82%BF%E3%83%B3%E3%82%A8%E3%83%AA%E3%82%A2\">#</a></h3>\n<p>このエリアには、プロジェクトの実行に関わるボタンが表示されます。</p>\n<p><img src=\"./img/project_control_btn.png\" alt=\"img\" title=\"control_button_area\"></p>\n<ol>\n<li>run ボタン：プロジェクトの実行開始</li>\n<li>stop ボタン：プロジェクトの実行を停止し実行前の状態に戻す</li>\n<li>clean：プロジェクトの実行中に生成されたファイルなどを削除し、実行開始前の状態に戻す</li>\n</ol>\n<h3 id=\"%E4%BF%9D%E5%AD%98%E3%83%9C%E3%82%BF%E3%83%B3%E3%82%A8%E3%83%AA%E3%82%A2\">保存ボタンエリア <a class=\"heading-anchor-permalink\" href=\"#%E4%BF%9D%E5%AD%98%E3%83%9C%E3%82%BF%E3%83%B3%E3%82%A8%E3%83%AA%E3%82%A2\">#</a></h3>\n<p>このエリアには編集したプロジェクトの保存に関わるボタンが表示されます。</p>\n<p><img src=\"./img/project_save.png\" alt=\"img\" title=\"save_button_area\"></p>\n<ol>\n<li>save ボタン：プロジェクトを保存する</li>\n<li>revert ボタン：プロジェクトを直前の保存状態に戻す</li>\n</ol>\n<p>WHEELでは、gitを用いたファイル管理を行っております。\nグラフビュー画面上での編集内容はサーバサイドのファイルにすぐに反映されますが\nSAVEボタンをクリックするまではgitリポジトリには登録されません。\nrevertボタンをクリックすると最後にコミットしてから後に行なった変更を全て破棄して\nリポジトリに最後にコミットした時の状態に戻します</p>\n<p>git操作の詳細については開発者向けドキュメント<a href=\"../../../doc/design/design.html\">詳細設計書</a>をご確認ください。</p>\n<h3 id=\"%E7%94%BB%E9%9D%A2%E8%A1%A8%E7%A4%BA%E5%88%87%E6%9B%BF%E3%83%9C%E3%82%BF%E3%83%B3\">画面表示切替ボタン <a class=\"heading-anchor-permalink\" href=\"#%E7%94%BB%E9%9D%A2%E8%A1%A8%E7%A4%BA%E5%88%87%E6%9B%BF%E3%83%9C%E3%82%BF%E3%83%B3\">#</a></h3>\n<p>初期表示のグラフビュー画面から、listビューおよびテキストエディタ画面へ遷移するためのボタンです</p>\n<p><img src=\"./img/change_view.png\" alt=\"img\" title=\"change_view_area\"></p>\n<ol>\n<li>graph view ボタン</li>\n<li>list view ボタン</li>\n<li>テキストエディタボタン</li>\n</ol>\n<p>テキストエディタへの遷移は、\nファイルの選択状態やプロジェクトの選択状態によって制限されており、\n遷移できない時はボタンがクリックできない状態になっています。</p>\n<h3 id=\"%E9%9A%8E%E5%B1%A4%E8%A1%A8%E7%A4%BA%E3%83%BB%E9%81%B7%E7%A7%BB%E3%83%9C%E3%82%BF%E3%83%B3\">階層表示・遷移ボタン <a class=\"heading-anchor-permalink\" href=\"#%E9%9A%8E%E5%B1%A4%E8%A1%A8%E7%A4%BA%E3%83%BB%E9%81%B7%E7%A7%BB%E3%83%9C%E3%82%BF%E3%83%B3\">#</a></h3>\n<p>ワークフローはコンポーネントの階層構造を持ちますが、\nグラフビュー画面では同一階層のコンポーネントしか同時に表示できません。</p>\n<p>階層表示部には現在表示中のコンポーネントが、プロジェクトのルートコンポーネントから\nどのような階層を降りてきた位置に存在するのか表示します。</p>\n<p><img src=\"./img/breadcrumbs.png\" alt=\"img\" title=\"breadcrumbs\"></p>\n<p>また、階層表示部の左端にある、ツリー表示ボタンをクリックすると\nプロジェクト全体の階層構造が表示されます。</p>\n<p><img src=\"./img/component_tree.png\" alt=\"img\" title=\"component_tree\"></p>\n<p>どちらの表示でも、コンポーネントをクリックすると、表示されているコンポーネントに表示が切り替わります。</p>\n<h3 id=\"%E7%92%B0%E5%A2%83%E5%A4%89%E6%95%B0%E3%82%A8%E3%83%87%E3%82%A3%E3%82%BF%E8%A1%A8%E7%A4%BA%E3%83%9C%E3%82%BF%E3%83%B3\">環境変数エディタ表示ボタン <a class=\"heading-anchor-permalink\" href=\"#%E7%92%B0%E5%A2%83%E5%A4%89%E6%95%B0%E3%82%A8%E3%83%87%E3%82%A3%E3%82%BF%E8%A1%A8%E7%A4%BA%E3%83%9C%E3%82%BF%E3%83%B3\">#</a></h3>\n<p>このボタンをクリックすると\nプロジェクト内で実行されるシェルスクリプトなどで使える環境変数を\n設定するための画面が表示されます。</p>\n<p><img src=\"./img/environment_variables_editor.png\" alt=\"img\" title=\"environment_variables_editor\"></p>\n<ul>\n<li>name欄に環境変数名、value欄に値を入力して[+]ボタンをクリックすると、新しく環境変数を追加することができます。</li>\n<li>環境変数、値ともに表示領域をクリックすることで変更することができます。</li>\n<li>右端に表示されているゴミ箱アイコンをクリックすることで設定済の環境変数を削除できます。</li>\n</ul>\n<p>設定を変更した後は、[SAVE] ボタンをクリックすることで変更内容が実際に反映されます。\n変更を破棄して終了する場合は [CANCEL] ボタンをクリックしてください。</p>\n<h3 id=\"%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC%E4%BD%9C%E6%88%90%E7%94%A8%E3%82%A8%E3%83%AA%E3%82%A2\">ワークフロー作成用エリア <a class=\"heading-anchor-permalink\" href=\"#%E3%83%AF%E3%83%BC%E3%82%AF%E3%83%95%E3%83%AD%E3%83%BC%E4%BD%9C%E6%88%90%E7%94%A8%E3%82%A8%E3%83%AA%E3%82%A2\">#</a></h3>\n<p>現在表示中のコンポーネントが持つ子コンポーネントが表示されています。\n初期状態ではプロジェクトのルートコンポーネントの直接の子コンポーネントが表示されています。</p>\n<p>この領域に、コンポーネントライブラリから、ドラッグ&amp;ドロップすることでプロジェクトにコンポーネントを追加します。</p>\n<p>表示されているコンポーネントをダブルクリックすることで、\nそのコンポーネントの下位コンポーネントを表示するように切り替わります。</p>\n<p>上位コンポーネントへの切り替えは、前述の階層表示部またはコンポーネントツリーを使ってください。</p>\n<p>表示されているコンポーネントをシングルクリックすると\nそのコンポーネントの設定値(プロパティ)を編集する領域が表示されます。</p>\n<p><img src=\"./img/component_property.png\" alt=\"img\" title=\"component_property\"></p>\n<ol>\n<li>closeボタン : プロパティ表示を閉じます</li>\n<li>cleanボタン : コンポーネント(もしあれば下位コンポーネントも)の状態を最新の保存状態に巻き戻します</li>\n<li>deleteボタン: コンポーネントを削除します</li>\n<li>詳細表示ボタン: プロパティの設定項目の表示/非表示をグループ毎に切り替えます</li>\n</ol>\n<p>コンポーネントの種類毎にこの領域に表示される内容は異なります。\nプロパティへの設定内容は<a href=\"../4_component/00_common.html\">コンポーネント</a>の章をご参照ください</p>\n<h3 id=\"%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E6%93%8D%E4%BD%9C%E3%82%A8%E3%83%AA%E3%82%A2\">ファイル操作エリア <a class=\"heading-anchor-permalink\" href=\"#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E6%93%8D%E4%BD%9C%E3%82%A8%E3%83%AA%E3%82%A2\">#</a></h3>\n<p>コンポーネントのプロパティを表示した状態で、Filesグループの <code>4 詳細表示ボタン</code>を\nクリックすると、次のようなファイル操作エリアが表示されます。</p>\n<p><img src=\"./img/file_area.png\" alt=\"img\" title=\"file area\"></p>\n<ol>\n<li>ファイル操作ボタン: コンポーネント内のファイル、ディレクトリを操作するボタンです。詳細は後述</li>\n<li>ファイル表示エリア: コンポーネント内のファイル、ディレクトリをツリー形式で表示します。</li>\n<li>closeボタン: ファイル操作エリアの表示/非表示を切り替えます。</li>\n</ol>\n<p>ファイル表示エリアには、選択中のコンポーネントディレクトリ以下に存在するファイル、ディレクトリのうち、wheelが使うメタデータファイルや、下位コンポーネントのディレクトリ以外のものが表示されます。</p>\n<p>ディレクトリおよびディレクトリへのシンボリックリンクの左側に表示されている三角形アイコンをクリックすることで、さらにそのディレクトリ内のファイル等を表示することができます。</p>\n<p>ファイルやディレクトリのうち、連番で構成されるもの(例えば、file1, file2, file3といったもの)が\n表示対象に含まれている時は、図中の<code>seq_dir*</code>や<code>seq_file*</code>のような形で1行にまとめて表示されます。</p>\n<p>これらの行の左側に表示されている三角形アイコンをクリックすると、ディレクトリと同じような形で元の連番ファイル/ディレクトリが個々に表示されます。</p>\n<p>ファイル表示エリアにファイルをドロップすると、コンポーネントディレクトリの直下にファイルをアップロードすることができます。</p>\n<h4 id=\"%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E6%93%8D%E4%BD%9C%E3%83%9C%E3%82%BF%E3%83%B3\">ファイル操作ボタン <a class=\"heading-anchor-permalink\" href=\"#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E6%93%8D%E4%BD%9C%E3%83%9C%E3%82%BF%E3%83%B3\">#</a></h4>\n<p>ファイル操作エリア上部には、ファイルの操作を行うためのボタンが並んで表示されています。</p>\n<p><img src=\"./img/file_area_button.png\" alt=\"img\" title=\"file area button\"></p>\n<ol>\n<li>新規ディレクトリ作成: 表示されている階層に新規ディレクトリを作成します。</li>\n<li>新規ファイル作成: 表示されている階層に新規の空ファイルを作成します</li>\n<li>リネーム: 選択中のファイル、ディレクトリ等をリネームします。</li>\n<li>削除: 選択中のファイル、ディレクトリ等を削除します。</li>\n<li>アップロード: 表示されている階層にファイルをアップロードします。</li>\n<li>ダウンロード: 選択中のファイル、ディレクトリをダウンロードします</li>\n<li>共有: 選択中のファイル、ディレクトリのパスを表示します。</li>\n</ol>\n<p>選択中のファイル、ディレクトリを対象とする操作は、非対応の時はボタンが無効化されます。</p>\n<p>共有ボタンをクリックすると、次のようなダイアログが表示されます。</p>\n<p><img src=\"./img/share_file.png\" alt=\"img\" title=\"share file dialogue\"></p>\n<p>表示されているパスの右にあるアイコンをクリックすると、クリップボードにコピーされるので\n別のアプリへファイルを渡す時などにお使いください。</p>\n<p>例えば、jupyterlabであれば、<code>http(s)://&lt;server:port&gt;/&lt;lab-location&gt;/lab/tree/path/to/notebook.ipynb</code> といった形式で指定したipynbファイルを開くことができます。ただし、WHEELからコピーされるファイルは絶対パスですが、ここで指定するパス(<code>path/to/notebook.ipynb</code>)はワークスペースのrootからの相対パスである必要があります。\n詳細は、jupyterlabのドキュメントをご参照ください。</p>\n<p><a href=\"https://jupyterlab.readthedocs.io/en/stable/user/urls.html\">File Navigation with tree</a></p>\n<h3 id=\"%E3%83%AD%E3%82%B0%E8%A1%A8%E7%A4%BA%E3%83%9C%E3%82%BF%E3%83%B3\">ログ表示ボタン <a class=\"heading-anchor-permalink\" href=\"#%E3%83%AD%E3%82%B0%E8%A1%A8%E7%A4%BA%E3%83%9C%E3%82%BF%E3%83%B3\">#</a></h3>\n<p>ワークフローの作成時や実行時等に出力されるログを表示します。</p>\n<p>ボタンをクリックすると、次のようなログ表示エリアが表れます。</p>\n<p><img src=\"./img/log_screen.png\" alt=\"img\" title=\"log_screen\"></p>\n<p>ログ表示は内容に応じて複数のタブにそれぞれ出力されます。</p>\n<ol>\n<li>Info：エラー、ワーニングなどの重大な情報と、プロジェクトの実行状況や操作に関する一般的な情報</li>\n<li>Stdout：ローカルホストで実行されたtaskの標準出力</li>\n<li>Stderr：ローカルホストで実行されたtaskの標準エラー出力</li>\n<li>Stdout(SSH)：リモートホストで実行されたtaskの標準出力</li>\n<li>Stderr(SSH)：リモートホストで実行されたtaskの標準エラー出力</li>\n</ol>\n<p>ラベルの色は次の意味を現わします。</p>\n<ul>\n<li>青: 現在表示中</li>\n<li>緑: 新規情報があり、未表示</li>\n<li>灰: 非表示中</li>\n</ul>\n<p>[CLEAR ALL LOG] ボタンをクリックすると、それまでに表示された全てのログが消去されます。</p>\n<p>最上部の△ボタンをクリックするとログ表示部が下部に折り畳まれます。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 11
    },
    {
      "path": "3_reference_manual/3_workflow_screen/2_listview.md",
      "url": "3_reference_manual/3_workflow_screen/2_listview.html",
      "content": "# リストビュー画面\n本章では、リストビュー画面の機能について説明します。\n\nリストビュー画面はプロジェクトに含まれるTaskコンポーネントの実行状況を\nツリー形式で表示する画面です。\n表示内容は以下のように構成されています。\n\n![img](./img/listview.png \"workflow_listview\")\n\n1. Name：コンポーネント名\n1. State：コンポーネント処理進行状況\n1. startTime：コンポーネント処理実行時刻\n1. endTime：コンポーネント処理完了時間\n\nStateは、以下のように分類され、表示されます。\n\n| State名 | State説明 |\n|----|----|\n| not-started | 初期状態 |\n| stage-in | リモートサーバへ必要なファイルを転送している状態 |\n| waiting | Taskコンポーネントの同時実行本数の制限による待ち状態 |\n| running | 処理が実行されている状態 |\n| queued | ジョブをジョブスケジューラに投入し実行開始を待っている状態 |\n| stage-out | リモートサーバでの処理が終了し必要なファイルを転送している状態 |\n| finished | 処理が完了した状態 |\n| unknown | ジョブスケジューラ経由で投入したTaskの処理がステータスチェックに失敗するなど<br>正常終了か異常終了か判定できなかった状態 |\n| failed | 処理が異常終了した状態 |\n\n上記画面のように、Forコンポーネントのような1回のプロジェクト実行中に\n複数回実行されるコンポーネントは、実行された回数分分けて表示されます。\n\nまた、他のコンポーネントの下位コンポーネントであるTaskコンポーネントは\n上流のコンポーネントツリーの中にネストして表示されます。\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"%E3%83%AA%E3%82%B9%E3%83%88%E3%83%93%E3%83%A5%E3%83%BC%E7%94%BB%E9%9D%A2\">リストビュー画面 <a class=\"heading-anchor-permalink\" href=\"#%E3%83%AA%E3%82%B9%E3%83%88%E3%83%93%E3%83%A5%E3%83%BC%E7%94%BB%E9%9D%A2\">#</a></h1>\n<p>本章では、リストビュー画面の機能について説明します。</p>\n<p>リストビュー画面はプロジェクトに含まれるTaskコンポーネントの実行状況を\nツリー形式で表示する画面です。\n表示内容は以下のように構成されています。</p>\n<p><img src=\"./img/listview.png\" alt=\"img\" title=\"workflow_listview\"></p>\n<ol>\n<li>Name：コンポーネント名</li>\n<li>State：コンポーネント処理進行状況</li>\n<li>startTime：コンポーネント処理実行時刻</li>\n<li>endTime：コンポーネント処理完了時間</li>\n</ol>\n<p>Stateは、以下のように分類され、表示されます。</p>\n<table>\n<thead>\n<tr>\n<th>State名</th>\n<th>State説明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>not-started</td>\n<td>初期状態</td>\n</tr>\n<tr>\n<td>stage-in</td>\n<td>リモートサーバへ必要なファイルを転送している状態</td>\n</tr>\n<tr>\n<td>waiting</td>\n<td>Taskコンポーネントの同時実行本数の制限による待ち状態</td>\n</tr>\n<tr>\n<td>running</td>\n<td>処理が実行されている状態</td>\n</tr>\n<tr>\n<td>queued</td>\n<td>ジョブをジョブスケジューラに投入し実行開始を待っている状態</td>\n</tr>\n<tr>\n<td>stage-out</td>\n<td>リモートサーバでの処理が終了し必要なファイルを転送している状態</td>\n</tr>\n<tr>\n<td>finished</td>\n<td>処理が完了した状態</td>\n</tr>\n<tr>\n<td>unknown</td>\n<td>ジョブスケジューラ経由で投入したTaskの処理がステータスチェックに失敗するなど<br>正常終了か異常終了か判定できなかった状態</td>\n</tr>\n<tr>\n<td>failed</td>\n<td>処理が異常終了した状態</td>\n</tr>\n</tbody>\n</table>\n<p>上記画面のように、Forコンポーネントのような1回のプロジェクト実行中に\n複数回実行されるコンポーネントは、実行された回数分分けて表示されます。</p>\n<p>また、他のコンポーネントの下位コンポーネントであるTaskコンポーネントは\n上流のコンポーネントツリーの中にネストして表示されます。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 12
    },
    {
      "path": "3_reference_manual/3_workflow_screen/3_editor.md",
      "url": "3_reference_manual/3_workflow_screen/3_editor.html",
      "content": "# テキストエディタ画面\n本章では、テキストエディタ画面の機能について説明します。\n\nテキストエディタ画面には次の3つのモードが存在します。\n- normalモード\n- PS-configモード\n- jobScriptEditorモード\n\nこれらのモードの切り替えは画面上部のドロップダウンリストで行ないますが\nテキストエディタ画面に遷移する前にグラフビュー画面で選択したコンポーネントによっては\n移行できないモードがあります。\n\n![img](./img/editor_mode.png \"editor_mode\")\n\n### normalモード\n本節ではnormalモードおよび全モード共通の機能について説明します。\n![img](./img/editor_normal.png \"editor_normal\")\n\n1. ファイルタブ\n2. 新規ファイルOpenボタン\n3. readonlyモード切り替えスイッチ\n4. 一括セーブボタン\n\nテキストエディタを開いた時、通常はnormalモードとして起動します。\nこのモードは、タブエディタとなっており、グラフビューモードで選択していたファイルが\n1番目のタブに読み込まれた状態で起動します。\n\nファイルタブには開いたファイルのファイル名が表示されており、現在表示中のタブは青色で示されます。\nタブのファイル名をクリックすると [save] または [close without save] の2つのメニューが表示されます。\n\n![img](./img/editor_tab_menu.png \"editor_tab_menu\")\n\n[save]を選択すると編集した内容が保存されますが、この状態ではgitリポジトリにはコミットされておらず、画面上部のrevertボタンをクリックすると編集内容は破棄されます。\n\n[close without save] をクリックすると編集内容を破棄してそのタブを閉じます\n\n新規ファイルOpenボタンをクリックすると、ファイル名の入力が求められ、有効なファイル名を入力すると空ファイルが作成されます。\nファイルは同時に新しいタブで開かれるので、内容を追加して保存してください。\n\nreadonlyモード切り替えスイッチを有効にすると、表示されたテキストに変更が加えられなくなります。\nテキストファイルの内容を確認する時などにご活用ください。\n\n一括セーブボタンをクリックすると、現在開いている全てのタブ、後述のPS-configモードで設定中のパラメータスタディ設定が全てsaveされます。タブの[save]メニューと同じく、この状態ではまだgitリポジトリにはコミットされていないため、画面上部のrevertボタンをクリックすると編集内容は破棄されます。\n\n### PS-configモード\n本節ではPS-configモードの機能を説明します。\n\nパラメータスタディ機能自体は、[PSコンポーネント]( ../4_component/06_PS.md)に解説されているので、そちらも合わせてご確認ください。\n\n![img](./img/editor_ps_config.png \"editor_ps_config\")\n\n1. targetFile入力エリア\n2. parameter入力エリア\n3. scatter設定入力エリア\n4. gather設定入力エリア\n\ntargetFile入力エリアでは、パラスタ実行時にパラメータ値で内容を上書きする元になるファイルを設定します。\n\nparameter入力エリアは、パラスタ実行時に使われるパラメータ空間の定義を行ないます。\n\nscatter設定入力エリアはパラスタ実行前に、各サブコンポーネントに個別に配布されるファイルの設定を行ないます。\n\ngather設定入力エリアはパラスタ完了後に、各サブコンポーネントから回収するファイルの設定を行ないます。\n\n### jobScriptEditorモード\n本節ではjobScriptEditorモードの機能を説明します。\n\n![img](./img/editor_jobscript_editor.png \"editor_jobscript_editor\")\n\n1. 対象スパコン選択リスト\n\njobScriptEditorモードでは、編集中のテキストファイルに対して、\nバッチサーバに投入するジョブスクリプトの冒頭部分に記載する\nオプション行を対話的に生成、編集する機能を提供します。\n\n起動直後は、normalモードと同じタブエディタの右側の領域に\n[HPC center]と書かれたドロップダウンリストが表示されています。\n\nドロップダウンリストから、ジョブを投入する対象のシステムを選択すると\nそのバッチシステムで使われるオプション内容を入力するフォームが表示されます。\n\n![img](./img/editor_jobscript_editor_fugaku.png \"editor_jobscript_editor_fugaku\")\n\n1. LOADボタン\n2. INSERTボタン\n3. CLEARボタン\n4. REGISTERボタン\n5. オプション入力フォーム\n\n[LOAD]ボタンをクリックすると後述の[REGISTER]ボタンで保存したオプション設定をフォーム部に読み込みます。\n\n[INSERT]ボタンをクリックすると現在、フォームに入力されているオプション値を\nジョブスクリプトに適した形式でタブエディタ側で開いているファイルの先頭部分に挿入します。\nまた、タブエディタ側で開いているファイルに既にオプション値が挿入されていた場合はこのボタンの表示は[UPDATE]に切り替わり、クリックすると既に入力された内容を現在の設定値で置き換えるように機能します。\n\n[CLEAR]ボタンをクリックするとフォーム部に入力済の内容を初期値に戻します。\nこの時タブエディタ側のファイルに既に入力された内容はそのまま残ります。\n\n[REGISTER]ボタンをクリックすると、フォーム部に入力された設定値に名前を付けて\n保存することができます。\n保存した内容を[LOAD]ボタンで呼び出すことで、複数のスクリプトに同じ設定を容易に入力することができます。\n\n[REGISTER] で入力した内容はプロジェクトのファイルとは別の場所に保存されているため、他のプロジェクトで用いた設定値を呼び出すことも可能です。\n\n保存済の内容を削除する時は、[LOAD]ボタンをクリックした時に表示されるリストの右端にあるゴミ箱アイコンをクリックしてください。\n\nなお、jobScriptEditorモードのフォームでは入力された値のバリデーションは行なっていません。\n\n例えば、指定可能な書式とは異なる形式でオプションを設定していたり、\n認められているリソース以上のリソースを要求するようなオプションを入力していても、\nジョブスクリプトは生成されますので、ユーザ自身で利用するシステムのドキュメント等を確認して\n有効な設定値を入力してください。\n\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%A8%E3%83%87%E3%82%A3%E3%82%BF%E7%94%BB%E9%9D%A2\">テキストエディタ画面 <a class=\"heading-anchor-permalink\" href=\"#%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%A8%E3%83%87%E3%82%A3%E3%82%BF%E7%94%BB%E9%9D%A2\">#</a></h1>\n<p>本章では、テキストエディタ画面の機能について説明します。</p>\n<p>テキストエディタ画面には次の3つのモードが存在します。</p>\n<ul>\n<li>normalモード</li>\n<li>PS-configモード</li>\n<li>jobScriptEditorモード</li>\n</ul>\n<p>これらのモードの切り替えは画面上部のドロップダウンリストで行ないますが\nテキストエディタ画面に遷移する前にグラフビュー画面で選択したコンポーネントによっては\n移行できないモードがあります。</p>\n<p><img src=\"./img/editor_mode.png\" alt=\"img\" title=\"editor_mode\"></p>\n<h3 id=\"normal%E3%83%A2%E3%83%BC%E3%83%89\">normalモード <a class=\"heading-anchor-permalink\" href=\"#normal%E3%83%A2%E3%83%BC%E3%83%89\">#</a></h3>\n<p>本節ではnormalモードおよび全モード共通の機能について説明します。\n<img src=\"./img/editor_normal.png\" alt=\"img\" title=\"editor_normal\"></p>\n<ol>\n<li>ファイルタブ</li>\n<li>新規ファイルOpenボタン</li>\n<li>readonlyモード切り替えスイッチ</li>\n<li>一括セーブボタン</li>\n</ol>\n<p>テキストエディタを開いた時、通常はnormalモードとして起動します。\nこのモードは、タブエディタとなっており、グラフビューモードで選択していたファイルが\n1番目のタブに読み込まれた状態で起動します。</p>\n<p>ファイルタブには開いたファイルのファイル名が表示されており、現在表示中のタブは青色で示されます。\nタブのファイル名をクリックすると [save] または [close without save] の2つのメニューが表示されます。</p>\n<p><img src=\"./img/editor_tab_menu.png\" alt=\"img\" title=\"editor_tab_menu\"></p>\n<p>[save]を選択すると編集した内容が保存されますが、この状態ではgitリポジトリにはコミットされておらず、画面上部のrevertボタンをクリックすると編集内容は破棄されます。</p>\n<p>[close without save] をクリックすると編集内容を破棄してそのタブを閉じます</p>\n<p>新規ファイルOpenボタンをクリックすると、ファイル名の入力が求められ、有効なファイル名を入力すると空ファイルが作成されます。\nファイルは同時に新しいタブで開かれるので、内容を追加して保存してください。</p>\n<p>readonlyモード切り替えスイッチを有効にすると、表示されたテキストに変更が加えられなくなります。\nテキストファイルの内容を確認する時などにご活用ください。</p>\n<p>一括セーブボタンをクリックすると、現在開いている全てのタブ、後述のPS-configモードで設定中のパラメータスタディ設定が全てsaveされます。タブの[save]メニューと同じく、この状態ではまだgitリポジトリにはコミットされていないため、画面上部のrevertボタンをクリックすると編集内容は破棄されます。</p>\n<h3 id=\"ps-config%E3%83%A2%E3%83%BC%E3%83%89\">PS-configモード <a class=\"heading-anchor-permalink\" href=\"#ps-config%E3%83%A2%E3%83%BC%E3%83%89\">#</a></h3>\n<p>本節ではPS-configモードの機能を説明します。</p>\n<p>パラメータスタディ機能自体は、<a href=\"../4_component/06_PS.html\">PSコンポーネント</a>に解説されているので、そちらも合わせてご確認ください。</p>\n<p><img src=\"./img/editor_ps_config.png\" alt=\"img\" title=\"editor_ps_config\"></p>\n<ol>\n<li>targetFile入力エリア</li>\n<li>parameter入力エリア</li>\n<li>scatter設定入力エリア</li>\n<li>gather設定入力エリア</li>\n</ol>\n<p>targetFile入力エリアでは、パラスタ実行時にパラメータ値で内容を上書きする元になるファイルを設定します。</p>\n<p>parameter入力エリアは、パラスタ実行時に使われるパラメータ空間の定義を行ないます。</p>\n<p>scatter設定入力エリアはパラスタ実行前に、各サブコンポーネントに個別に配布されるファイルの設定を行ないます。</p>\n<p>gather設定入力エリアはパラスタ完了後に、各サブコンポーネントから回収するファイルの設定を行ないます。</p>\n<h3 id=\"jobscripteditor%E3%83%A2%E3%83%BC%E3%83%89\">jobScriptEditorモード <a class=\"heading-anchor-permalink\" href=\"#jobscripteditor%E3%83%A2%E3%83%BC%E3%83%89\">#</a></h3>\n<p>本節ではjobScriptEditorモードの機能を説明します。</p>\n<p><img src=\"./img/editor_jobscript_editor.png\" alt=\"img\" title=\"editor_jobscript_editor\"></p>\n<ol>\n<li>対象スパコン選択リスト</li>\n</ol>\n<p>jobScriptEditorモードでは、編集中のテキストファイルに対して、\nバッチサーバに投入するジョブスクリプトの冒頭部分に記載する\nオプション行を対話的に生成、編集する機能を提供します。</p>\n<p>起動直後は、normalモードと同じタブエディタの右側の領域に\n[HPC center]と書かれたドロップダウンリストが表示されています。</p>\n<p>ドロップダウンリストから、ジョブを投入する対象のシステムを選択すると\nそのバッチシステムで使われるオプション内容を入力するフォームが表示されます。</p>\n<p><img src=\"./img/editor_jobscript_editor_fugaku.png\" alt=\"img\" title=\"editor_jobscript_editor_fugaku\"></p>\n<ol>\n<li>LOADボタン</li>\n<li>INSERTボタン</li>\n<li>CLEARボタン</li>\n<li>REGISTERボタン</li>\n<li>オプション入力フォーム</li>\n</ol>\n<p>[LOAD]ボタンをクリックすると後述の[REGISTER]ボタンで保存したオプション設定をフォーム部に読み込みます。</p>\n<p>[INSERT]ボタンをクリックすると現在、フォームに入力されているオプション値を\nジョブスクリプトに適した形式でタブエディタ側で開いているファイルの先頭部分に挿入します。\nまた、タブエディタ側で開いているファイルに既にオプション値が挿入されていた場合はこのボタンの表示は[UPDATE]に切り替わり、クリックすると既に入力された内容を現在の設定値で置き換えるように機能します。</p>\n<p>[CLEAR]ボタンをクリックするとフォーム部に入力済の内容を初期値に戻します。\nこの時タブエディタ側のファイルに既に入力された内容はそのまま残ります。</p>\n<p>[REGISTER]ボタンをクリックすると、フォーム部に入力された設定値に名前を付けて\n保存することができます。\n保存した内容を[LOAD]ボタンで呼び出すことで、複数のスクリプトに同じ設定を容易に入力することができます。</p>\n<p>[REGISTER] で入力した内容はプロジェクトのファイルとは別の場所に保存されているため、他のプロジェクトで用いた設定値を呼び出すことも可能です。</p>\n<p>保存済の内容を削除する時は、[LOAD]ボタンをクリックした時に表示されるリストの右端にあるゴミ箱アイコンをクリックしてください。</p>\n<p>なお、jobScriptEditorモードのフォームでは入力された値のバリデーションは行なっていません。</p>\n<p>例えば、指定可能な書式とは異なる形式でオプションを設定していたり、\n認められているリソース以上のリソースを要求するようなオプションを入力していても、\nジョブスクリプトは生成されますので、ユーザ自身で利用するシステムのドキュメント等を確認して\n有効な設定値を入力してください。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 13
    },
    {
      "path": "3_reference_manual/4_component/00_common.md",
      "url": "3_reference_manual/4_component/00_common.html",
      "content": "# コンポーネント共通項目\n本節では全コンポーネントに共通する仕様について説明します。\n\n## name,description\n全てのコンポーネントは共通して、`name`プロパティと`description`プロパティを持ちます。\n\n![img](./img/name_description.png \"name_and_description\")\n\nnameは、そのコンポーネントに必要なファイルを格納するディレクトリ名として扱われるため\n同一階層に同じ名前のコンポーネントを作成することはできません。\n\nまた、nameには、英数字、ハイフン`-`、およびアンダーバー`_`しか使うことができません。\n\ndescriptionはnameのような制約が無く自由に記述することができます。\nnameのみでは識別し難いようなコンポーネントを区別したり、\nコンポーネントの処理内容を説明するために(スクリプトやソースコードにおける)コメントのような\n使い方をすることができます。\n\n\n## inputFile/outputFile\nWHEELにはコンポーネント内のファイルを別のコンポーネントで使うために\n転送するinputFile/outputFileという機能があります。\n\n![img](./img/input_output_files.png \"inputFiles_outputFiles\")\n\nあるコンポーネントのoutputFileに指定したファイルと別のコンポーネントのinputFileに指定したファイルを\n画面上で接続すると、後続コンポーネントの実行前に先行コンポーネントのディレクトリ内の\n必要なファイルに対してシンボリックリンクを作成するので\n後続コンポーネント内のスクリプトからもファイルにアクセスすることができます。\n\n![img](./img/input_output_connect.png \"connected input and output file\")\n\ninputFileとoutpuFileの指定方法によってそれぞれ次のような挙動を示します。\n\n### inputFileが空白でoutputFileに通常のパスが指定された時\noutputFileに指定されたファイルまたはディレクトリへのシンボリックリンクが\n後続コンポーネントの最上位ディレクトリに作成されます。\n\n### inputFileが'/'で終わらない文字列、outputFileに通常のパスが指定された時\n後続コンポーネントのディレクトリ内に、outputFileに指定されたファイルまたはディレクトリへの\nシンボリックリンクが、inputFileに指定された名前で作成されます。\n\n### inputFileが'/'で終わらない文字列で、outputFileに指定されたパスがglob(\\*や\\?など)を含む時\n後続コンポーネントのディレクトリ内に、inputFileに指定された文字列のディレクトリが作成され\nその中に、outpuFileで指定されたglobと一致するファイル、ディレクトリへのシンボリックリンクが\n作成されます。\n\n### inputFileに'/'で終わる文字列が指定された時\n後続コンポーネントのディレクトリ内に、inputFileに指定された文字列のディレクトリが作成され\noutputFileに指定されたファイル、ディレクトリへのシンボリックリンクが作成されます。\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%85%B1%E9%80%9A%E9%A0%85%E7%9B%AE\">コンポーネント共通項目 <a class=\"heading-anchor-permalink\" href=\"#%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%85%B1%E9%80%9A%E9%A0%85%E7%9B%AE\">#</a></h1>\n<p>本節では全コンポーネントに共通する仕様について説明します。</p>\n<h2 id=\"name%2Cdescription\">name,description <a class=\"heading-anchor-permalink\" href=\"#name%2Cdescription\">#</a></h2>\n<p>全てのコンポーネントは共通して、<code>name</code>プロパティと<code>description</code>プロパティを持ちます。</p>\n<p><img src=\"./img/name_description.png\" alt=\"img\" title=\"name_and_description\"></p>\n<p>nameは、そのコンポーネントに必要なファイルを格納するディレクトリ名として扱われるため\n同一階層に同じ名前のコンポーネントを作成することはできません。</p>\n<p>また、nameには、英数字、ハイフン<code>-</code>、およびアンダーバー<code>_</code>しか使うことができません。</p>\n<p>descriptionはnameのような制約が無く自由に記述することができます。\nnameのみでは識別し難いようなコンポーネントを区別したり、\nコンポーネントの処理内容を説明するために(スクリプトやソースコードにおける)コメントのような\n使い方をすることができます。</p>\n<h2 id=\"inputfile%2Foutputfile\">inputFile/outputFile <a class=\"heading-anchor-permalink\" href=\"#inputfile%2Foutputfile\">#</a></h2>\n<p>WHEELにはコンポーネント内のファイルを別のコンポーネントで使うために\n転送するinputFile/outputFileという機能があります。</p>\n<p><img src=\"./img/input_output_files.png\" alt=\"img\" title=\"inputFiles_outputFiles\"></p>\n<p>あるコンポーネントのoutputFileに指定したファイルと別のコンポーネントのinputFileに指定したファイルを\n画面上で接続すると、後続コンポーネントの実行前に先行コンポーネントのディレクトリ内の\n必要なファイルに対してシンボリックリンクを作成するので\n後続コンポーネント内のスクリプトからもファイルにアクセスすることができます。</p>\n<p><img src=\"./img/input_output_connect.png\" alt=\"img\" title=\"connected input and output file\"></p>\n<p>inputFileとoutpuFileの指定方法によってそれぞれ次のような挙動を示します。</p>\n<h3 id=\"inputfile%E3%81%8C%E7%A9%BA%E7%99%BD%E3%81%A7outputfile%E3%81%AB%E9%80%9A%E5%B8%B8%E3%81%AE%E3%83%91%E3%82%B9%E3%81%8C%E6%8C%87%E5%AE%9A%E3%81%95%E3%82%8C%E3%81%9F%E6%99%82\">inputFileが空白でoutputFileに通常のパスが指定された時 <a class=\"heading-anchor-permalink\" href=\"#inputfile%E3%81%8C%E7%A9%BA%E7%99%BD%E3%81%A7outputfile%E3%81%AB%E9%80%9A%E5%B8%B8%E3%81%AE%E3%83%91%E3%82%B9%E3%81%8C%E6%8C%87%E5%AE%9A%E3%81%95%E3%82%8C%E3%81%9F%E6%99%82\">#</a></h3>\n<p>outputFileに指定されたファイルまたはディレクトリへのシンボリックリンクが\n後続コンポーネントの最上位ディレクトリに作成されます。</p>\n<h3 id=\"inputfile%E3%81%8C%E2%80%99%2F'%E3%81%A7%E7%B5%82%E3%82%8F%E3%82%89%E3%81%AA%E3%81%84%E6%96%87%E5%AD%97%E5%88%97%E3%80%81outputfile%E3%81%AB%E9%80%9A%E5%B8%B8%E3%81%AE%E3%83%91%E3%82%B9%E3%81%8C%E6%8C%87%E5%AE%9A%E3%81%95%E3%82%8C%E3%81%9F%E6%99%82\">inputFileが’/'で終わらない文字列、outputFileに通常のパスが指定された時 <a class=\"heading-anchor-permalink\" href=\"#inputfile%E3%81%8C%E2%80%99%2F'%E3%81%A7%E7%B5%82%E3%82%8F%E3%82%89%E3%81%AA%E3%81%84%E6%96%87%E5%AD%97%E5%88%97%E3%80%81outputfile%E3%81%AB%E9%80%9A%E5%B8%B8%E3%81%AE%E3%83%91%E3%82%B9%E3%81%8C%E6%8C%87%E5%AE%9A%E3%81%95%E3%82%8C%E3%81%9F%E6%99%82\">#</a></h3>\n<p>後続コンポーネントのディレクトリ内に、outputFileに指定されたファイルまたはディレクトリへの\nシンボリックリンクが、inputFileに指定された名前で作成されます。</p>\n<h3 id=\"inputfile%E3%81%8C%E2%80%99%2F'%E3%81%A7%E7%B5%82%E3%82%8F%E3%82%89%E3%81%AA%E3%81%84%E6%96%87%E5%AD%97%E5%88%97%E3%81%A7%E3%80%81outputfile%E3%81%AB%E6%8C%87%E5%AE%9A%E3%81%95%E3%82%8C%E3%81%9F%E3%83%91%E3%82%B9%E3%81%8Cglob(*%E3%82%84%3F%E3%81%AA%E3%81%A9)%E3%82%92%E5%90%AB%E3%82%80%E6%99%82\">inputFileが’/'で終わらない文字列で、outputFileに指定されたパスがglob(*や?など)を含む時 <a class=\"heading-anchor-permalink\" href=\"#inputfile%E3%81%8C%E2%80%99%2F'%E3%81%A7%E7%B5%82%E3%82%8F%E3%82%89%E3%81%AA%E3%81%84%E6%96%87%E5%AD%97%E5%88%97%E3%81%A7%E3%80%81outputfile%E3%81%AB%E6%8C%87%E5%AE%9A%E3%81%95%E3%82%8C%E3%81%9F%E3%83%91%E3%82%B9%E3%81%8Cglob(*%E3%82%84%3F%E3%81%AA%E3%81%A9)%E3%82%92%E5%90%AB%E3%82%80%E6%99%82\">#</a></h3>\n<p>後続コンポーネントのディレクトリ内に、inputFileに指定された文字列のディレクトリが作成され\nその中に、outpuFileで指定されたglobと一致するファイル、ディレクトリへのシンボリックリンクが\n作成されます。</p>\n<h3 id=\"inputfile%E3%81%AB%E2%80%99%2F'%E3%81%A7%E7%B5%82%E3%82%8F%E3%82%8B%E6%96%87%E5%AD%97%E5%88%97%E3%81%8C%E6%8C%87%E5%AE%9A%E3%81%95%E3%82%8C%E3%81%9F%E6%99%82\">inputFileに’/'で終わる文字列が指定された時 <a class=\"heading-anchor-permalink\" href=\"#inputfile%E3%81%AB%E2%80%99%2F'%E3%81%A7%E7%B5%82%E3%82%8F%E3%82%8B%E6%96%87%E5%AD%97%E5%88%97%E3%81%8C%E6%8C%87%E5%AE%9A%E3%81%95%E3%82%8C%E3%81%9F%E6%99%82\">#</a></h3>\n<p>後続コンポーネントのディレクトリ内に、inputFileに指定された文字列のディレクトリが作成され\noutputFileに指定されたファイル、ディレクトリへのシンボリックリンクが作成されます。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 14
    },
    {
      "path": "3_reference_manual/4_component/01_Task.md",
      "url": "3_reference_manual/4_component/01_Task.html",
      "content": "# Task\n\n![img](./img/task.png \"task\")\n\nTaskコンポーネントは、WHEELの用意するコンポーネントの中で最も基本的かつ重要なコンポーネントです。\n[ script ]プロパティに設定されたスクリプトファイルを実行環境(host/useJobScheduler/queueプロパティ)の設定に応じて実行します。\n\nTaskコンポーネントに指定することのできるプロパティは以下のとおりです。\nなお、name, description, inputFile, outpuFileの4項目については[共通項目](./00_common.md)をご参照ください。\n\n### script\nTaskコンポーネントの実行時に呼ぶスクリプトのファイル名を設定します。\n\n![img](./img/task_script.png \"task_script\")\n\nscriptプロパティの入力欄はセレクトボックスになっており、\nTaskコンポーネント内に存在するファイルの中から選ぶことができます。\n\n### host\n[リモートホスト設定](../../2_remotehost_screen/remotehost.md)にて設定されたリモートホストのラベル\nまたは\"localhost\"を設定します。\n\n![img](./img/task_host.png \"task_host\")\n\nhostが\"localhost\"の時は、scriptはWHEELが動作しているマシン上で実行されますが\nそれ以外の値が設定されている時は、リモートホストへsshでディレクトリ全体を転送し\nリモートホスト上で実行されます。(後述のuseJobSchedulerが設定されている時は、バッチサーバにジョブを投入します)\n\n### useJobScheduler\nscriptの実行をバッチサーバに投入する時に有効にします。\nuseJobSchedulerを有効に設定した時のみ、次のqueue, submit optionプロパティを設定することができます。\n\n無効のとき\n![img](./img/task_jobScheduler_disable.png \"task_jobScheduler_disable\")\n\n有効のとき\n![img](./img/task_jobScheduler_enable.png \"task_jobScheduler_enable\")\n\n### queue\nジョブを投入するキューをリモートホスト設定で設定したキューの中から選びます。\n無指定の場合はバッチサーバのデフォルトキューに対してジョブを投入します。\n\n### submit command\nこの欄は実際にはTaskコンポーネントのプロパティではなく、リモートホスト設定で指定された\nバッチサーバにジョブを投入する時のコマンド名が表示されています。\n\nここでは変更することはできません。\n\n### submit option\nジョブ投入時に追加で指定するオプションを設定します。\n\n### number of retry\nTaskコンポーネントの実行に失敗した時に、自動的に再実行を行なう回数を指定します。\n無指定時は再実行は行ないません。\n\n![img](./img/task_num_retry.png \"task_number_of_retry\")\n\n### use javascript expression for condition check\nTaskコンポーネントの成功/失敗を判定するのに\njavascript式を用いるか、シェルスクリプトを用いるか指定します。\n\n無効の時は、シェルスクリプトを選択するドロップダウンリストが表示されており\nTaskコンポーネント実行終了後に指定されたシェルスクリプトが実行されて\n戻り値が0であれば成功、0以外であれば失敗と判定されます。\n\nなお、無指定の時は[script]に指定したスクリプトの戻り値で同様の判定を行ないます。\n\n![img](./img/task_retry_expression_disable.png \"task_retry_expression_disable\")\n\n有効の時は、ジャバスクリプトの式を記述することができます。\nTaskコンポーネントの実行終了後にこの式を評価し、Truthyな値を返せば成功、\nFalthyな値を返せば失敗と判定されます。\n\n![img](./img/task_retry_expression_enable.png \"task_retry_expression_enable\")\n\n### include, exclude\nTaskコンポーネントがリモートホストで実行された後、リモートホスト上のディレクトリ内にあるファイルは\noutputFileに指定されているなど、その後の処理で必要にならない限りそのままの状態で残されます。\n\n実行時にアプリケーションが出力するログファイルなど、その後のワークフローの処理には不要だが\n確認したいファイルなどがは、`include`に指定することでTaskコンポーネント実行終了時にダウンロードされ\nFilesエリアで確認することができます。\n\n`include`にはディレクトリ名やglobなどを指定することができますが、さらに`exclude`を指定すれば\nダウンロード対象除外することができます。\n\n例えば、`include`に`*.txt`、excludeに`foo.txt`を指定して、実行終了時にfoo.txt,bar.txt,baz.txtが生成されていたとすると\n実際にダウンロードされるファイルは、bar.txt, baz.txtの2つのみとなります。\n\n### cleanup flag\nリモートホストでの実行終了後にリモートホスト上に残されたファイルを削除するかどうかを指定します。\n`remove files`を指定すれば削除、`keep files`を指定すればリモートホスト上に保存されます。\n\nデフォルト設定は`same as parent`が指定されており、上位コンポーネントの設定と同じ動作をします。\n\n\n\n\n\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"task\">Task <a class=\"heading-anchor-permalink\" href=\"#task\">#</a></h1>\n<p><img src=\"./img/task.png\" alt=\"img\" title=\"task\"></p>\n<p>Taskコンポーネントは、WHEELの用意するコンポーネントの中で最も基本的かつ重要なコンポーネントです。\n[ script ]プロパティに設定されたスクリプトファイルを実行環境(host/useJobScheduler/queueプロパティ)の設定に応じて実行します。</p>\n<p>Taskコンポーネントに指定することのできるプロパティは以下のとおりです。\nなお、name, description, inputFile, outpuFileの4項目については<a href=\"./00_common.html\">共通項目</a>をご参照ください。</p>\n<h3 id=\"script\">script <a class=\"heading-anchor-permalink\" href=\"#script\">#</a></h3>\n<p>Taskコンポーネントの実行時に呼ぶスクリプトのファイル名を設定します。</p>\n<p><img src=\"./img/task_script.png\" alt=\"img\" title=\"task_script\"></p>\n<p>scriptプロパティの入力欄はセレクトボックスになっており、\nTaskコンポーネント内に存在するファイルの中から選ぶことができます。</p>\n<h3 id=\"host\">host <a class=\"heading-anchor-permalink\" href=\"#host\">#</a></h3>\n<p><a href=\"../../2_remotehost_screen/remotehost.html\">リモートホスト設定</a>にて設定されたリモートホストのラベル\nまたは&quot;localhost&quot;を設定します。</p>\n<p><img src=\"./img/task_host.png\" alt=\"img\" title=\"task_host\"></p>\n<p>hostが&quot;localhost&quot;の時は、scriptはWHEELが動作しているマシン上で実行されますが\nそれ以外の値が設定されている時は、リモートホストへsshでディレクトリ全体を転送し\nリモートホスト上で実行されます。(後述のuseJobSchedulerが設定されている時は、バッチサーバにジョブを投入します)</p>\n<h3 id=\"usejobscheduler\">useJobScheduler <a class=\"heading-anchor-permalink\" href=\"#usejobscheduler\">#</a></h3>\n<p>scriptの実行をバッチサーバに投入する時に有効にします。\nuseJobSchedulerを有効に設定した時のみ、次のqueue, submit optionプロパティを設定することができます。</p>\n<p>無効のとき\n<img src=\"./img/task_jobScheduler_disable.png\" alt=\"img\" title=\"task_jobScheduler_disable\"></p>\n<p>有効のとき\n<img src=\"./img/task_jobScheduler_enable.png\" alt=\"img\" title=\"task_jobScheduler_enable\"></p>\n<h3 id=\"queue\">queue <a class=\"heading-anchor-permalink\" href=\"#queue\">#</a></h3>\n<p>ジョブを投入するキューをリモートホスト設定で設定したキューの中から選びます。\n無指定の場合はバッチサーバのデフォルトキューに対してジョブを投入します。</p>\n<h3 id=\"submit-command\">submit command <a class=\"heading-anchor-permalink\" href=\"#submit-command\">#</a></h3>\n<p>この欄は実際にはTaskコンポーネントのプロパティではなく、リモートホスト設定で指定された\nバッチサーバにジョブを投入する時のコマンド名が表示されています。</p>\n<p>ここでは変更することはできません。</p>\n<h3 id=\"submit-option\">submit option <a class=\"heading-anchor-permalink\" href=\"#submit-option\">#</a></h3>\n<p>ジョブ投入時に追加で指定するオプションを設定します。</p>\n<h3 id=\"number-of-retry\">number of retry <a class=\"heading-anchor-permalink\" href=\"#number-of-retry\">#</a></h3>\n<p>Taskコンポーネントの実行に失敗した時に、自動的に再実行を行なう回数を指定します。\n無指定時は再実行は行ないません。</p>\n<p><img src=\"./img/task_num_retry.png\" alt=\"img\" title=\"task_number_of_retry\"></p>\n<h3 id=\"use-javascript-expression-for-condition-check\">use javascript expression for condition check <a class=\"heading-anchor-permalink\" href=\"#use-javascript-expression-for-condition-check\">#</a></h3>\n<p>Taskコンポーネントの成功/失敗を判定するのに\njavascript式を用いるか、シェルスクリプトを用いるか指定します。</p>\n<p>無効の時は、シェルスクリプトを選択するドロップダウンリストが表示されており\nTaskコンポーネント実行終了後に指定されたシェルスクリプトが実行されて\n戻り値が0であれば成功、0以外であれば失敗と判定されます。</p>\n<p>なお、無指定の時は[script]に指定したスクリプトの戻り値で同様の判定を行ないます。</p>\n<p><img src=\"./img/task_retry_expression_disable.png\" alt=\"img\" title=\"task_retry_expression_disable\"></p>\n<p>有効の時は、ジャバスクリプトの式を記述することができます。\nTaskコンポーネントの実行終了後にこの式を評価し、Truthyな値を返せば成功、\nFalthyな値を返せば失敗と判定されます。</p>\n<p><img src=\"./img/task_retry_expression_enable.png\" alt=\"img\" title=\"task_retry_expression_enable\"></p>\n<h3 id=\"include%2C-exclude\">include, exclude <a class=\"heading-anchor-permalink\" href=\"#include%2C-exclude\">#</a></h3>\n<p>Taskコンポーネントがリモートホストで実行された後、リモートホスト上のディレクトリ内にあるファイルは\noutputFileに指定されているなど、その後の処理で必要にならない限りそのままの状態で残されます。</p>\n<p>実行時にアプリケーションが出力するログファイルなど、その後のワークフローの処理には不要だが\n確認したいファイルなどがは、<code>include</code>に指定することでTaskコンポーネント実行終了時にダウンロードされ\nFilesエリアで確認することができます。</p>\n<p><code>include</code>にはディレクトリ名やglobなどを指定することができますが、さらに<code>exclude</code>を指定すれば\nダウンロード対象除外することができます。</p>\n<p>例えば、<code>include</code>に<code>*.txt</code>、excludeに<code>foo.txt</code>を指定して、実行終了時にfoo.txt,bar.txt,baz.txtが生成されていたとすると\n実際にダウンロードされるファイルは、bar.txt, baz.txtの2つのみとなります。</p>\n<h3 id=\"cleanup-flag\">cleanup flag <a class=\"heading-anchor-permalink\" href=\"#cleanup-flag\">#</a></h3>\n<p>リモートホストでの実行終了後にリモートホスト上に残されたファイルを削除するかどうかを指定します。\n<code>remove files</code>を指定すれば削除、<code>keep files</code>を指定すればリモートホスト上に保存されます。</p>\n<p>デフォルト設定は<code>same as parent</code>が指定されており、上位コンポーネントの設定と同じ動作をします。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 15
    },
    {
      "path": "3_reference_manual/4_component/02_If.md",
      "url": "3_reference_manual/4_component/02_If.html",
      "content": "# If\n\n![img](./img/if.png \"if\")\n\nIfコンポーネントは、[ condition ]プロパティに設定したスクリプトまたはJavascript式によって\n条件判定を行ない、その後のワークフローの処理を分岐させます。\n\n真の場合はnext（緑）に指定されたコンポーネント、偽の場合はelse（紫）に指定されたコンポーネントが\n後続コンポーネントとして処理されます。\n\nIfコンポーネントに設定できるプロパティは以下のとおりです。\n\n### condition\n条件判定を行うためのシェルスクリプト名または、Javasciprt式を設定することができます。\nTaskコンポーネントのretry処理と同様です。\n\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"if\">If <a class=\"heading-anchor-permalink\" href=\"#if\">#</a></h1>\n<p><img src=\"./img/if.png\" alt=\"img\" title=\"if\"></p>\n<p>Ifコンポーネントは、[ condition ]プロパティに設定したスクリプトまたはJavascript式によって\n条件判定を行ない、その後のワークフローの処理を分岐させます。</p>\n<p>真の場合はnext（緑）に指定されたコンポーネント、偽の場合はelse（紫）に指定されたコンポーネントが\n後続コンポーネントとして処理されます。</p>\n<p>Ifコンポーネントに設定できるプロパティは以下のとおりです。</p>\n<h3 id=\"condition\">condition <a class=\"heading-anchor-permalink\" href=\"#condition\">#</a></h3>\n<p>条件判定を行うためのシェルスクリプト名または、Javasciprt式を設定することができます。\nTaskコンポーネントのretry処理と同様です。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 16
    },
    {
      "path": "3_reference_manual/4_component/03_For.md",
      "url": "3_reference_manual/4_component/03_For.html",
      "content": "# For\n\n![img](./img/for.png \"for\")\n\nForコンポーネントは、FortranのDoループのように指定されたインデックス値に応じて\n下位コンポーネントを繰り返し実行します。\n\nForコンポーネントに設定できるプロパティは以下のとおりです。\n\n### start\nインデックスの始値を設定します。\n\n### end\nインデックスの終値を設定します。\n\n### step\nインデックス更新時の更新幅を設定します。\n\n### number of instances to keep\n各インデックスで処理を行なった時のディレクトリを最大何個まで残すかを指定します。\n無指定の時は、全てのディレクトリが保存されます。\n\n## Forコンポーネント実行時の挙動\nForコンポーネントが初めて実行される時、コンポーネントのディレクトリはインデックスの値を末尾につけた名前に\nコピーされます。\nコピーされたディレクトリ内の下位コンポーネントの実行が全て終了すると、新しいインデックス値が計算され\nその値に基いてさらにディレクトリがコピーされます。\n\nこの処理は順次繰り返し実行され、インデックスの値が終値を超えるまで続けられます。\n終値を超えた時点のディレクトリは元のディレクトリにコピーされ、Forコンポーネントの処理は終了します。\nなお、stepにマイナスの値を設定した場合も始値 > 終値 となっていれば正常に実行されます。\nこの場合はインデックスが終値を下回ると実行終了となります。\n\n\n例えば、rt=1, end=3,step=2と設定された `for`というコンポーネントは\n次のように処理されます。\n\n1. `for`ディレクトリが`for_1`ディレクトリにコピーされる\n2. `for_1`ディレクトリ内のコンポーネントが順次実行される\n3. index計算 1+2 = 3  => 終値の3と等しいので次のループを実行する\n4. `for_1`ディレクトリが`for_3`ディレクトリにコピーされる\n5. `for_3`ディレクトリ内のコンポーネントが順次実行される\n6. index計算 3+2 = 5  => 終値の3を超えているので、終了処理を行なう\n7. `for_3`ディレクトリを`for`ディレクトリにコピー\n\nnumber of instance to keepの値が0以外に設定されていた場合は、4,7の処理を行なった時に\n設定された数を超える古いディレクトリ(`for_1`や`for_3`など)を削除します。\n\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"for\">For <a class=\"heading-anchor-permalink\" href=\"#for\">#</a></h1>\n<p><img src=\"./img/for.png\" alt=\"img\" title=\"for\"></p>\n<p>Forコンポーネントは、FortranのDoループのように指定されたインデックス値に応じて\n下位コンポーネントを繰り返し実行します。</p>\n<p>Forコンポーネントに設定できるプロパティは以下のとおりです。</p>\n<h3 id=\"start\">start <a class=\"heading-anchor-permalink\" href=\"#start\">#</a></h3>\n<p>インデックスの始値を設定します。</p>\n<h3 id=\"end\">end <a class=\"heading-anchor-permalink\" href=\"#end\">#</a></h3>\n<p>インデックスの終値を設定します。</p>\n<h3 id=\"step\">step <a class=\"heading-anchor-permalink\" href=\"#step\">#</a></h3>\n<p>インデックス更新時の更新幅を設定します。</p>\n<h3 id=\"number-of-instances-to-keep\">number of instances to keep <a class=\"heading-anchor-permalink\" href=\"#number-of-instances-to-keep\">#</a></h3>\n<p>各インデックスで処理を行なった時のディレクトリを最大何個まで残すかを指定します。\n無指定の時は、全てのディレクトリが保存されます。</p>\n<h2 id=\"for%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%AE%9F%E8%A1%8C%E6%99%82%E3%81%AE%E6%8C%99%E5%8B%95\">Forコンポーネント実行時の挙動 <a class=\"heading-anchor-permalink\" href=\"#for%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%AE%9F%E8%A1%8C%E6%99%82%E3%81%AE%E6%8C%99%E5%8B%95\">#</a></h2>\n<p>Forコンポーネントが初めて実行される時、コンポーネントのディレクトリはインデックスの値を末尾につけた名前に\nコピーされます。\nコピーされたディレクトリ内の下位コンポーネントの実行が全て終了すると、新しいインデックス値が計算され\nその値に基いてさらにディレクトリがコピーされます。</p>\n<p>この処理は順次繰り返し実行され、インデックスの値が終値を超えるまで続けられます。\n終値を超えた時点のディレクトリは元のディレクトリにコピーされ、Forコンポーネントの処理は終了します。\nなお、stepにマイナスの値を設定した場合も始値 &gt; 終値 となっていれば正常に実行されます。\nこの場合はインデックスが終値を下回ると実行終了となります。</p>\n<p>例えば、rt=1, end=3,step=2と設定された <code>for</code>というコンポーネントは\n次のように処理されます。</p>\n<ol>\n<li><code>for</code>ディレクトリが<code>for_1</code>ディレクトリにコピーされる</li>\n<li><code>for_1</code>ディレクトリ内のコンポーネントが順次実行される</li>\n<li>index計算 1+2 = 3  =&gt; 終値の3と等しいので次のループを実行する</li>\n<li><code>for_1</code>ディレクトリが<code>for_3</code>ディレクトリにコピーされる</li>\n<li><code>for_3</code>ディレクトリ内のコンポーネントが順次実行される</li>\n<li>index計算 3+2 = 5  =&gt; 終値の3を超えているので、終了処理を行なう</li>\n<li><code>for_3</code>ディレクトリを<code>for</code>ディレクトリにコピー</li>\n</ol>\n<p>number of instance to keepの値が0以外に設定されていた場合は、4,7の処理を行なった時に\n設定された数を超える古いディレクトリ(<code>for_1</code>や<code>for_3</code>など)を削除します。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 17
    },
    {
      "path": "3_reference_manual/4_component/04_while.md",
      "url": "3_reference_manual/4_component/04_while.html",
      "content": "# While\n\n![img](./img/while.png \"while\")\n\n\nWhileコンポーネントは、各種プログラミング言語のWhileループと同様に\n設定された条件判定が真の間、\n下位コンポーネントを繰り返し実行します。\n\nWhileコンポーネントに設定できるプロパティは以下のとおりです。\n\n### use javascript expression for condition check\nTaskコンポーネントのretry判定と同じく、\n繰り返し実行を行うかどうかの判定にシェルスクリプトを用いるか\nJavascriptの式を用いるかを指定します。\n\n### script name for condition check\nuse javascript expression for condition checkが無効の時のみ\n条件判定に用いるシェルスクリプトをドロップダウンリストから選択します。\n\n### jacascript expression\nuse javascript expression for condition checkが有効の時のみ\n条件判定に用いるjavascript式を設定します。\n\n### number of instances to keep\n各インデックスで処理を行なった時のディレクトリを最大何個まで残すかを指定します。\n無指定の時は、全てのディレクトリが保存されます。\n\n## Whileコンポーネント実行時の挙動\nForeachコンポーネントもForコンポーネントと同様の挙動をしますが\nディレクトリ名の末尾にはインデックス値の代わりに、\n0から始まる数字を1刻みで使用します。\n\nまた終了判定もインデックス値の計算ではなく設定されたシェルスクリプトの戻り値か\nJavascript式の評価結果を用います。\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"while\">While <a class=\"heading-anchor-permalink\" href=\"#while\">#</a></h1>\n<p><img src=\"./img/while.png\" alt=\"img\" title=\"while\"></p>\n<p>Whileコンポーネントは、各種プログラミング言語のWhileループと同様に\n設定された条件判定が真の間、\n下位コンポーネントを繰り返し実行します。</p>\n<p>Whileコンポーネントに設定できるプロパティは以下のとおりです。</p>\n<h3 id=\"use-javascript-expression-for-condition-check\">use javascript expression for condition check <a class=\"heading-anchor-permalink\" href=\"#use-javascript-expression-for-condition-check\">#</a></h3>\n<p>Taskコンポーネントのretry判定と同じく、\n繰り返し実行を行うかどうかの判定にシェルスクリプトを用いるか\nJavascriptの式を用いるかを指定します。</p>\n<h3 id=\"script-name-for-condition-check\">script name for condition check <a class=\"heading-anchor-permalink\" href=\"#script-name-for-condition-check\">#</a></h3>\n<p>use javascript expression for condition checkが無効の時のみ\n条件判定に用いるシェルスクリプトをドロップダウンリストから選択します。</p>\n<h3 id=\"jacascript-expression\">jacascript expression <a class=\"heading-anchor-permalink\" href=\"#jacascript-expression\">#</a></h3>\n<p>use javascript expression for condition checkが有効の時のみ\n条件判定に用いるjavascript式を設定します。</p>\n<h3 id=\"number-of-instances-to-keep\">number of instances to keep <a class=\"heading-anchor-permalink\" href=\"#number-of-instances-to-keep\">#</a></h3>\n<p>各インデックスで処理を行なった時のディレクトリを最大何個まで残すかを指定します。\n無指定の時は、全てのディレクトリが保存されます。</p>\n<h2 id=\"while%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%AE%9F%E8%A1%8C%E6%99%82%E3%81%AE%E6%8C%99%E5%8B%95\">Whileコンポーネント実行時の挙動 <a class=\"heading-anchor-permalink\" href=\"#while%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%AE%9F%E8%A1%8C%E6%99%82%E3%81%AE%E6%8C%99%E5%8B%95\">#</a></h2>\n<p>ForeachコンポーネントもForコンポーネントと同様の挙動をしますが\nディレクトリ名の末尾にはインデックス値の代わりに、\n0から始まる数字を1刻みで使用します。</p>\n<p>また終了判定もインデックス値の計算ではなく設定されたシェルスクリプトの戻り値か\nJavascript式の評価結果を用います。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 18
    },
    {
      "path": "3_reference_manual/4_component/05_Foreach.md",
      "url": "3_reference_manual/4_component/05_Foreach.html",
      "content": "# Foreach\n\n![img](./img/foreach.png \"foreach\")\n\nForeachコンポーネントは、シェルスクリプトのforループのように\n設定されたインデックスのリストをもとに\n下位コンポーネントを繰り返し実行します。\n\nForeachコンポーネントに設定できるプロパティは以下のとおりです。\n\n### indexList\nインデックス値のリスト\n\n### number of instances to keep\n各インデックスで処理を行なった時のディレクトリを最大何個まで残すかを指定します。\n無指定の時は、全てのディレクトリが保存されます。\n\n\n## Foreachコンポーネント実行時の挙動\nForeachコンポーネントもForコンポーネントと同様の挙動をしますが\nインデックス値は計算によって求められるのではなく\nindexListに設定された値がリストの先頭から順に使われ\nリストの終端まで実行されるとコンポーネント全体の実行を終了します。\n\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"foreach\">Foreach <a class=\"heading-anchor-permalink\" href=\"#foreach\">#</a></h1>\n<p><img src=\"./img/foreach.png\" alt=\"img\" title=\"foreach\"></p>\n<p>Foreachコンポーネントは、シェルスクリプトのforループのように\n設定されたインデックスのリストをもとに\n下位コンポーネントを繰り返し実行します。</p>\n<p>Foreachコンポーネントに設定できるプロパティは以下のとおりです。</p>\n<h3 id=\"indexlist\">indexList <a class=\"heading-anchor-permalink\" href=\"#indexlist\">#</a></h3>\n<p>インデックス値のリスト</p>\n<h3 id=\"number-of-instances-to-keep\">number of instances to keep <a class=\"heading-anchor-permalink\" href=\"#number-of-instances-to-keep\">#</a></h3>\n<p>各インデックスで処理を行なった時のディレクトリを最大何個まで残すかを指定します。\n無指定の時は、全てのディレクトリが保存されます。</p>\n<h2 id=\"foreach%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%AE%9F%E8%A1%8C%E6%99%82%E3%81%AE%E6%8C%99%E5%8B%95\">Foreachコンポーネント実行時の挙動 <a class=\"heading-anchor-permalink\" href=\"#foreach%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%AE%9F%E8%A1%8C%E6%99%82%E3%81%AE%E6%8C%99%E5%8B%95\">#</a></h2>\n<p>ForeachコンポーネントもForコンポーネントと同様の挙動をしますが\nインデックス値は計算によって求められるのではなく\nindexListに設定された値がリストの先頭から順に使われ\nリストの終端まで実行されるとコンポーネント全体の実行を終了します。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 19
    },
    {
      "path": "3_reference_manual/4_component/06_PS.md",
      "url": "3_reference_manual/4_component/06_PS.html",
      "content": "# ParameterStudy\n\n![img](./img/PS.png \"Parameter Study\")\n\nParameterStudyコンポーネント（以下、PSコンポーネント）は、\nParameterFileに指定されたパラメータ空間内で\n全ての組み合わせについて下位コンポーネントを可能な限り並列実行します。\n\n\nPSコンポーネントに設定できるプロパティは以下のとおりです。\n\n### parameterFile\nパラメータ空間を定義したJsonファイルを指定します。\nparameterFileの作成には[テキストエディタ画面](../../2_WHEEL_manual/3_workflow_screen/3_editor.md)のPS-configモードを用いてください。\n\n### force overwrite\nパラメータを設定したディレクトリを作成する際に、\n既存のディレクトリが存在しても上書きするかどうかを設定します。\n\n### delete all instances\n実行終了時にコピーされた個々のパラメータ用のディレクトリを削除するかどうかを指定します。\n\n\n## PSコンポーネント実行時の挙動\nPSコンポーネントは実行開始時にパラメータ設定ファイルを読み込み、\nそこに定義されたパラメータ空間内の全組み合わせに相当する\nディレクトリを自身のディレクトリをコピーすることで作成します。\n\nこの時、パラメータ設定ファイル中の`targetFiles`に設定されたファイルは\n単純なコピーではなくファイル内に書かれたプレースホルダを\nそのパラメータの設定値に書き換えられたファイルがコピーされます。\n\nまた`scatter`に設定されたファイルは、設定された内容に応じて\n必要なディレクトリのみに、名前を変更してコピーされます。\n\n名前としてパラメータの値を用いることもできます。\n\nコピーされたディレクトリ内のコンポーネントは、並列に実行されますが\nTaskコンポーネントについては同時実行本数の制限のなかでの並列実行となります。\n\n全てのパラメータについてコンポーネントの実行が終了すると\n`gather`に設定されたファイルのみが、元のディレクトリ以下に集められます。\nこの時もパラメータの値を用いてファイル名を変更することができるので\nアプリケーションの実行結果ファイルなどで、同じ名前のファイルが作成されている場合は\nこの機能を用いてリネームして集めてください。\n\ngather機能で指定されたなかったファイルは`delete all instances`を\n指定しない限り消されることはありませんが、WHEELのGUIからはアクセスできないディレクトリに\n置かれるため、実行終了後にアクセスすることはできなくなります。\n\n\n\n\n\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"parameterstudy\">ParameterStudy <a class=\"heading-anchor-permalink\" href=\"#parameterstudy\">#</a></h1>\n<p><img src=\"./img/PS.png\" alt=\"img\" title=\"Parameter Study\"></p>\n<p>ParameterStudyコンポーネント（以下、PSコンポーネント）は、\nParameterFileに指定されたパラメータ空間内で\n全ての組み合わせについて下位コンポーネントを可能な限り並列実行します。</p>\n<p>PSコンポーネントに設定できるプロパティは以下のとおりです。</p>\n<h3 id=\"parameterfile\">parameterFile <a class=\"heading-anchor-permalink\" href=\"#parameterfile\">#</a></h3>\n<p>パラメータ空間を定義したJsonファイルを指定します。\nparameterFileの作成には<a href=\"../../2_WHEEL_manual/3_workflow_screen/3_editor.html\">テキストエディタ画面</a>のPS-configモードを用いてください。</p>\n<h3 id=\"force-overwrite\">force overwrite <a class=\"heading-anchor-permalink\" href=\"#force-overwrite\">#</a></h3>\n<p>パラメータを設定したディレクトリを作成する際に、\n既存のディレクトリが存在しても上書きするかどうかを設定します。</p>\n<h3 id=\"delete-all-instances\">delete all instances <a class=\"heading-anchor-permalink\" href=\"#delete-all-instances\">#</a></h3>\n<p>実行終了時にコピーされた個々のパラメータ用のディレクトリを削除するかどうかを指定します。</p>\n<h2 id=\"ps%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%AE%9F%E8%A1%8C%E6%99%82%E3%81%AE%E6%8C%99%E5%8B%95\">PSコンポーネント実行時の挙動 <a class=\"heading-anchor-permalink\" href=\"#ps%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%AE%9F%E8%A1%8C%E6%99%82%E3%81%AE%E6%8C%99%E5%8B%95\">#</a></h2>\n<p>PSコンポーネントは実行開始時にパラメータ設定ファイルを読み込み、\nそこに定義されたパラメータ空間内の全組み合わせに相当する\nディレクトリを自身のディレクトリをコピーすることで作成します。</p>\n<p>この時、パラメータ設定ファイル中の<code>targetFiles</code>に設定されたファイルは\n単純なコピーではなくファイル内に書かれたプレースホルダを\nそのパラメータの設定値に書き換えられたファイルがコピーされます。</p>\n<p>また<code>scatter</code>に設定されたファイルは、設定された内容に応じて\n必要なディレクトリのみに、名前を変更してコピーされます。</p>\n<p>名前としてパラメータの値を用いることもできます。</p>\n<p>コピーされたディレクトリ内のコンポーネントは、並列に実行されますが\nTaskコンポーネントについては同時実行本数の制限のなかでの並列実行となります。</p>\n<p>全てのパラメータについてコンポーネントの実行が終了すると\n<code>gather</code>に設定されたファイルのみが、元のディレクトリ以下に集められます。\nこの時もパラメータの値を用いてファイル名を変更することができるので\nアプリケーションの実行結果ファイルなどで、同じ名前のファイルが作成されている場合は\nこの機能を用いてリネームして集めてください。</p>\n<p>gather機能で指定されたなかったファイルは<code>delete all instances</code>を\n指定しない限り消されることはありませんが、WHEELのGUIからはアクセスできないディレクトリに\n置かれるため、実行終了後にアクセスすることはできなくなります。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 20
    },
    {
      "path": "3_reference_manual/4_component/07_Workflow.md",
      "url": "3_reference_manual/4_component/07_Workflow.html",
      "content": "# Workflow\n\n![img](./img/workflow.png \"workflow\")\n\nWorkflowコンポーネントは、複数のコンポーネントからなる処理を一つのコンポーネントにまとめるために用います。\nWorkflowコンポーネントを使用することで、ワークフロー編集画面上を処理毎に集約することができ、ワークフロー全体の見通しを良くすることができます。\n\nWorkflowコンポーネントには固有のプロパティはありません。\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"workflow\">Workflow <a class=\"heading-anchor-permalink\" href=\"#workflow\">#</a></h1>\n<p><img src=\"./img/workflow.png\" alt=\"img\" title=\"workflow\"></p>\n<p>Workflowコンポーネントは、複数のコンポーネントからなる処理を一つのコンポーネントにまとめるために用います。\nWorkflowコンポーネントを使用することで、ワークフロー編集画面上を処理毎に集約することができ、ワークフロー全体の見通しを良くすることができます。</p>\n<p>Workflowコンポーネントには固有のプロパティはありません。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 21
    },
    {
      "path": "3_reference_manual/4_component/08_Storage.md",
      "url": "3_reference_manual/4_component/08_Storage.html",
      "content": "# Storage\n\n![img](./img/storage.png \"storage\")\n\nStorageコンポーネントは、プロジェクトディレクトリの範囲外にある\nディレクトリにファイルを保存するためのコンポーネントです。\n\nワークフロー内のファイルはgitによって管理されており\n実行中に生成されたファイルや変更されたファイルは\nCleanボタンをクリックすることで実行開始前の状態に戻されます。\n\n同じプロジェクトを設定を変えて繰り返し実行するような場合など\nプロジェクトのClean後にも保持したいファイルをStorageコンポーネントに\ninputFile/outputFileの機構を用いて転送することで\ngitの管理外の場所にファイルを保存することができます。\n\n\nStorageコンポーネントに設定できるプロパティは以下のとおりです。\n\n### host\nhostには実際にファイルを保存するホストを設定できます。\n\n`localhost`が指定された時はWHEELの動作するマシン上に\nそれ以外が指定された場合は、リモートホスト上にファイルのコピーが\n保存されます。\n\n### path\n![img](./img/storage_path.png \"storage_path\")\n\npathに指定したディレクトリ下にstorageコンポーネントに転送されてきた\nファイルをコピーします。\n\npathがプロジェクトディレクトリの範囲内に設定されていると\nプロジェクトのClean時に消されてしまいますが\nWHEELでは設定したpathがプロジェクトディレクトリ内かどうかの判定は\nしていないため、必要に応じてプロジェクトディレクトリ外のpathを設定してください。\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"storage\">Storage <a class=\"heading-anchor-permalink\" href=\"#storage\">#</a></h1>\n<p><img src=\"./img/storage.png\" alt=\"img\" title=\"storage\"></p>\n<p>Storageコンポーネントは、プロジェクトディレクトリの範囲外にある\nディレクトリにファイルを保存するためのコンポーネントです。</p>\n<p>ワークフロー内のファイルはgitによって管理されており\n実行中に生成されたファイルや変更されたファイルは\nCleanボタンをクリックすることで実行開始前の状態に戻されます。</p>\n<p>同じプロジェクトを設定を変えて繰り返し実行するような場合など\nプロジェクトのClean後にも保持したいファイルをStorageコンポーネントに\ninputFile/outputFileの機構を用いて転送することで\ngitの管理外の場所にファイルを保存することができます。</p>\n<p>Storageコンポーネントに設定できるプロパティは以下のとおりです。</p>\n<h3 id=\"host\">host <a class=\"heading-anchor-permalink\" href=\"#host\">#</a></h3>\n<p>hostには実際にファイルを保存するホストを設定できます。</p>\n<p><code>localhost</code>が指定された時はWHEELの動作するマシン上に\nそれ以外が指定された場合は、リモートホスト上にファイルのコピーが\n保存されます。</p>\n<h3 id=\"path\">path <a class=\"heading-anchor-permalink\" href=\"#path\">#</a></h3>\n<p><img src=\"./img/storage_path.png\" alt=\"img\" title=\"storage_path\"></p>\n<p>pathに指定したディレクトリ下にstorageコンポーネントに転送されてきた\nファイルをコピーします。</p>\n<p>pathがプロジェクトディレクトリの範囲内に設定されていると\nプロジェクトのClean時に消されてしまいますが\nWHEELでは設定したpathがプロジェクトディレクトリ内かどうかの判定は\nしていないため、必要に応じてプロジェクトディレクトリ外のpathを設定してください。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 22
    },
    {
      "path": "3_reference_manual/4_component/09_Source.md",
      "url": "3_reference_manual/4_component/09_Source.html",
      "content": "# Source\n\n![img](./img/source.png \"source\")\n\nSourceコンポーネントは、プロジェクト実行に関する\n入力ファイルに相当するファイルを扱うためのコンポーネントです。\n\nSourceコンポーネントに設定できるプロパティは以下のとおりです。\nなお、SourceコンポーネントにはinputFilesプロパティは指定することができません。\n\n\n### uploadOnDemand\nプロジェクトの実行時にブラウザから実際に使うファイルを\nWHEELにアップロードするかどうかを指定します。\n\n\n## Sourceコンポーネントの挙動\nプロジェクト実行時にSourceコンポーネントのoutputFileに指定されたファイルが\nディレクトリ内に存在する場合、Sourceコンポーネントは特に何も処理せず\n正常終了します。\n\nファイルが存在せず、uploadOnDemandが無効な時は\nディレクトリ内のファイルのリストがブラウザ上に表示され\nユーザが選択したファイルをoutputFileとして扱います。\n\nファイルが存在せず、uploadOnDemandが有効な時は\nブラウザ上でファイルアップロードダイアログが表示され\nユーザがアップロードしたファイルがoutputFileとして扱われます。\n\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"source\">Source <a class=\"heading-anchor-permalink\" href=\"#source\">#</a></h1>\n<p><img src=\"./img/source.png\" alt=\"img\" title=\"source\"></p>\n<p>Sourceコンポーネントは、プロジェクト実行に関する\n入力ファイルに相当するファイルを扱うためのコンポーネントです。</p>\n<p>Sourceコンポーネントに設定できるプロパティは以下のとおりです。\nなお、SourceコンポーネントにはinputFilesプロパティは指定することができません。</p>\n<h3 id=\"uploadondemand\">uploadOnDemand <a class=\"heading-anchor-permalink\" href=\"#uploadondemand\">#</a></h3>\n<p>プロジェクトの実行時にブラウザから実際に使うファイルを\nWHEELにアップロードするかどうかを指定します。</p>\n<h2 id=\"source%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E6%8C%99%E5%8B%95\">Sourceコンポーネントの挙動 <a class=\"heading-anchor-permalink\" href=\"#source%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E6%8C%99%E5%8B%95\">#</a></h2>\n<p>プロジェクト実行時にSourceコンポーネントのoutputFileに指定されたファイルが\nディレクトリ内に存在する場合、Sourceコンポーネントは特に何も処理せず\n正常終了します。</p>\n<p>ファイルが存在せず、uploadOnDemandが無効な時は\nディレクトリ内のファイルのリストがブラウザ上に表示され\nユーザが選択したファイルをoutputFileとして扱います。</p>\n<p>ファイルが存在せず、uploadOnDemandが有効な時は\nブラウザ上でファイルアップロードダイアログが表示され\nユーザがアップロードしたファイルがoutputFileとして扱われます。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 23
    },
    {
      "path": "3_reference_manual/4_component/10_Viewer.md",
      "url": "3_reference_manual/4_component/10_Viewer.html",
      "content": "# Viewer\n\n![img](./img/viewer.png \"viewer\")\n\nViewerコンポーネントはプロジェクト実行中に生成される画像ファイルなどを\nブラウザから確認するためのコンポーネントです。\n表示可能なファイルは次のとおりです。\n\n- apng (Animated Portable Network Graphics)\n- avif (AV1 Image File Format)\n- gif (Graphics Interchange Format)\n- jpeg (Joint Photographic Expert Group image)\n- png (Portable Network Graphics)\n- webp (Web Picture format)\n- tiff (Tagged Image File Format)\n- bmp (BitMaP image)\n- svg (Scalable Vector Graphics)\n\nViewerコンポーネントに指定できる固有のプロパティはありません。\nまた、ViewerコンポーネントにはoutputFilesプロパティを設定することはできません。\n\n### Viewerコンポーネントの挙動\nViewerコンポーネントは先行するコンポーネントの実行終了後に\ninputFileから接続されたファイルを受け取ります。\n\nこれらのファイルに、ブラウザで表示可能な画像ファイルが含まれている時は\n初回のみブラウザ上にダイアログが表示され、\n`OK`をクリックすると別のタブでビューワー画面が表示されます。\n\n![img](./img/viewer_dialog.png \"viewer_dialog\")\n\nまた、画面上部のビューワー画面表示ボタンが有効になり\n以降はこのボタンをクリックすることでビューワー画面を表示することができます。\n\n\n\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"viewer\">Viewer <a class=\"heading-anchor-permalink\" href=\"#viewer\">#</a></h1>\n<p><img src=\"./img/viewer.png\" alt=\"img\" title=\"viewer\"></p>\n<p>Viewerコンポーネントはプロジェクト実行中に生成される画像ファイルなどを\nブラウザから確認するためのコンポーネントです。\n表示可能なファイルは次のとおりです。</p>\n<ul>\n<li>apng (Animated Portable Network Graphics)</li>\n<li>avif (AV1 Image File Format)</li>\n<li>gif (Graphics Interchange Format)</li>\n<li>jpeg (Joint Photographic Expert Group image)</li>\n<li>png (Portable Network Graphics)</li>\n<li>webp (Web Picture format)</li>\n<li>tiff (Tagged Image File Format)</li>\n<li>bmp (BitMaP image)</li>\n<li>svg (Scalable Vector Graphics)</li>\n</ul>\n<p>Viewerコンポーネントに指定できる固有のプロパティはありません。\nまた、ViewerコンポーネントにはoutputFilesプロパティを設定することはできません。</p>\n<h3 id=\"viewer%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E6%8C%99%E5%8B%95\">Viewerコンポーネントの挙動 <a class=\"heading-anchor-permalink\" href=\"#viewer%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E6%8C%99%E5%8B%95\">#</a></h3>\n<p>Viewerコンポーネントは先行するコンポーネントの実行終了後に\ninputFileから接続されたファイルを受け取ります。</p>\n<p>これらのファイルに、ブラウザで表示可能な画像ファイルが含まれている時は\n初回のみブラウザ上にダイアログが表示され、\n<code>OK</code>をクリックすると別のタブでビューワー画面が表示されます。</p>\n<p><img src=\"./img/viewer_dialog.png\" alt=\"img\" title=\"viewer_dialog\"></p>\n<p>また、画面上部のビューワー画面表示ボタンが有効になり\n以降はこのボタンをクリックすることでビューワー画面を表示することができます。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 24
    },
    {
      "path": "3_reference_manual/4_component/11_Stepjob.md",
      "url": "3_reference_manual/4_component/11_Stepjob.html",
      "content": "# Stepjob\n\n![img](./img/stepjob.png)\n\nstepjob/stepjobTaskコンポーネントは、ジョブスケジューラ「FUJITSU Software Technical Computing Suite（TCS）」のステップジョブ機能に基づいた機能です。\nステップジョブを利用できるリモートホストが設定されている場合のみ使用することができます。\n\n本機能は、stepjobコンポーネントとstepjobコンポーネント内でのみ使用できるstepjobTaskコンポーネントを組み合わせて使用します。\n\nstepjobコンポーネントは特殊なworkflowコンポーネントとして機能し、\n内部にはstepjobTaskコンポーネントのみを配置することができます。\n\nstepjobtaskコンポーネントは実行順と依存関係式を指定することができます。\nこれらの設定に基づいてTCSのステップジョブ機能を用いてサブジョブとして投入されます。\n\nステップジョブ機能の詳細に関しては、ジョブスケジューラ「FUJITSU Software Technical Computing Suite（TCS）」のドキュメントをご確認ください。\n\nStepjob/StepjobTaskコンポーネントに設定できるプロパティは以下のとおりです。\n\n## stepjob\n###  host\ntaskコンポーネントと同様ですが、stepjob機能を利用できるリモートホストを設定する必要があります。\n\n### useJobScheduler\nデフォルトで有効になっており、無効に設定すると\nプロジェクトが正常に実行されなくなります。\n\n### queue\ntaskコンポーネントと同様、ジョブの投入先キューを設定します。\n\n## stepjobtask\n### script\nバッチサーバに投入するジョブスクリプトを設定します。\n\n### useDependency\n有効にすると、次のdependencyFormを設定できるようになり、\nそこで設定された依存関係式に従ってステップジョブが実行されます。\n\n### step number\nstepjobtaskの実行順を決める番号が設定されます。\nこの値はコンポーネント間の接続状況から、WHEELが自動的に計算して設定し\n変更することはできません\n\n### dependencyForm\nジョブ実行を行うにあたっての依存関係式を設定できます。\n\n依存関係式は、実行済みstepjobTaskコンポーネントの\nジョブスクリプトの終了ステータス（ec)\nもしくはジョブの終了コード(pc）にもとづいて\n実行の可否を判断するための式です。\n\n依存関係式の定義は次のとおりです。\n\n```\nsd=form[:[deletetype][:stepno[:stepno[...]]]]\n```\n\n| 式要素 | 説明 |\n| ---- | ---- |\n| sd= | 接頭辞、必須 |\n| form | 投入するサブジョブを実行するかどうかを判断する条件を示す式 |\n| deletetype | サブジョブを実行しない場合の詳細動作の指定 |\n| stepno | どのサブジョブの実行結果に対して適用するかを示すステップナンバー |\n\n#### form\n\nformは、param(ec:依存するサブジョブのジョブスクリプトの終了コード, pc:依存するサブジョブのジョブ終了コード)と\n値「==, !=, <, > , <=, >=」で指定します。\n```\nex.\nec==0\n```\n条件==や!=を指定する場合、値はコンマ(,)で区切ることで複数指定できます。\n\n#### deletetype\ndeletetypeは、以下の3種類指定できます。\n\n| deletetype | 説明 |\n| ---- | ---- |\n| one | このサブジョブのみ削除する。このサブジョブの結果に依存する後続のサブジョブは削除されない |\n| after | このサブジョブ、及びそれに依存する後続のサブジョブのみ削除する|\n| all | このサブジョブ、及び後続のサブジョブを全て削除する |\n\n以下にformプロパティに設定する依存関係式の例を示します。\n```\nex.ステップナンバー0のサブジョブのジョブスクリプトの終了コードが0以外の場合、このサブジョブ以降は実行しない\n\nsd=ec!=0:all:0\n```\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"stepjob\">Stepjob <a class=\"heading-anchor-permalink\" href=\"#stepjob\">#</a></h1>\n<p><img src=\"./img/stepjob.png\" alt=\"img\"></p>\n<p>stepjob/stepjobTaskコンポーネントは、ジョブスケジューラ「FUJITSU Software Technical Computing Suite（TCS）」のステップジョブ機能に基づいた機能です。\nステップジョブを利用できるリモートホストが設定されている場合のみ使用することができます。</p>\n<p>本機能は、stepjobコンポーネントとstepjobコンポーネント内でのみ使用できるstepjobTaskコンポーネントを組み合わせて使用します。</p>\n<p>stepjobコンポーネントは特殊なworkflowコンポーネントとして機能し、\n内部にはstepjobTaskコンポーネントのみを配置することができます。</p>\n<p>stepjobtaskコンポーネントは実行順と依存関係式を指定することができます。\nこれらの設定に基づいてTCSのステップジョブ機能を用いてサブジョブとして投入されます。</p>\n<p>ステップジョブ機能の詳細に関しては、ジョブスケジューラ「FUJITSU Software Technical Computing Suite（TCS）」のドキュメントをご確認ください。</p>\n<p>Stepjob/StepjobTaskコンポーネントに設定できるプロパティは以下のとおりです。</p>\n<h2 id=\"stepjob-2\">stepjob <a class=\"heading-anchor-permalink\" href=\"#stepjob-2\">#</a></h2>\n<h3 id=\"host\">host <a class=\"heading-anchor-permalink\" href=\"#host\">#</a></h3>\n<p>taskコンポーネントと同様ですが、stepjob機能を利用できるリモートホストを設定する必要があります。</p>\n<h3 id=\"usejobscheduler\">useJobScheduler <a class=\"heading-anchor-permalink\" href=\"#usejobscheduler\">#</a></h3>\n<p>デフォルトで有効になっており、無効に設定すると\nプロジェクトが正常に実行されなくなります。</p>\n<h3 id=\"queue\">queue <a class=\"heading-anchor-permalink\" href=\"#queue\">#</a></h3>\n<p>taskコンポーネントと同様、ジョブの投入先キューを設定します。</p>\n<h2 id=\"stepjobtask\">stepjobtask <a class=\"heading-anchor-permalink\" href=\"#stepjobtask\">#</a></h2>\n<h3 id=\"script\">script <a class=\"heading-anchor-permalink\" href=\"#script\">#</a></h3>\n<p>バッチサーバに投入するジョブスクリプトを設定します。</p>\n<h3 id=\"usedependency\">useDependency <a class=\"heading-anchor-permalink\" href=\"#usedependency\">#</a></h3>\n<p>有効にすると、次のdependencyFormを設定できるようになり、\nそこで設定された依存関係式に従ってステップジョブが実行されます。</p>\n<h3 id=\"step-number\">step number <a class=\"heading-anchor-permalink\" href=\"#step-number\">#</a></h3>\n<p>stepjobtaskの実行順を決める番号が設定されます。\nこの値はコンポーネント間の接続状況から、WHEELが自動的に計算して設定し\n変更することはできません</p>\n<h3 id=\"dependencyform\">dependencyForm <a class=\"heading-anchor-permalink\" href=\"#dependencyform\">#</a></h3>\n<p>ジョブ実行を行うにあたっての依存関係式を設定できます。</p>\n<p>依存関係式は、実行済みstepjobTaskコンポーネントの\nジョブスクリプトの終了ステータス（ec)\nもしくはジョブの終了コード(pc）にもとづいて\n実行の可否を判断するための式です。</p>\n<p>依存関係式の定義は次のとおりです。</p>\n<pre><code>sd=form[:[deletetype][:stepno[:stepno[...]]]]\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>式要素</th>\n<th>説明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sd=</td>\n<td>接頭辞、必須</td>\n</tr>\n<tr>\n<td>form</td>\n<td>投入するサブジョブを実行するかどうかを判断する条件を示す式</td>\n</tr>\n<tr>\n<td>deletetype</td>\n<td>サブジョブを実行しない場合の詳細動作の指定</td>\n</tr>\n<tr>\n<td>stepno</td>\n<td>どのサブジョブの実行結果に対して適用するかを示すステップナンバー</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"form\">form <a class=\"heading-anchor-permalink\" href=\"#form\">#</a></h4>\n<p>formは、param(ec:依存するサブジョブのジョブスクリプトの終了コード, pc:依存するサブジョブのジョブ終了コード)と\n値「==, !=, &lt;, &gt; , &lt;=, &gt;=」で指定します。</p>\n<pre><code>ex.\nec==0\n</code></pre>\n<p>条件==や!=を指定する場合、値はコンマ(,)で区切ることで複数指定できます。</p>\n<h4 id=\"deletetype\">deletetype <a class=\"heading-anchor-permalink\" href=\"#deletetype\">#</a></h4>\n<p>deletetypeは、以下の3種類指定できます。</p>\n<table>\n<thead>\n<tr>\n<th>deletetype</th>\n<th>説明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>one</td>\n<td>このサブジョブのみ削除する。このサブジョブの結果に依存する後続のサブジョブは削除されない</td>\n</tr>\n<tr>\n<td>after</td>\n<td>このサブジョブ、及びそれに依存する後続のサブジョブのみ削除する</td>\n</tr>\n<tr>\n<td>all</td>\n<td>このサブジョブ、及び後続のサブジョブを全て削除する</td>\n</tr>\n</tbody>\n</table>\n<p>以下にformプロパティに設定する依存関係式の例を示します。</p>\n<pre><code>ex.ステップナンバー0のサブジョブのジョブスクリプトの終了コードが0以外の場合、このサブジョブ以降は実行しない\n\nsd=ec!=0:all:0\n</code></pre>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 25
    },
    {
      "path": "3_reference_manual/4_component/12_BulkjobTask.md",
      "url": "3_reference_manual/4_component/12_BulkjobTask.html",
      "content": "# BulkjobTask\n\n![img](./img/bulkjobTask.png)\n\nbulkjobTaskコンポーネントは、ジョブスケジューラ「FUJITSU Software Technical Computing Suite（TCS）」のバルクジョブ機能に基づいた機能です。\nバルクジョブを利用できるリモートホストが設定されている場合のみ使用することができます。\n\nbuildjobTaskコンポーネントには、バルク番号、インプットファイルを指定することができ\nこれらの設定に基づいてサブジョブとして複数のジョブが投入されます。\n\nバルクジョブ機能の詳細に関しては、ジョブスケジューラ「FUJITSU Software Technical Computing Suite（TCS）」のドキュメントをご確認ください。\n\nbulkjobTaskコンポーネントに設定できるプロパティは以下のとおりです。\n\n### use parameter setting file for bulk number\nバルク番号をパラメータ設定ファイルから指定するかどうかを設定します。\n\n有効の時はパラメータ設定ファイルを指定することができます。\n\n無効の時は、startおよびendの値を指定することができ、それぞれ開始バルク番号\n終了バルク番号として扱われます。\n\n### manual finish condition\nコンポーネントの終了状態の判定を独自に指定するかどうかを設定します。\n\n--------\n[リファレンスマニュアルのトップページに戻る](../index.md)\n",
      "html": "<h1 id=\"bulkjobtask\">BulkjobTask <a class=\"heading-anchor-permalink\" href=\"#bulkjobtask\">#</a></h1>\n<p><img src=\"./img/bulkjobTask.png\" alt=\"img\"></p>\n<p>bulkjobTaskコンポーネントは、ジョブスケジューラ「FUJITSU Software Technical Computing Suite（TCS）」のバルクジョブ機能に基づいた機能です。\nバルクジョブを利用できるリモートホストが設定されている場合のみ使用することができます。</p>\n<p>buildjobTaskコンポーネントには、バルク番号、インプットファイルを指定することができ\nこれらの設定に基づいてサブジョブとして複数のジョブが投入されます。</p>\n<p>バルクジョブ機能の詳細に関しては、ジョブスケジューラ「FUJITSU Software Technical Computing Suite（TCS）」のドキュメントをご確認ください。</p>\n<p>bulkjobTaskコンポーネントに設定できるプロパティは以下のとおりです。</p>\n<h3 id=\"use-parameter-setting-file-for-bulk-number\">use parameter setting file for bulk number <a class=\"heading-anchor-permalink\" href=\"#use-parameter-setting-file-for-bulk-number\">#</a></h3>\n<p>バルク番号をパラメータ設定ファイルから指定するかどうかを設定します。</p>\n<p>有効の時はパラメータ設定ファイルを指定することができます。</p>\n<p>無効の時は、startおよびendの値を指定することができ、それぞれ開始バルク番号\n終了バルク番号として扱われます。</p>\n<h3 id=\"manual-finish-condition\">manual finish condition <a class=\"heading-anchor-permalink\" href=\"#manual-finish-condition\">#</a></h3>\n<p>コンポーネントの終了状態の判定を独自に指定するかどうかを設定します。</p>\n<hr>\n<p><a href=\"../index.html\">リファレンスマニュアルのトップページに戻る</a></p>\n",
      "id": 26
    },
    {
      "path": "3_reference_manual/index.md",
      "url": "3_reference_manual/index.html",
      "content": "# WHEEL リファレンスマニュアル\n本ドキュメントはWHEELの画面構成、機能を網羅的に説明するリファレンスマニュアルです。\n\n[1. ホーム画面](1_home_screen/home.md)\n\n[2. リモートホスト画面](2_remotehost_screen/remotehost.md)\n\n[3. ワークフロー画面-グラフビュー](3_workflow_screen/1_graphview.md)\n\n[4. ワークフロー画面-リストビュー](3_workflow_screen/2_listview.md)\n\n[5. ワークフロー画面-テキストエディタ](3_workflow_screen/3_editor.md)\n\n[6. コンポーネントの詳細](4_component/00_common.md)\n\n具体的なプロジェクトの作成・実行方法は次のドキュメントをご参照ください\n\n[WHEELチュートリアル](../3_WHEEL_tutorial/index.md)\n\n\n\n--------\n[トップページに戻る](../index.md)\n",
      "html": "<h1 id=\"wheel-%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9%E3%83%9E%E3%83%8B%E3%83%A5%E3%82%A2%E3%83%AB\">WHEEL リファレンスマニュアル <a class=\"heading-anchor-permalink\" href=\"#wheel-%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9%E3%83%9E%E3%83%8B%E3%83%A5%E3%82%A2%E3%83%AB\">#</a></h1>\n<p>本ドキュメントはWHEELの画面構成、機能を網羅的に説明するリファレンスマニュアルです。</p>\n<p><a href=\"1_home_screen/home.html\">1. ホーム画面</a></p>\n<p><a href=\"2_remotehost_screen/remotehost.html\">2. リモートホスト画面</a></p>\n<p><a href=\"3_workflow_screen/1_graphview.html\">3. ワークフロー画面-グラフビュー</a></p>\n<p><a href=\"3_workflow_screen/2_listview.html\">4. ワークフロー画面-リストビュー</a></p>\n<p><a href=\"3_workflow_screen/3_editor.html\">5. ワークフロー画面-テキストエディタ</a></p>\n<p><a href=\"4_component/00_common.html\">6. コンポーネントの詳細</a></p>\n<p>具体的なプロジェクトの作成・実行方法は次のドキュメントをご参照ください</p>\n<p><a href=\"../3_WHEEL_tutorial/index.html\">WHEELチュートリアル</a></p>\n<hr>\n<p><a href=\"../index.html\">トップページに戻る</a></p>\n",
      "id": 27
    },
    {
      "path": "4_ATTENTION/index.md",
      "url": "4_ATTENTION/index.html",
      "content": "# 注意事項\n## はじめに\n本ドキュメントは、ワークフローシステムWHEELの仕様上の制限について説明いたします。\n以下の内容によって構成されています。\n1. [リモートタスクがシグナルによって終了した場合](#リモートタスクがシグナルによって終了した場合)\n1. [プロジェクトを停止した場合における実行中スクリプトの取り扱い](#プロジェクトを停止した場合における実行中スクリプトの取り扱い)\n1. [巨大なファイルの取り扱いについて](#巨大なファイルの取り扱いについて)\n1. [input/outputコネクタを接続した状態でのコネクタ名称の変更について](#input/outputコネクタを接続した状態でのコネクタ名称の変更について)\n1. [Windows環境での操作](#Windows環境での操作)\n1. [holdingおよびunknown状態について](#holdingおよびunknown状態について)\n1. [既存プロジェクトの読み込みについて](#既存プロジェクトの読み込みについて)\n\n***\n## リモートタスクがシグナルによって終了した場合\nリモートホストで実行中のプロセスがシグナルによって終了した場合、\nWHEELの仕様上、リモートのシグナル番号を補足できないため正常終了と判断されます。\n***\n## プロジェクトを停止した場合における実行中スクリプトの取り扱い\nプロジェクトの停止ボタンによってプロジェクトを停止した場合、nodeが呼び出した子プロセスは停止されますが、\n子プロセスが実行するスクリプトは停止されません。\n***\n## 巨大なファイルの取り扱いについて\nWHEELではプロジェクトで取り扱うデータをgitで管理しているため大サイズのファイルをプロジェクトディレクトリ内に配置すると\nリポジトリ操作のパフォーマンスが低下することによって様々なトラブルが起きます。\nこの問題を回避するためWHEELのグラフビューからアップロードしたファイルについては一定以上のサイズのものは\ngit LFS (https://git-lfs.github.com/) による管理の対象とするように設定します。\nWHEEL以外の手段でプロジェクトのgitリポジトリにファイルを追加した場合は、サイズによっては正常に操作できなくなる可能性があるので注意してください。\n***\n## input/outputコネクタを接続した状態でのコネクタ名称の変更について\n複数のoutputコネクタを1つのinputコネクタに接続してる状態で、\ninputコネクタの名称変更を行なうと、同時に複数の名称変更処理が行われるため\nコンポーネントの整合性が取れなくなる場合があります。\ninput/outputコネクタの編集を行う際は、接続を解除してから実施してください。\n***\n## Windows環境での操作\nWHEELの動作環境がWindowsOSの際、プロジェクトのdeleteを実行するとエラーが表示される場合があります。\nその場合、deleteしたプロジェクトはプロジェクトリストから削除されますが、実データは削除されません。手動にて削除してください。\n***\n## holdingおよびunknown状態について\nプロジェクトにジョブを投入するタスクが含まれていると、プロジェクトの状態がholdingまたはunknown状態となることがあります。\nholding状態は、ジョブの投入後終了を確認する前に、WHEELのプロセスが終了してしまった時に遷移します。\nこの状態では、プロジェクトの実行は一時停止していますがプロセスが終了する前に投入したジョブの終了確認のみを行なっています。\n全てのジョブが終了した段階で、unknown状態に遷移します。\n\nunknown状態は、プロジェクトの状態が確認できない状態を意味します。\n前述のholding状態から遷移してきた場合は、個々のコンポーネントの状態を確認して全てのタスクが完了しているかどうかを確認してください。\n終了していないタスクが存在する時は、そのままプロジェクトを再実行すると未実行およびfailed状態のコンポーネントのみが再実行されます。\n\nまた、ジョブを投入した後の状態確認処理に失敗した場合(e.g. 一時的な障害などでバッチサーバへの接続が行なえなかった時など)にもunknown状態になります。\nこの場合は、unknown状態となったタスクが正常に終了しているかどうかを直接ジョブ投入先サーバへログインするなどして確認し、\n必要なファイルがあればコピーしてきてください。\n***\n## 既存プロジェクトの読み込みについて\nWHEELは、プロジェクトリストに載っていない既存のプロジェクトを読み込む際に、全ての変更をgitリポジトリにコミットします。このため、読み込むプロジェクトまたはプロジェクトに含まれるコンポーネントが\"not-started\"以外の状態だった場合、プロジェクトのcleanを行なっても再実行できなくなります。\nしたがって、読み込み前にプロジェクトおよびコンポーネントのstateを確認してから実行してください。\n\n\n\n--------\n[トップページに戻る](../index.md)\n",
      "html": "<h1 id=\"%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85\">注意事項 <a class=\"heading-anchor-permalink\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85\">#</a></h1>\n<h2 id=\"%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB\">はじめに <a class=\"heading-anchor-permalink\" href=\"#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB\">#</a></h2>\n<p>本ドキュメントは、ワークフローシステムWHEELの仕様上の制限について説明いたします。\n以下の内容によって構成されています。</p>\n<ol>\n<li><a href=\"#%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%8C%E3%82%B7%E3%82%B0%E3%83%8A%E3%83%AB%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E7%B5%82%E4%BA%86%E3%81%97%E3%81%9F%E5%A0%B4%E5%90%88\">リモートタスクがシグナルによって終了した場合</a></li>\n<li><a href=\"#%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E5%81%9C%E6%AD%A2%E3%81%97%E3%81%9F%E5%A0%B4%E5%90%88%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E5%AE%9F%E8%A1%8C%E4%B8%AD%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%81%AE%E5%8F%96%E3%82%8A%E6%89%B1%E3%81%84\">プロジェクトを停止した場合における実行中スクリプトの取り扱い</a></li>\n<li><a href=\"#%E5%B7%A8%E5%A4%A7%E3%81%AA%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%8F%96%E3%82%8A%E6%89%B1%E3%81%84%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">巨大なファイルの取り扱いについて</a></li>\n<li><a href=\"#input/output%E3%82%B3%E3%83%8D%E3%82%AF%E3%82%BF%E3%82%92%E6%8E%A5%E7%B6%9A%E3%81%97%E3%81%9F%E7%8A%B6%E6%85%8B%E3%81%A7%E3%81%AE%E3%82%B3%E3%83%8D%E3%82%AF%E3%82%BF%E5%90%8D%E7%A7%B0%E3%81%AE%E5%A4%89%E6%9B%B4%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">input/outputコネクタを接続した状態でのコネクタ名称の変更について</a></li>\n<li><a href=\"#Windows%E7%92%B0%E5%A2%83%E3%81%A7%E3%81%AE%E6%93%8D%E4%BD%9C\">Windows環境での操作</a></li>\n<li><a href=\"#holding%E3%81%8A%E3%82%88%E3%81%B3unknown%E7%8A%B6%E6%85%8B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">holdingおよびunknown状態について</a></li>\n<li><a href=\"#%E6%97%A2%E5%AD%98%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">既存プロジェクトの読み込みについて</a></li>\n</ol>\n<hr>\n<h2 id=\"%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%8C%E3%82%B7%E3%82%B0%E3%83%8A%E3%83%AB%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E7%B5%82%E4%BA%86%E3%81%97%E3%81%9F%E5%A0%B4%E5%90%88\">リモートタスクがシグナルによって終了した場合 <a class=\"heading-anchor-permalink\" href=\"#%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%8C%E3%82%B7%E3%82%B0%E3%83%8A%E3%83%AB%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E7%B5%82%E4%BA%86%E3%81%97%E3%81%9F%E5%A0%B4%E5%90%88\">#</a></h2>\n<p>リモートホストで実行中のプロセスがシグナルによって終了した場合、\nWHEELの仕様上、リモートのシグナル番号を補足できないため正常終了と判断されます。</p>\n<hr>\n<h2 id=\"%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E5%81%9C%E6%AD%A2%E3%81%97%E3%81%9F%E5%A0%B4%E5%90%88%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E5%AE%9F%E8%A1%8C%E4%B8%AD%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%81%AE%E5%8F%96%E3%82%8A%E6%89%B1%E3%81%84\">プロジェクトを停止した場合における実行中スクリプトの取り扱い <a class=\"heading-anchor-permalink\" href=\"#%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E5%81%9C%E6%AD%A2%E3%81%97%E3%81%9F%E5%A0%B4%E5%90%88%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E5%AE%9F%E8%A1%8C%E4%B8%AD%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%81%AE%E5%8F%96%E3%82%8A%E6%89%B1%E3%81%84\">#</a></h2>\n<p>プロジェクトの停止ボタンによってプロジェクトを停止した場合、nodeが呼び出した子プロセスは停止されますが、\n子プロセスが実行するスクリプトは停止されません。</p>\n<hr>\n<h2 id=\"%E5%B7%A8%E5%A4%A7%E3%81%AA%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%8F%96%E3%82%8A%E6%89%B1%E3%81%84%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">巨大なファイルの取り扱いについて <a class=\"heading-anchor-permalink\" href=\"#%E5%B7%A8%E5%A4%A7%E3%81%AA%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%8F%96%E3%82%8A%E6%89%B1%E3%81%84%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">#</a></h2>\n<p>WHEELではプロジェクトで取り扱うデータをgitで管理しているため大サイズのファイルをプロジェクトディレクトリ内に配置すると\nリポジトリ操作のパフォーマンスが低下することによって様々なトラブルが起きます。\nこの問題を回避するためWHEELのグラフビューからアップロードしたファイルについては一定以上のサイズのものは\ngit LFS (<a href=\"https://git-lfs.github.com/\">https://git-lfs.github.com/</a>) による管理の対象とするように設定します。\nWHEEL以外の手段でプロジェクトのgitリポジトリにファイルを追加した場合は、サイズによっては正常に操作できなくなる可能性があるので注意してください。</p>\n<hr>\n<h2 id=\"input%2Foutput%E3%82%B3%E3%83%8D%E3%82%AF%E3%82%BF%E3%82%92%E6%8E%A5%E7%B6%9A%E3%81%97%E3%81%9F%E7%8A%B6%E6%85%8B%E3%81%A7%E3%81%AE%E3%82%B3%E3%83%8D%E3%82%AF%E3%82%BF%E5%90%8D%E7%A7%B0%E3%81%AE%E5%A4%89%E6%9B%B4%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">input/outputコネクタを接続した状態でのコネクタ名称の変更について <a class=\"heading-anchor-permalink\" href=\"#input%2Foutput%E3%82%B3%E3%83%8D%E3%82%AF%E3%82%BF%E3%82%92%E6%8E%A5%E7%B6%9A%E3%81%97%E3%81%9F%E7%8A%B6%E6%85%8B%E3%81%A7%E3%81%AE%E3%82%B3%E3%83%8D%E3%82%AF%E3%82%BF%E5%90%8D%E7%A7%B0%E3%81%AE%E5%A4%89%E6%9B%B4%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">#</a></h2>\n<p>複数のoutputコネクタを1つのinputコネクタに接続してる状態で、\ninputコネクタの名称変更を行なうと、同時に複数の名称変更処理が行われるため\nコンポーネントの整合性が取れなくなる場合があります。\ninput/outputコネクタの編集を行う際は、接続を解除してから実施してください。</p>\n<hr>\n<h2 id=\"windows%E7%92%B0%E5%A2%83%E3%81%A7%E3%81%AE%E6%93%8D%E4%BD%9C\">Windows環境での操作 <a class=\"heading-anchor-permalink\" href=\"#windows%E7%92%B0%E5%A2%83%E3%81%A7%E3%81%AE%E6%93%8D%E4%BD%9C\">#</a></h2>\n<p>WHEELの動作環境がWindowsOSの際、プロジェクトのdeleteを実行するとエラーが表示される場合があります。\nその場合、deleteしたプロジェクトはプロジェクトリストから削除されますが、実データは削除されません。手動にて削除してください。</p>\n<hr>\n<h2 id=\"holding%E3%81%8A%E3%82%88%E3%81%B3unknown%E7%8A%B6%E6%85%8B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">holdingおよびunknown状態について <a class=\"heading-anchor-permalink\" href=\"#holding%E3%81%8A%E3%82%88%E3%81%B3unknown%E7%8A%B6%E6%85%8B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">#</a></h2>\n<p>プロジェクトにジョブを投入するタスクが含まれていると、プロジェクトの状態がholdingまたはunknown状態となることがあります。\nholding状態は、ジョブの投入後終了を確認する前に、WHEELのプロセスが終了してしまった時に遷移します。\nこの状態では、プロジェクトの実行は一時停止していますがプロセスが終了する前に投入したジョブの終了確認のみを行なっています。\n全てのジョブが終了した段階で、unknown状態に遷移します。</p>\n<p>unknown状態は、プロジェクトの状態が確認できない状態を意味します。\n前述のholding状態から遷移してきた場合は、個々のコンポーネントの状態を確認して全てのタスクが完了しているかどうかを確認してください。\n終了していないタスクが存在する時は、そのままプロジェクトを再実行すると未実行およびfailed状態のコンポーネントのみが再実行されます。</p>\n<p>また、ジョブを投入した後の状態確認処理に失敗した場合(e.g. 一時的な障害などでバッチサーバへの接続が行なえなかった時など)にもunknown状態になります。\nこの場合は、unknown状態となったタスクが正常に終了しているかどうかを直接ジョブ投入先サーバへログインするなどして確認し、\n必要なファイルがあればコピーしてきてください。</p>\n<hr>\n<h2 id=\"%E6%97%A2%E5%AD%98%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">既存プロジェクトの読み込みについて <a class=\"heading-anchor-permalink\" href=\"#%E6%97%A2%E5%AD%98%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">#</a></h2>\n<p>WHEELは、プロジェクトリストに載っていない既存のプロジェクトを読み込む際に、全ての変更をgitリポジトリにコミットします。このため、読み込むプロジェクトまたはプロジェクトに含まれるコンポーネントが&quot;not-started&quot;以外の状態だった場合、プロジェクトのcleanを行なっても再実行できなくなります。\nしたがって、読み込み前にプロジェクトおよびコンポーネントのstateを確認してから実行してください。</p>\n<hr>\n<p><a href=\"../index.html\">トップページに戻る</a></p>\n",
      "id": 28
    }
  ]
}