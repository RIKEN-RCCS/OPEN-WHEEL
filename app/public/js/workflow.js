webpackJsonp([0],{

/***/ 38:
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2Nzcy93b3JrZmxvdy5jc3M/MzAzZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL2Nzcy93b3JrZmxvdy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///38\n");

/***/ }),

/***/ 39:
/***/ (function(module, exports) {

eval("module.exports = {\"extension\":{\"project\":\".prj.json\",\"workflow\":\".wf.json\"},\"default_filename\":\"define\",\"submit_script\":\"submit.sh\",\"system_name\":\"swf\",\"node_color\":{\"task\":\"#3B55B3\",\"workflow\":\"#803DB3\",\"for\":\"#247780\",\"while\":\"#247780\",\"condition\":\"violet\",\"if\":\"#5B5B5F\",\"foreach\":\"#247780\",\"parameterStudy\":\"#666622\"},\"box_appearance\":{\"titleHeight\":32,\"titleWidth\":256,\"opacity\":1,\"strokeWidth\":2,\"marginHeight\":12,\"outputTextOffset\":12,\"textHeightScale\":1.2,\"plug_drop_area_scale\":2,\"inputTextNamePosX\":8},\"state_color\":{\"planning\":\"white\",\"running\":\"cyan\",\"rerunning\":\"orange\",\"waiting\":\"yellow\",\"completed\":\"#00ff00\",\"failed\":\"red\"},\"plug_color\":{\"file\":\"#5673BF\",\"files\":\"#5673BF\",\"directory\":\"#5673BF\",\"flow\":\"#338033\",\"elseFlow\":\"#9944bb\"},\"node_icon\":{\"task\":\"/image/img_task.png\",\"workflow\":\"/image/img_workflow.png\",\"for\":\"/image/img_for.png\",\"while\":\"/image/img_while.png\",\"if\":\"/image/img_if.png\",\"foreach\":\"/image/img_foreach.png\",\"parameterStudy\":\"/image/img_parameterStudy.png\"},\"state_icon\":{\"not-started\":\"/image/img_stateQue.png\",\"running\":\"/image/img_statePlay.png\",\"completed\":\"/image/img_stateDone.png\",\"failed\":\"/image/img_error.png\",\"rerunning\":\"orange\",\"waiting\":\"yellow\"},\"reload_project_ms\":2000}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2pzL2NvbmZpZy5qc29uP2E0NGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsa0JBQWtCLGFBQWEsNENBQTRDLDJGQUEyRiwySkFBMkosbUJBQW1CLDJLQUEySyxnQkFBZ0IsaUhBQWlILGVBQWUsK0ZBQStGLGNBQWMseU9BQXlPLGVBQWUsNExBQTRMIiwiZmlsZSI6IjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XCJleHRlbnNpb25cIjp7XCJwcm9qZWN0XCI6XCIucHJqLmpzb25cIixcIndvcmtmbG93XCI6XCIud2YuanNvblwifSxcImRlZmF1bHRfZmlsZW5hbWVcIjpcImRlZmluZVwiLFwic3VibWl0X3NjcmlwdFwiOlwic3VibWl0LnNoXCIsXCJzeXN0ZW1fbmFtZVwiOlwic3dmXCIsXCJub2RlX2NvbG9yXCI6e1widGFza1wiOlwiIzNCNTVCM1wiLFwid29ya2Zsb3dcIjpcIiM4MDNEQjNcIixcImZvclwiOlwiIzI0Nzc4MFwiLFwid2hpbGVcIjpcIiMyNDc3ODBcIixcImNvbmRpdGlvblwiOlwidmlvbGV0XCIsXCJpZlwiOlwiIzVCNUI1RlwiLFwiZm9yZWFjaFwiOlwiIzI0Nzc4MFwiLFwicGFyYW1ldGVyU3R1ZHlcIjpcIiM2NjY2MjJcIn0sXCJib3hfYXBwZWFyYW5jZVwiOntcInRpdGxlSGVpZ2h0XCI6MzIsXCJ0aXRsZVdpZHRoXCI6MjU2LFwib3BhY2l0eVwiOjEsXCJzdHJva2VXaWR0aFwiOjIsXCJtYXJnaW5IZWlnaHRcIjoxMixcIm91dHB1dFRleHRPZmZzZXRcIjoxMixcInRleHRIZWlnaHRTY2FsZVwiOjEuMixcInBsdWdfZHJvcF9hcmVhX3NjYWxlXCI6MixcImlucHV0VGV4dE5hbWVQb3NYXCI6OH0sXCJzdGF0ZV9jb2xvclwiOntcInBsYW5uaW5nXCI6XCJ3aGl0ZVwiLFwicnVubmluZ1wiOlwiY3lhblwiLFwicmVydW5uaW5nXCI6XCJvcmFuZ2VcIixcIndhaXRpbmdcIjpcInllbGxvd1wiLFwiY29tcGxldGVkXCI6XCIjMDBmZjAwXCIsXCJmYWlsZWRcIjpcInJlZFwifSxcInBsdWdfY29sb3JcIjp7XCJmaWxlXCI6XCIjNTY3M0JGXCIsXCJmaWxlc1wiOlwiIzU2NzNCRlwiLFwiZGlyZWN0b3J5XCI6XCIjNTY3M0JGXCIsXCJmbG93XCI6XCIjMzM4MDMzXCIsXCJlbHNlRmxvd1wiOlwiIzk5NDRiYlwifSxcIm5vZGVfaWNvblwiOntcInRhc2tcIjpcIi9pbWFnZS9pbWdfdGFzay5wbmdcIixcIndvcmtmbG93XCI6XCIvaW1hZ2UvaW1nX3dvcmtmbG93LnBuZ1wiLFwiZm9yXCI6XCIvaW1hZ2UvaW1nX2Zvci5wbmdcIixcIndoaWxlXCI6XCIvaW1hZ2UvaW1nX3doaWxlLnBuZ1wiLFwiaWZcIjpcIi9pbWFnZS9pbWdfaWYucG5nXCIsXCJmb3JlYWNoXCI6XCIvaW1hZ2UvaW1nX2ZvcmVhY2gucG5nXCIsXCJwYXJhbWV0ZXJTdHVkeVwiOlwiL2ltYWdlL2ltZ19wYXJhbWV0ZXJTdHVkeS5wbmdcIn0sXCJzdGF0ZV9pY29uXCI6e1wibm90LXN0YXJ0ZWRcIjpcIi9pbWFnZS9pbWdfc3RhdGVRdWUucG5nXCIsXCJydW5uaW5nXCI6XCIvaW1hZ2UvaW1nX3N0YXRlUGxheS5wbmdcIixcImNvbXBsZXRlZFwiOlwiL2ltYWdlL2ltZ19zdGF0ZURvbmUucG5nXCIsXCJmYWlsZWRcIjpcIi9pbWFnZS9pbWdfZXJyb3IucG5nXCIsXCJyZXJ1bm5pbmdcIjpcIm9yYW5nZVwiLFwid2FpdGluZ1wiOlwieWVsbG93XCJ9LFwicmVsb2FkX3Byb2plY3RfbXNcIjoyMDAwfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL3NyYy9qcy9jb25maWcuanNvblxuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39\n");

/***/ }),

/***/ 45:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n* svg.js - A lightweight library for manipulating and animating SVG.\n* @version 2.6.2\n* https://svgdotjs.github.io/\n*\n* @copyright Wout Fierens <wout@mick-wout.com>\n* @license MIT\n*\n* BUILT: Mon Jun 05 2017 11:33:23 GMT+0200 (MitteleuropÃ¤ische Sommerzeit)\n*/;\n(function(root, factory) {\r\n  /* istanbul ignore next */\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){\r\n      return factory(root, root.document)\r\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n  } else if (typeof exports === 'object') {\r\n    module.exports = root.document ? factory(root, root.document) : function(w){ return factory(w, w.document) }\r\n  } else {\r\n    root.SVG = factory(root, root.document)\r\n  }\r\n}(typeof window !== \"undefined\" ? window : this, function(window, document) {\r\n\r\n// The main wrapping element\r\nvar SVG = this.SVG = function(element) {\r\n  if (SVG.supported) {\r\n    element = new SVG.Doc(element)\r\n\r\n    if(!SVG.parser.draw)\r\n      SVG.prepare()\r\n\r\n    return element\r\n  }\r\n}\r\n\r\n// Default namespaces\r\nSVG.ns    = 'http://www.w3.org/2000/svg'\r\nSVG.xmlns = 'http://www.w3.org/2000/xmlns/'\r\nSVG.xlink = 'http://www.w3.org/1999/xlink'\r\nSVG.svgjs = 'http://svgjs.com/svgjs'\r\n\r\n// Svg support test\r\nSVG.supported = (function() {\r\n  return !! document.createElementNS &&\r\n         !! document.createElementNS(SVG.ns,'svg').createSVGRect\r\n})()\r\n\r\n// Don't bother to continue if SVG is not supported\r\nif (!SVG.supported) return false\r\n\r\n// Element id sequence\r\nSVG.did  = 1000\r\n\r\n// Get next named element id\r\nSVG.eid = function(name) {\r\n  return 'Svgjs' + capitalize(name) + (SVG.did++)\r\n}\r\n\r\n// Method for element creation\r\nSVG.create = function(name) {\r\n  // create element\r\n  var element = document.createElementNS(this.ns, name)\r\n\r\n  // apply unique id\r\n  element.setAttribute('id', this.eid(name))\r\n\r\n  return element\r\n}\r\n\r\n// Method for extending objects\r\nSVG.extend = function() {\r\n  var modules, methods, key, i\r\n\r\n  // Get list of modules\r\n  modules = [].slice.call(arguments)\r\n\r\n  // Get object with extensions\r\n  methods = modules.pop()\r\n\r\n  for (i = modules.length - 1; i >= 0; i--)\r\n    if (modules[i])\r\n      for (key in methods)\r\n        modules[i].prototype[key] = methods[key]\r\n\r\n  // Make sure SVG.Set inherits any newly added methods\r\n  if (SVG.Set && SVG.Set.inherit)\r\n    SVG.Set.inherit()\r\n}\r\n\r\n// Invent new element\r\nSVG.invent = function(config) {\r\n  // Create element initializer\r\n  var initializer = typeof config.create == 'function' ?\r\n    config.create :\r\n    function() {\r\n      this.constructor.call(this, SVG.create(config.create))\r\n    }\r\n\r\n  // Inherit prototype\r\n  if (config.inherit)\r\n    initializer.prototype = new config.inherit\r\n\r\n  // Extend with methods\r\n  if (config.extend)\r\n    SVG.extend(initializer, config.extend)\r\n\r\n  // Attach construct method to parent\r\n  if (config.construct)\r\n    SVG.extend(config.parent || SVG.Container, config.construct)\r\n\r\n  return initializer\r\n}\r\n\r\n// Adopt existing svg elements\r\nSVG.adopt = function(node) {\r\n  // check for presence of node\r\n  if (!node) return null\r\n\r\n  // make sure a node isn't already adopted\r\n  if (node.instance) return node.instance\r\n\r\n  // initialize variables\r\n  var element\r\n\r\n  // adopt with element-specific settings\r\n  if (node.nodeName == 'svg')\r\n    element = node.parentNode instanceof window.SVGElement ? new SVG.Nested : new SVG.Doc\r\n  else if (node.nodeName == 'linearGradient')\r\n    element = new SVG.Gradient('linear')\r\n  else if (node.nodeName == 'radialGradient')\r\n    element = new SVG.Gradient('radial')\r\n  else if (SVG[capitalize(node.nodeName)])\r\n    element = new SVG[capitalize(node.nodeName)]\r\n  else\r\n    element = new SVG.Element(node)\r\n\r\n  // ensure references\r\n  element.type  = node.nodeName\r\n  element.node  = node\r\n  node.instance = element\r\n\r\n  // SVG.Class specific preparations\r\n  if (element instanceof SVG.Doc)\r\n    element.namespace().defs()\r\n\r\n  // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\r\n  element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {})\r\n\r\n  return element\r\n}\r\n\r\n// Initialize parsing element\r\nSVG.prepare = function() {\r\n  // Select document body and create invisible svg element\r\n  var body = document.getElementsByTagName('body')[0]\r\n    , draw = (body ? new SVG.Doc(body) : SVG.adopt(document.documentElement).nested()).size(2, 0)\r\n\r\n  // Create parser object\r\n  SVG.parser = {\r\n    body: body || document.documentElement\r\n  , draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').node\r\n  , poly: draw.polyline().node\r\n  , path: draw.path().node\r\n  , native: SVG.create('svg')\r\n  }\r\n}\r\n\r\nSVG.parser = {\r\n  native: SVG.create('svg')\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', function() {\r\n  if(!SVG.parser.draw)\r\n    SVG.prepare()\r\n}, false)\r\n\n// Storage for regular expressions\r\nSVG.regex = {\r\n  // Parse unit value\r\n  numberAndUnit:    /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i\r\n\r\n  // Parse hex value\r\n, hex:              /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i\r\n\r\n  // Parse rgb value\r\n, rgb:              /rgb\\((\\d+),(\\d+),(\\d+)\\)/\r\n\r\n  // Parse reference id\r\n, reference:        /#([a-z0-9\\-_]+)/i\r\n\r\n  // splits a transformation chain\r\n, transforms:       /\\)\\s*,?\\s*/\r\n\r\n  // Whitespace\r\n, whitespace:       /\\s/g\r\n\r\n  // Test hex value\r\n, isHex:            /^#[a-f0-9]{3,6}$/i\r\n\r\n  // Test rgb value\r\n, isRgb:            /^rgb\\(/\r\n\r\n  // Test css declaration\r\n, isCss:            /[^:]+:[^;]+;?/\r\n\r\n  // Test for blank string\r\n, isBlank:          /^(\\s+)?$/\r\n\r\n  // Test for numeric string\r\n, isNumber:         /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i\r\n\r\n  // Test for percent value\r\n, isPercent:        /^-?[\\d\\.]+%$/\r\n\r\n  // Test for image url\r\n, isImage:          /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i\r\n\r\n  // split at whitespace and comma\r\n, delimiter:        /[\\s,]+/\r\n\r\n  // The following regex are used to parse the d attribute of a path\r\n\r\n  // Matches all hyphens which are not after an exponent\r\n, hyphen:           /([^e])\\-/gi\r\n\r\n  // Replaces and tests for all path letters\r\n, pathLetters:      /[MLHVCSQTAZ]/gi\r\n\r\n  // yes we need this one, too\r\n, isPathLetter:     /[MLHVCSQTAZ]/i\r\n\r\n  // matches 0.154.23.45\r\n, numbersWithDots:  /((\\d?\\.\\d+(?:e[+-]?\\d+)?)((?:\\.\\d+(?:e[+-]?\\d+)?)+))+/gi\r\n\r\n  // matches .\r\n, dots:             /\\./g\r\n}\r\n\nSVG.utils = {\r\n  // Map function\r\n  map: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n\r\n    for (i = 0; i < il; i++)\r\n      result.push(block(array[i]))\r\n\r\n    return result\r\n  }\r\n\r\n  // Filter function\r\n, filter: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n\r\n    for (i = 0; i < il; i++)\r\n      if (block(array[i]))\r\n        result.push(array[i])\r\n\r\n    return result\r\n  }\r\n\r\n  // Degrees to radians\r\n, radians: function(d) {\r\n    return d % 360 * Math.PI / 180\r\n  }\r\n\r\n  // Radians to degrees\r\n, degrees: function(r) {\r\n    return r * 180 / Math.PI % 360\r\n  }\r\n\r\n, filterSVGElements: function(nodes) {\r\n    return this.filter( nodes, function(el) { return el instanceof window.SVGElement })\r\n  }\r\n\r\n}\n\r\nSVG.defaults = {\r\n  // Default attribute values\r\n  attrs: {\r\n    // fill and stroke\r\n    'fill-opacity':     1\r\n  , 'stroke-opacity':   1\r\n  , 'stroke-width':     0\r\n  , 'stroke-linejoin':  'miter'\r\n  , 'stroke-linecap':   'butt'\r\n  , fill:               '#000000'\r\n  , stroke:             '#000000'\r\n  , opacity:            1\r\n    // position\r\n  , x:                  0\r\n  , y:                  0\r\n  , cx:                 0\r\n  , cy:                 0\r\n    // size\r\n  , width:              0\r\n  , height:             0\r\n    // radius\r\n  , r:                  0\r\n  , rx:                 0\r\n  , ry:                 0\r\n    // gradient\r\n  , offset:             0\r\n  , 'stop-opacity':     1\r\n  , 'stop-color':       '#000000'\r\n    // text\r\n  , 'font-size':        16\r\n  , 'font-family':      'Helvetica, Arial, sans-serif'\r\n  , 'text-anchor':      'start'\r\n  }\r\n\r\n}\n// Module for color convertions\r\nSVG.Color = function(color) {\r\n  var match\r\n\r\n  // initialize defaults\r\n  this.r = 0\r\n  this.g = 0\r\n  this.b = 0\r\n\r\n  if(!color) return\r\n\r\n  // parse color\r\n  if (typeof color === 'string') {\r\n    if (SVG.regex.isRgb.test(color)) {\r\n      // get rgb values\r\n      match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace,''))\r\n\r\n      // parse numeric values\r\n      this.r = parseInt(match[1])\r\n      this.g = parseInt(match[2])\r\n      this.b = parseInt(match[3])\r\n\r\n    } else if (SVG.regex.isHex.test(color)) {\r\n      // get hex values\r\n      match = SVG.regex.hex.exec(fullHex(color))\r\n\r\n      // parse numeric values\r\n      this.r = parseInt(match[1], 16)\r\n      this.g = parseInt(match[2], 16)\r\n      this.b = parseInt(match[3], 16)\r\n\r\n    }\r\n\r\n  } else if (typeof color === 'object') {\r\n    this.r = color.r\r\n    this.g = color.g\r\n    this.b = color.b\r\n\r\n  }\r\n\r\n}\r\n\r\nSVG.extend(SVG.Color, {\r\n  // Default to hex conversion\r\n  toString: function() {\r\n    return this.toHex()\r\n  }\r\n  // Build hex value\r\n, toHex: function() {\r\n    return '#'\r\n      + compToHex(this.r)\r\n      + compToHex(this.g)\r\n      + compToHex(this.b)\r\n  }\r\n  // Build rgb value\r\n, toRgb: function() {\r\n    return 'rgb(' + [this.r, this.g, this.b].join() + ')'\r\n  }\r\n  // Calculate true brightness\r\n, brightness: function() {\r\n    return (this.r / 255 * 0.30)\r\n         + (this.g / 255 * 0.59)\r\n         + (this.b / 255 * 0.11)\r\n  }\r\n  // Make color morphable\r\n, morph: function(color) {\r\n    this.destination = new SVG.Color(color)\r\n\r\n    return this\r\n  }\r\n  // Get morphed color at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // normalise pos\r\n    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos\r\n\r\n    // generate morphed color\r\n    return new SVG.Color({\r\n      r: ~~(this.r + (this.destination.r - this.r) * pos)\r\n    , g: ~~(this.g + (this.destination.g - this.g) * pos)\r\n    , b: ~~(this.b + (this.destination.b - this.b) * pos)\r\n    })\r\n  }\r\n\r\n})\r\n\r\n// Testers\r\n\r\n// Test if given value is a color string\r\nSVG.Color.test = function(color) {\r\n  color += ''\r\n  return SVG.regex.isHex.test(color)\r\n      || SVG.regex.isRgb.test(color)\r\n}\r\n\r\n// Test if given value is a rgb object\r\nSVG.Color.isRgb = function(color) {\r\n  return color && typeof color.r == 'number'\r\n               && typeof color.g == 'number'\r\n               && typeof color.b == 'number'\r\n}\r\n\r\n// Test if given value is a color\r\nSVG.Color.isColor = function(color) {\r\n  return SVG.Color.isRgb(color) || SVG.Color.test(color)\r\n}\n// Module for array conversion\r\nSVG.Array = function(array, fallback) {\r\n  array = (array || []).valueOf()\r\n\r\n  // if array is empty and fallback is provided, use fallback\r\n  if (array.length == 0 && fallback)\r\n    array = fallback.valueOf()\r\n\r\n  // parse array\r\n  this.value = this.parse(array)\r\n}\r\n\r\nSVG.extend(SVG.Array, {\r\n  // Make array morphable\r\n  morph: function(array) {\r\n    this.destination = this.parse(array)\r\n\r\n    // normalize length of arrays\r\n    if (this.value.length != this.destination.length) {\r\n      var lastValue       = this.value[this.value.length - 1]\r\n        , lastDestination = this.destination[this.destination.length - 1]\r\n\r\n      while(this.value.length > this.destination.length)\r\n        this.destination.push(lastDestination)\r\n      while(this.value.length < this.destination.length)\r\n        this.value.push(lastValue)\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Clean up any duplicate points\r\n, settle: function() {\r\n    // find all unique values\r\n    for (var i = 0, il = this.value.length, seen = []; i < il; i++)\r\n      if (seen.indexOf(this.value[i]) == -1)\r\n        seen.push(this.value[i])\r\n\r\n    // set new value\r\n    return this.value = seen\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed array\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)\r\n\r\n    return new SVG.Array(array)\r\n  }\r\n  // Convert array to string\r\n, toString: function() {\r\n    return this.value.join(' ')\r\n  }\r\n  // Real value\r\n, valueOf: function() {\r\n    return this.value\r\n  }\r\n  // Parse whitespace separated string\r\n, parse: function(array) {\r\n    array = array.valueOf()\r\n\r\n    // if already is an array, no need to parse it\r\n    if (Array.isArray(array)) return array\r\n\r\n    return this.split(array)\r\n  }\r\n  // Strip unnecessary whitespace\r\n, split: function(string) {\r\n    return string.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n  }\r\n  // Reverse array\r\n, reverse: function() {\r\n    this.value.reverse()\r\n\r\n    return this\r\n  }\r\n, clone: function() {\r\n    var clone = new this.constructor()\r\n    clone.value = array_clone(this.value)\r\n    return clone\r\n  }\r\n})\n// Poly points array\r\nSVG.PointArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [[0,0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PointArray.prototype = new SVG.Array\r\nSVG.PointArray.prototype.constructor = SVG.PointArray\r\n\r\nSVG.extend(SVG.PointArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    // convert to a poly point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i].join(','))\r\n\r\n    return array.join(' ')\r\n  }\r\n  // Convert array to line object\r\n, toLine: function() {\r\n    return {\r\n      x1: this.value[0][0]\r\n    , y1: this.value[0][1]\r\n    , x2: this.value[1][0]\r\n    , y2: this.value[1][1]\r\n    }\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push([\r\n        this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos\r\n      , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos\r\n      ])\r\n\r\n    return new SVG.PointArray(array)\r\n  }\r\n  // Parse point string and flat array\r\n, parse: function(array) {\r\n    var points = []\r\n\r\n    array = array.valueOf()\r\n\r\n    // if it is an array\r\n    if (Array.isArray(array)) {\r\n      // and it is not flat, there is no need to parse it\r\n      if(Array.isArray(array[0])) {\r\n        return array\r\n      }\r\n    } else { // Else, it is considered as a string\r\n      // parse points\r\n      array = array.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n    }\r\n\r\n    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\r\n    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\r\n    if (array.length % 2 !== 0) array.pop()\r\n\r\n    // wrap points in two-tuples and parse points as floats\r\n    for(var i = 0, len = array.length; i < len; i = i + 2)\r\n      points.push([ array[i], array[i+1] ])\r\n\r\n    return points\r\n  }\r\n  // Move point string\r\n, move: function(x, y) {\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    // move every point\r\n    if (!isNaN(x) && !isNaN(y))\r\n      for (var i = this.value.length - 1; i >= 0; i--)\r\n        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]\r\n\r\n    return this\r\n  }\r\n  // Resize poly string\r\n, size: function(width, height) {\r\n    var i, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      if(box.width) this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x\r\n      if(box.height) this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get bounding box of points\r\n, bbox: function() {\r\n    SVG.parser.poly.setAttribute('points', this.toString())\r\n\r\n    return SVG.parser.poly.getBBox()\r\n  }\r\n})\r\n\nvar pathHandlers = {\r\n  M: function(c, p, p0) {\r\n    p.x = p0.x = c[0]\r\n    p.y = p0.y = c[1]\r\n\r\n    return ['M', p.x, p.y]\r\n  },\r\n  L: function(c, p) {\r\n    p.x = c[0]\r\n    p.y = c[1]\r\n    return ['L', c[0], c[1]]\r\n  },\r\n  H: function(c, p) {\r\n    p.x = c[0]\r\n    return ['H', c[0]]\r\n  },\r\n  V: function(c, p) {\r\n    p.y = c[0]\r\n    return ['V', c[0]]\r\n  },\r\n  C: function(c, p) {\r\n    p.x = c[4]\r\n    p.y = c[5]\r\n    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]]\r\n  },\r\n  S: function(c, p) {\r\n    p.x = c[2]\r\n    p.y = c[3]\r\n    return ['S', c[0], c[1], c[2], c[3]]\r\n  },\r\n  Q: function(c, p) {\r\n    p.x = c[2]\r\n    p.y = c[3]\r\n    return ['Q', c[0], c[1], c[2], c[3]]\r\n  },\r\n  T: function(c, p) {\r\n    p.x = c[0]\r\n    p.y = c[1]\r\n    return ['T', c[0], c[1]]\r\n  },\r\n  Z: function(c, p, p0) {\r\n    p.x = p0.x\r\n    p.y = p0.y\r\n    return ['Z']\r\n  },\r\n  A: function(c, p) {\r\n    p.x = c[5]\r\n    p.y = c[6]\r\n    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]]\r\n  }\r\n}\r\n\r\nvar mlhvqtcsa = 'mlhvqtcsaz'.split('')\r\n\r\nfor(var i = 0, il = mlhvqtcsa.length; i < il; ++i){\r\n  pathHandlers[mlhvqtcsa[i]] = (function(i){\r\n    return function(c, p, p0) {\r\n      if(i == 'H') c[0] = c[0] + p.x\r\n      else if(i == 'V') c[0] = c[0] + p.y\r\n      else if(i == 'A'){\r\n        c[5] = c[5] + p.x,\r\n        c[6] = c[6] + p.y\r\n      }\r\n      else\r\n        for(var j = 0, jl = c.length; j < jl; ++j) {\r\n          c[j] = c[j] + (j%2 ? p.y : p.x)\r\n        }\r\n\r\n      return pathHandlers[i](c, p, p0)\r\n    }\r\n  })(mlhvqtcsa[i].toUpperCase())\r\n}\r\n\r\n// Path points array\r\nSVG.PathArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [['M', 0, 0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PathArray.prototype = new SVG.Array\r\nSVG.PathArray.prototype.constructor = SVG.PathArray\r\n\r\nSVG.extend(SVG.PathArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    return arrayToString(this.value)\r\n  }\r\n  // Move path string\r\n, move: function(x, y) {\r\n    // get bounding box of current situation\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    if (!isNaN(x) && !isNaN(y)) {\r\n      // move every point\r\n      for (var l, i = this.value.length - 1; i >= 0; i--) {\r\n        l = this.value[i][0]\r\n\r\n        if (l == 'M' || l == 'L' || l == 'T')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n\r\n        } else if (l == 'H')  {\r\n          this.value[i][1] += x\r\n\r\n        } else if (l == 'V')  {\r\n          this.value[i][1] += y\r\n\r\n        } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n          this.value[i][3] += x\r\n          this.value[i][4] += y\r\n\r\n          if (l == 'C')  {\r\n            this.value[i][5] += x\r\n            this.value[i][6] += y\r\n          }\r\n\r\n        } else if (l == 'A')  {\r\n          this.value[i][6] += x\r\n          this.value[i][7] += y\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Resize path string\r\n, size: function(width, height) {\r\n    // get bounding box of current situation\r\n    var i, l, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      l = this.value[i][0]\r\n\r\n      if (l == 'M' || l == 'L' || l == 'T')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'H')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n\r\n      } else if (l == 'V')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n        this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y\r\n\r\n        if (l == 'C')  {\r\n          this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x\r\n          this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y\r\n        }\r\n\r\n      } else if (l == 'A')  {\r\n        // resize radii\r\n        this.value[i][1] = (this.value[i][1] * width)  / box.width\r\n        this.value[i][2] = (this.value[i][2] * height) / box.height\r\n\r\n        // move position values\r\n        this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y\r\n      }\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Test if the passed path array use the same path data commands as this path array\r\n, equalCommands: function(pathArray) {\r\n    var i, il, equalCommands\r\n\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    equalCommands = this.value.length === pathArray.value.length\r\n    for(i = 0, il = this.value.length; equalCommands && i < il; i++) {\r\n      equalCommands = this.value[i][0] === pathArray.value[i][0]\r\n    }\r\n\r\n    return equalCommands\r\n  }\r\n  // Make path array morphable\r\n, morph: function(pathArray) {\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    if(this.equalCommands(pathArray)) {\r\n      this.destination = pathArray\r\n    } else {\r\n      this.destination = null\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get morphed path array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    var sourceArray = this.value\r\n      , destinationArray = this.destination.value\r\n      , array = [], pathArray = new SVG.PathArray()\r\n      , i, il, j, jl\r\n\r\n    // Animate has specified in the SVG spec\r\n    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\r\n    for (i = 0, il = sourceArray.length; i < il; i++) {\r\n      array[i] = [sourceArray[i][0]]\r\n      for(j = 1, jl = sourceArray[i].length; j < jl; j++) {\r\n        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos\r\n      }\r\n      // For the two flags of the elliptical arc command, the SVG spec say:\r\n      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\r\n      // Elliptical arc command as an array followed by corresponding indexes:\r\n      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\r\n      //   0    1   2        3                 4             5      6  7\r\n      if(array[i][0] === 'A') {\r\n        array[i][4] = +(array[i][4] != 0)\r\n        array[i][5] = +(array[i][5] != 0)\r\n      }\r\n    }\r\n\r\n    // Directly modify the value of a path array, this is done this way for performance\r\n    pathArray.value = array\r\n    return pathArray\r\n  }\r\n  // Absolutize and parse path to array\r\n, parse: function(array) {\r\n    // if it's already a patharray, no need to parse it\r\n    if (array instanceof SVG.PathArray) return array.valueOf()\r\n\r\n    // prepare for parsing\r\n    var i, x0, y0, s, seg, arr\r\n      , x = 0\r\n      , y = 0\r\n      , paramCnt = { 'M':2, 'L':2, 'H':1, 'V':1, 'C':6, 'S':4, 'Q':4, 'T':2, 'A':7, 'Z':0 }\r\n\r\n    if(typeof array == 'string'){\r\n\r\n      array = array\r\n        .replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\r\n        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\r\n        .replace(SVG.regex.hyphen, '$1 -')      // add space before hyphen\r\n        .trim()                                 // trim\r\n        .split(SVG.regex.delimiter)   // split into array\r\n\r\n    }else{\r\n      array = array.reduce(function(prev, curr){\r\n        return [].concat.call(prev, curr)\r\n      }, [])\r\n    }\r\n\r\n    // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\r\n    var arr = []\r\n      , p = new SVG.Point()\r\n      , p0 = new SVG.Point()\r\n      , index = 0\r\n      , len = array.length\r\n\r\n    do{\r\n      // Test if we have a path letter\r\n      if(SVG.regex.isPathLetter.test(array[index])){\r\n        s = array[index]\r\n        ++index\r\n      // If last letter was a move command and we got no new, it defaults to [L]ine\r\n      }else if(s == 'M'){\r\n        s = 'L'\r\n      }else if(s == 'm'){\r\n        s = 'l'\r\n      }\r\n\r\n      arr.push(pathHandlers[s].call(null,\r\n          array.slice(index, (index = index + paramCnt[s.toUpperCase()])).map(parseFloat),\r\n          p, p0\r\n        )\r\n      )\r\n\r\n    }while(len > index)\r\n\r\n    return arr\r\n\r\n  }\r\n  // Get bounding box of path\r\n, bbox: function() {\r\n    SVG.parser.path.setAttribute('d', this.toString())\r\n\r\n    return SVG.parser.path.getBBox()\r\n  }\r\n\r\n})\r\n\n// Module for unit convertions\r\nSVG.Number = SVG.invent({\r\n  // Initialize\r\n  create: function(value, unit) {\r\n    // initialize defaults\r\n    this.value = 0\r\n    this.unit  = unit || ''\r\n\r\n    // parse value\r\n    if (typeof value === 'number') {\r\n      // ensure a valid numeric value\r\n      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value\r\n\r\n    } else if (typeof value === 'string') {\r\n      unit = value.match(SVG.regex.numberAndUnit)\r\n\r\n      if (unit) {\r\n        // make value numeric\r\n        this.value = parseFloat(unit[1])\r\n\r\n        // normalize\r\n        if (unit[5] == '%')\r\n          this.value /= 100\r\n        else if (unit[5] == 's')\r\n          this.value *= 1000\r\n\r\n        // store unit\r\n        this.unit = unit[5]\r\n      }\r\n\r\n    } else {\r\n      if (value instanceof SVG.Number) {\r\n        this.value = value.valueOf()\r\n        this.unit  = value.unit\r\n      }\r\n    }\r\n\r\n  }\r\n  // Add methods\r\n, extend: {\r\n    // Stringalize\r\n    toString: function() {\r\n      return (\r\n        this.unit == '%' ?\r\n          ~~(this.value * 1e8) / 1e6:\r\n        this.unit == 's' ?\r\n          this.value / 1e3 :\r\n          this.value\r\n      ) + this.unit\r\n    }\r\n  , toJSON: function() {\r\n      return this.toString()\r\n    }\r\n  , // Convert to primitive\r\n    valueOf: function() {\r\n      return this.value\r\n    }\r\n    // Add number\r\n  , plus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this + number, this.unit || number.unit)\r\n    }\r\n    // Subtract number\r\n  , minus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this - number, this.unit || number.unit)\r\n    }\r\n    // Multiply number\r\n  , times: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this * number, this.unit || number.unit)\r\n    }\r\n    // Divide number\r\n  , divide: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this / number, this.unit || number.unit)\r\n    }\r\n    // Convert to different unit\r\n  , to: function(unit) {\r\n      var number = new SVG.Number(this)\r\n\r\n      if (typeof unit === 'string')\r\n        number.unit = unit\r\n\r\n      return number\r\n    }\r\n    // Make number morphable\r\n  , morph: function(number) {\r\n      this.destination = new SVG.Number(number)\r\n\r\n      if(number.relative) {\r\n        this.destination.value += this.value\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Get morphed number at given position\r\n  , at: function(pos) {\r\n      // Make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // Generate new morphed number\r\n      return new SVG.Number(this.destination)\r\n          .minus(this)\r\n          .times(pos)\r\n          .plus(this)\r\n    }\r\n\r\n  }\r\n})\r\n\n\r\nSVG.Element = SVG.invent({\r\n  // Initialize node\r\n  create: function(node) {\r\n    // make stroke value accessible dynamically\r\n    this._stroke = SVG.defaults.attrs.stroke\r\n    this._event = null\r\n\r\n    // initialize data object\r\n    this.dom = {}\r\n\r\n    // create circular reference\r\n    if (this.node = node) {\r\n      this.type = node.nodeName\r\n      this.node.instance = this\r\n\r\n      // store current attribute value\r\n      this._stroke = node.getAttribute('stroke') || this._stroke\r\n    }\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return this.attr('y', y)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)\r\n    }\r\n    // Move element to given x and y values\r\n  , move: function(x, y) {\r\n      return this.x(x).y(y)\r\n    }\r\n    // Move element by its center\r\n  , center: function(x, y) {\r\n      return this.cx(x).cy(y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return this.attr('width', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('height', height)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .width(new SVG.Number(p.width))\r\n        .height(new SVG.Number(p.height))\r\n    }\r\n    // Clone element\r\n  , clone: function(parent, withData) {\r\n      // write dom data to the dom so the clone can pickup the data\r\n      this.writeDataToDom()\r\n\r\n      // clone element and assign new id\r\n      var clone = assignNewId(this.node.cloneNode(true))\r\n\r\n      // insert the clone in the given parent or after myself\r\n      if(parent) parent.add(clone)\r\n      else this.after(clone)\r\n\r\n      return clone\r\n    }\r\n    // Remove element\r\n  , remove: function() {\r\n      if (this.parent())\r\n        this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n    // Replace element\r\n  , replace: function(element) {\r\n      this.after(element).remove()\r\n\r\n      return element\r\n    }\r\n    // Add element to given container and return self\r\n  , addTo: function(parent) {\r\n      return parent.put(this)\r\n    }\r\n    // Add element to given container and return container\r\n  , putIn: function(parent) {\r\n      return parent.add(this)\r\n    }\r\n    // Get / set id\r\n  , id: function(id) {\r\n      return this.attr('id', id)\r\n    }\r\n    // Checks whether the given point inside the bounding box of the element\r\n  , inside: function(x, y) {\r\n      var box = this.bbox()\r\n\r\n      return x > box.x\r\n          && y > box.y\r\n          && x < box.x + box.width\r\n          && y < box.y + box.height\r\n    }\r\n    // Show element\r\n  , show: function() {\r\n      return this.style('display', '')\r\n    }\r\n    // Hide element\r\n  , hide: function() {\r\n      return this.style('display', 'none')\r\n    }\r\n    // Is element visible?\r\n  , visible: function() {\r\n      return this.style('display') != 'none'\r\n    }\r\n    // Return id on string conversion\r\n  , toString: function() {\r\n      return this.attr('id')\r\n    }\r\n    // Return array of classes on the node\r\n  , classes: function() {\r\n      var attr = this.attr('class')\r\n\r\n      return attr == null ? [] : attr.trim().split(SVG.regex.delimiter)\r\n    }\r\n    // Return true if class exists on the node, false otherwise\r\n  , hasClass: function(name) {\r\n      return this.classes().indexOf(name) != -1\r\n    }\r\n    // Add class to the node\r\n  , addClass: function(name) {\r\n      if (!this.hasClass(name)) {\r\n        var array = this.classes()\r\n        array.push(name)\r\n        this.attr('class', array.join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Remove class from the node\r\n  , removeClass: function(name) {\r\n      if (this.hasClass(name)) {\r\n        this.attr('class', this.classes().filter(function(c) {\r\n          return c != name\r\n        }).join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Toggle the presence of a class on the node\r\n  , toggleClass: function(name) {\r\n      return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)\r\n    }\r\n    // Get referenced element form attribute value\r\n  , reference: function(attr) {\r\n      return SVG.get(this.attr(attr))\r\n    }\r\n    // Returns the parent element instance\r\n  , parent: function(type) {\r\n      var parent = this\r\n\r\n      // check for parent\r\n      if(!parent.node.parentNode) return null\r\n\r\n      // get parent element\r\n      parent = SVG.adopt(parent.node.parentNode)\r\n\r\n      if(!type) return parent\r\n\r\n      // loop trough ancestors if type is given\r\n      while(parent && parent.node instanceof window.SVGElement){\r\n        if(typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent\r\n        parent = SVG.adopt(parent.node.parentNode)\r\n      }\r\n    }\r\n    // Get parent document\r\n  , doc: function() {\r\n      return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)\r\n    }\r\n    // return array of all ancestors of given type up to the root svg\r\n  , parents: function(type) {\r\n      var parents = [], parent = this\r\n\r\n      do{\r\n        parent = parent.parent(type)\r\n        if(!parent || !parent.node) break\r\n\r\n        parents.push(parent)\r\n      } while(parent.parent)\r\n\r\n      return parents\r\n    }\r\n    // matches the element vs a css selector\r\n  , matches: function(selector){\r\n      return matches(this.node, selector)\r\n    }\r\n    // Returns the svg node to call native svg methods on it\r\n  , native: function() {\r\n      return this.node\r\n    }\r\n    // Import raw svg\r\n  , svg: function(svg) {\r\n      // create temporary holder\r\n      var well = document.createElement('svg')\r\n\r\n      // act as a setter if svg is given\r\n      if (svg && this instanceof SVG.Parent) {\r\n        // dump raw svg\r\n        well.innerHTML = '<svg>' + svg.replace(/\\n/, '').replace(/<(\\w+)([^<]+?)\\/>/g, '<$1$2></$1>') + '</svg>'\r\n\r\n        // transplant nodes\r\n        for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)\r\n          this.node.appendChild(well.firstChild.firstChild)\r\n\r\n      // otherwise act as a getter\r\n      } else {\r\n        // create a wrapping svg element in case of partial content\r\n        well.appendChild(svg = document.createElement('svg'))\r\n\r\n        // write svgjs data to the dom\r\n        this.writeDataToDom()\r\n\r\n        // insert a copy of this node\r\n        svg.appendChild(this.node.cloneNode(true))\r\n\r\n        // return target element\r\n        return well.innerHTML.replace(/^<svg>/, '').replace(/<\\/svg>$/, '')\r\n      }\r\n\r\n      return this\r\n    }\r\n  // write svgjs data to the dom\r\n  , writeDataToDom: function() {\r\n\r\n      // dump variables recursively\r\n      if(this.each || this.lines){\r\n        var fn = this.each ? this : this.lines();\r\n        fn.each(function(){\r\n          this.writeDataToDom()\r\n        })\r\n      }\r\n\r\n      // remove previously set data\r\n      this.node.removeAttribute('svgjs:data')\r\n\r\n      if(Object.keys(this.dom).length)\r\n        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)) // see #428\r\n\r\n      return this\r\n    }\r\n  // set given data to the elements data property\r\n  , setData: function(o){\r\n      this.dom = o\r\n      return this\r\n    }\r\n  , is: function(obj){\r\n      return is(this, obj)\r\n    }\r\n  }\r\n})\r\n\nSVG.easing = {\r\n  '-': function(pos){return pos}\r\n, '<>':function(pos){return -Math.cos(pos * Math.PI) / 2 + 0.5}\r\n, '>': function(pos){return  Math.sin(pos * Math.PI / 2)}\r\n, '<': function(pos){return -Math.cos(pos * Math.PI / 2) + 1}\r\n}\r\n\r\nSVG.morph = function(pos){\r\n  return function(from, to) {\r\n    return new SVG.MorphObj(from, to).at(pos)\r\n  }\r\n}\r\n\r\nSVG.Situation = SVG.invent({\r\n\r\n  create: function(o){\r\n    this.init = false\r\n    this.reversed = false\r\n    this.reversing = false\r\n\r\n    this.duration = new SVG.Number(o.duration).valueOf()\r\n    this.delay = new SVG.Number(o.delay).valueOf()\r\n\r\n    this.start = +new Date() + this.delay\r\n    this.finish = this.start + this.duration\r\n    this.ease = o.ease\r\n\r\n    // this.loop is incremented from 0 to this.loops\r\n    // it is also incremented when in an infinite loop (when this.loops is true)\r\n    this.loop = 0\r\n    this.loops = false\r\n\r\n    this.animations = {\r\n      // functionToCall: [list of morphable objects]\r\n      // e.g. move: [SVG.Number, SVG.Number]\r\n    }\r\n\r\n    this.attrs = {\r\n      // holds all attributes which are not represented from a function svg.js provides\r\n      // e.g. someAttr: SVG.Number\r\n    }\r\n\r\n    this.styles = {\r\n      // holds all styles which should be animated\r\n      // e.g. fill-color: SVG.Color\r\n    }\r\n\r\n    this.transforms = [\r\n      // holds all transformations as transformation objects\r\n      // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\r\n    ]\r\n\r\n    this.once = {\r\n      // functions to fire at a specific position\r\n      // e.g. \"0.5\": function foo(){}\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\n\r\nSVG.FX = SVG.invent({\r\n\r\n  create: function(element) {\r\n    this._target = element\r\n    this.situations = []\r\n    this.active = false\r\n    this.situation = null\r\n    this.paused = false\r\n    this.lastPos = 0\r\n    this.pos = 0\r\n    // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\r\n    // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\r\n    this.absPos = 0\r\n    this._speed = 1\r\n  }\r\n\r\n, extend: {\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\r\n     * @param ease function || string Function which should be used for easing or easing keyword\r\n     * @param delay Number indicating the delay before the animation starts\r\n     * @return target || this\r\n     */\r\n    animate: function(o, ease, delay){\r\n\r\n      if(typeof o == 'object'){\r\n        ease = o.ease\r\n        delay = o.delay\r\n        o = o.duration\r\n      }\r\n\r\n      var situation = new SVG.Situation({\r\n        duration: o || 1000,\r\n        delay: delay || 0,\r\n        ease: SVG.easing[ease || '-'] || ease\r\n      })\r\n\r\n      this.queue(situation)\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * sets a delay before the next element of the queue is called\r\n     * @param delay Duration of delay in milliseconds\r\n     * @return this.target()\r\n     */\r\n  , delay: function(delay){\r\n      // The delay is performed by an empty situation with its duration\r\n      // attribute set to the duration of the delay\r\n      var situation = new SVG.Situation({\r\n        duration: delay,\r\n        delay: 0,\r\n        ease: SVG.easing['-']\r\n      })\r\n\r\n      return this.queue(situation)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param null || target SVG.Element which should be set as new target\r\n     * @return target || this\r\n     */\r\n  , target: function(target){\r\n      if(target && target instanceof SVG.Element){\r\n        this._target = target\r\n        return this\r\n      }\r\n\r\n      return this._target\r\n    }\r\n\r\n    // returns the absolute position at a given time\r\n  , timeToAbsPos: function(timestamp){\r\n      return (timestamp - this.situation.start) / (this.situation.duration/this._speed)\r\n    }\r\n\r\n    // returns the timestamp from a given absolute positon\r\n  , absPosToTime: function(absPos){\r\n      return this.situation.duration/this._speed * absPos + this.situation.start\r\n    }\r\n\r\n    // starts the animationloop\r\n  , startAnimFrame: function(){\r\n      this.stopAnimFrame()\r\n      this.animationFrame = window.requestAnimationFrame(function(){ this.step() }.bind(this))\r\n    }\r\n\r\n    // cancels the animationframe\r\n  , stopAnimFrame: function(){\r\n      window.cancelAnimationFrame(this.animationFrame)\r\n    }\r\n\r\n    // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\r\n  , start: function(){\r\n      // dont start if already started\r\n      if(!this.active && this.situation){\r\n        this.active = true\r\n        this.startCurrent()\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // start the current situation\r\n  , startCurrent: function(){\r\n      this.situation.start = +new Date + this.situation.delay/this._speed\r\n      this.situation.finish = this.situation.start + this.situation.duration/this._speed\r\n      return this.initAnimations().step()\r\n    }\r\n\r\n    /**\r\n     * adds a function / Situation to the animation queue\r\n     * @param fn function / situation to add\r\n     * @return this\r\n     */\r\n  , queue: function(fn){\r\n      if(typeof fn == 'function' || fn instanceof SVG.Situation)\r\n        this.situations.push(fn)\r\n\r\n      if(!this.situation) this.situation = this.situations.shift()\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * pulls next element from the queue and execute it\r\n     * @return this\r\n     */\r\n  , dequeue: function(){\r\n      // stop current animation\r\n      this.stop()\r\n\r\n      // get next animation from queue\r\n      this.situation = this.situations.shift()\r\n\r\n      if(this.situation){\r\n        if(this.situation instanceof SVG.Situation) {\r\n          this.start()\r\n        } else {\r\n          // If it is not a SVG.Situation, then it is a function, we execute it\r\n          this.situation.call(this)\r\n        }\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // updates all animations to the current state of the element\r\n    // this is important when one property could be changed from another property\r\n  , initAnimations: function() {\r\n      var i, j, source\r\n      var s = this.situation\r\n\r\n      if(s.init) return this\r\n\r\n      for(i in s.animations){\r\n        source = this.target()[i]()\r\n\r\n        if(!Array.isArray(source)) {\r\n          source = [source]\r\n        }\r\n\r\n        if(!Array.isArray(s.animations[i])) {\r\n          s.animations[i] = [s.animations[i]]\r\n        }\r\n\r\n        //if(s.animations[i].length > source.length) {\r\n        //  source.concat = source.concat(s.animations[i].slice(source.length, s.animations[i].length))\r\n        //}\r\n\r\n        for(j = source.length; j--;) {\r\n          // The condition is because some methods return a normal number instead\r\n          // of a SVG.Number\r\n          if(s.animations[i][j] instanceof SVG.Number)\r\n            source[j] = new SVG.Number(source[j])\r\n\r\n          s.animations[i][j] = source[j].morph(s.animations[i][j])\r\n        }\r\n      }\r\n\r\n      for(i in s.attrs){\r\n        s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i])\r\n      }\r\n\r\n      for(i in s.styles){\r\n        s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i])\r\n      }\r\n\r\n      s.initialTransformation = this.target().matrixify()\r\n\r\n      s.init = true\r\n      return this\r\n    }\r\n  , clearQueue: function(){\r\n      this.situations = []\r\n      return this\r\n    }\r\n  , clearCurrent: function(){\r\n      this.situation = null\r\n      return this\r\n    }\r\n    /** stops the animation immediately\r\n     * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\r\n     * @param clearQueue A Boolean indicating whether to remove queued animation as well.\r\n     * @return this\r\n     */\r\n  , stop: function(jumpToEnd, clearQueue){\r\n      var active = this.active\r\n      this.active = false\r\n\r\n      if(clearQueue){\r\n        this.clearQueue()\r\n      }\r\n\r\n      if(jumpToEnd && this.situation){\r\n        // initialize the situation if it was not\r\n        !active && this.startCurrent()\r\n        this.atEnd()\r\n      }\r\n\r\n      this.stopAnimFrame()\r\n\r\n      return this.clearCurrent()\r\n    }\r\n\r\n    /** resets the element to the state where the current element has started\r\n     * @return this\r\n     */\r\n  , reset: function(){\r\n      if(this.situation){\r\n        var temp = this.situation\r\n        this.stop()\r\n        this.situation = temp\r\n        this.atStart()\r\n      }\r\n      return this\r\n    }\r\n\r\n    // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.\r\n  , finish: function(){\r\n\r\n      this.stop(true, false)\r\n\r\n      while(this.dequeue().situation && this.stop(true, false));\r\n\r\n      this.clearQueue().clearCurrent()\r\n\r\n      return this\r\n    }\r\n\r\n    // set the internal animation pointer at the start position, before any loops, and updates the visualisation\r\n  , atStart: function() {\r\n      return this.at(0, true)\r\n    }\r\n\r\n    // set the internal animation pointer at the end position, after all the loops, and updates the visualisation\r\n  , atEnd: function() {\r\n      if (this.situation.loops === true) {\r\n        // If in a infinite loop, we end the current iteration\r\n        this.situation.loops = this.situation.loop + 1\r\n      }\r\n\r\n      if(typeof this.situation.loops == 'number') {\r\n        // If performing a finite number of loops, we go after all the loops\r\n        return this.at(this.situation.loops, true)\r\n      } else {\r\n        // If no loops, we just go at the end\r\n        return this.at(1, true)\r\n      }\r\n    }\r\n\r\n    // set the internal animation pointer to the specified position and updates the visualisation\r\n    // if isAbsPos is true, pos is treated as an absolute position\r\n  , at: function(pos, isAbsPos){\r\n      var durDivSpd = this.situation.duration/this._speed\r\n\r\n      this.absPos = pos\r\n      // If pos is not an absolute position, we convert it into one\r\n      if (!isAbsPos) {\r\n        if (this.situation.reversed) this.absPos = 1 - this.absPos\r\n        this.absPos += this.situation.loop\r\n      }\r\n\r\n      this.situation.start = +new Date - this.absPos * durDivSpd\r\n      this.situation.finish = this.situation.start + durDivSpd\r\n\r\n      return this.step(true)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the speed of the animations\r\n     * @param speed null || Number The new speed of the animations\r\n     * @return Number || this\r\n     */\r\n  , speed: function(speed){\r\n      if (speed === 0) return this.pause()\r\n\r\n      if (speed) {\r\n        this._speed = speed\r\n        // We use an absolute position here so that speed can affect the delay before the animation\r\n        return this.at(this.absPos, true)\r\n      } else return this._speed\r\n    }\r\n\r\n    // Make loopable\r\n  , loop: function(times, reverse) {\r\n      var c = this.last()\r\n\r\n      // store total loops\r\n      c.loops = (times != null) ? times : true\r\n      c.loop = 0\r\n\r\n      if(reverse) c.reversing = true\r\n      return this\r\n    }\r\n\r\n    // pauses the animation\r\n  , pause: function(){\r\n      this.paused = true\r\n      this.stopAnimFrame()\r\n\r\n      return this\r\n    }\r\n\r\n    // unpause the animation\r\n  , play: function(){\r\n      if(!this.paused) return this\r\n      this.paused = false\r\n      // We use an absolute position here so that the delay before the animation can be paused\r\n      return this.at(this.absPos, true)\r\n    }\r\n\r\n    /**\r\n     * toggle or set the direction of the animation\r\n     * true sets direction to backwards while false sets it to forwards\r\n     * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)\r\n     * @return this\r\n     */\r\n  , reverse: function(reversed){\r\n      var c = this.last()\r\n\r\n      if(typeof reversed == 'undefined') c.reversed = !c.reversed\r\n      else c.reversed = reversed\r\n\r\n      return this\r\n    }\r\n\r\n\r\n    /**\r\n     * returns a float from 0-1 indicating the progress of the current animation\r\n     * @param eased Boolean indicating whether the returned position should be eased or not\r\n     * @return number\r\n     */\r\n  , progress: function(easeIt){\r\n      return easeIt ? this.situation.ease(this.pos) : this.pos\r\n    }\r\n\r\n    /**\r\n     * adds a callback function which is called when the current animation is finished\r\n     * @param fn Function which should be executed as callback\r\n     * @return number\r\n     */\r\n  , after: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function wrapper(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, c)\r\n              this.off('finished.fx', wrapper) // prevent memory leak\r\n            }\r\n          }\r\n\r\n      this.target().on('finished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // adds a callback which is called whenever one animation step is performed\r\n  , during: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c)\r\n            }\r\n          }\r\n\r\n      // see above\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.after(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls after ALL animations in the queue are finished\r\n  , afterAll: function(fn){\r\n      var wrapper = function wrapper(e){\r\n            fn.call(this)\r\n            this.off('allfinished.fx', wrapper)\r\n          }\r\n\r\n      // see above\r\n      this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls on every animation step for all animations\r\n  , duringAll: function(fn){\r\n      var wrapper = function(e){\r\n            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation)\r\n          }\r\n\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.afterAll(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n  , last: function(){\r\n      return this.situations.length ? this.situations[this.situations.length-1] : this.situation\r\n    }\r\n\r\n    // adds one property to the animations\r\n  , add: function(method, args, type){\r\n      this.last()[type || 'animations'][method] = args\r\n      return this._callStart()\r\n    }\r\n\r\n    /** perform one step of the animation\r\n     *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\r\n     *  @return this\r\n     */\r\n  , step: function(ignoreTime){\r\n\r\n      // convert current time to an absolute position\r\n      if(!ignoreTime) this.absPos = this.timeToAbsPos(+new Date)\r\n\r\n      // This part convert an absolute position to a position\r\n      if(this.situation.loops !== false) {\r\n        var absPos, absPosInt, lastLoop\r\n\r\n        // If the absolute position is below 0, we just treat it as if it was 0\r\n        absPos = Math.max(this.absPos, 0)\r\n        absPosInt = Math.floor(absPos)\r\n\r\n        if(this.situation.loops === true || absPosInt < this.situation.loops) {\r\n          this.pos = absPos - absPosInt\r\n          lastLoop = this.situation.loop\r\n          this.situation.loop = absPosInt\r\n        } else {\r\n          this.absPos = this.situation.loops\r\n          this.pos = 1\r\n          // The -1 here is because we don't want to toggle reversed when all the loops have been completed\r\n          lastLoop = this.situation.loop - 1\r\n          this.situation.loop = this.situation.loops\r\n        }\r\n\r\n        if(this.situation.reversing) {\r\n          // Toggle reversed if an odd number of loops as occured since the last call of step\r\n          this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2)\r\n        }\r\n\r\n      } else {\r\n        // If there are no loop, the absolute position must not be above 1\r\n        this.absPos = Math.min(this.absPos, 1)\r\n        this.pos = this.absPos\r\n      }\r\n\r\n      // while the absolute position can be below 0, the position must not be below 0\r\n      if(this.pos < 0) this.pos = 0\r\n\r\n      if(this.situation.reversed) this.pos = 1 - this.pos\r\n\r\n\r\n      // apply easing\r\n      var eased = this.situation.ease(this.pos)\r\n\r\n      // call once-callbacks\r\n      for(var i in this.situation.once){\r\n        if(i > this.lastPos && i <= eased){\r\n          this.situation.once[i].call(this.target(), this.pos, eased)\r\n          delete this.situation.once[i]\r\n        }\r\n      }\r\n\r\n      // fire during callback with position, eased position and current situation as parameter\r\n      if(this.active) this.target().fire('during', {pos: this.pos, eased: eased, fx: this, situation: this.situation})\r\n\r\n      // the user may call stop or finish in the during callback\r\n      // so make sure that we still have a valid situation\r\n      if(!this.situation){\r\n        return this\r\n      }\r\n\r\n      // apply the actual animation to every property\r\n      this.eachAt()\r\n\r\n      // do final code when situation is finished\r\n      if((this.pos == 1 && !this.situation.reversed) || (this.situation.reversed && this.pos == 0)){\r\n\r\n        // stop animation callback\r\n        this.stopAnimFrame()\r\n\r\n        // fire finished callback with current situation as parameter\r\n        this.target().fire('finished', {fx:this, situation: this.situation})\r\n\r\n        if(!this.situations.length){\r\n          this.target().fire('allfinished')\r\n\r\n          // Recheck the length since the user may call animate in the afterAll callback\r\n          if(!this.situations.length){\r\n            this.target().off('.fx') // there shouldnt be any binding left, but to make sure...\r\n            this.active = false\r\n          }\r\n        }\r\n\r\n        // start next animation\r\n        if(this.active) this.dequeue()\r\n        else this.clearCurrent()\r\n\r\n      }else if(!this.paused && this.active){\r\n        // we continue animating when we are not at the end\r\n        this.startAnimFrame()\r\n      }\r\n\r\n      // save last eased position for once callback triggering\r\n      this.lastPos = eased\r\n      return this\r\n\r\n    }\r\n\r\n    // calculates the step for every property and calls block with it\r\n  , eachAt: function(){\r\n      var i, len, at, self = this, target = this.target(), s = this.situation\r\n\r\n      // apply animations which can be called trough a method\r\n      for(i in s.animations){\r\n\r\n        at = [].concat(s.animations[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target[i].apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with attr()\r\n      for(i in s.attrs){\r\n\r\n        at = [i].concat(s.attrs[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.attr.apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with style()\r\n      for(i in s.styles){\r\n\r\n        at = [i].concat(s.styles[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.style.apply(target, at)\r\n\r\n      }\r\n\r\n      // animate initialTransformation which has to be chained\r\n      if(s.transforms.length){\r\n\r\n        // get initial initialTransformation\r\n        at = s.initialTransformation\r\n        for(i = 0, len = s.transforms.length; i < len; i++){\r\n\r\n          // get next transformation in chain\r\n          var a = s.transforms[i]\r\n\r\n          // multiply matrix directly\r\n          if(a instanceof SVG.Matrix){\r\n\r\n            if(a.relative){\r\n              at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)))\r\n            }else{\r\n              at = at.morph(a).at(s.ease(this.pos))\r\n            }\r\n            continue\r\n          }\r\n\r\n          // when transformation is absolute we have to reset the needed transformation first\r\n          if(!a.relative)\r\n            a.undo(at.extract())\r\n\r\n          // and reapply it after\r\n          at = at.multiply(a.at(s.ease(this.pos)))\r\n\r\n        }\r\n\r\n        // set new matrix on element\r\n        target.matrix(at)\r\n      }\r\n\r\n      return this\r\n\r\n    }\r\n\r\n\r\n    // adds an once-callback which is called at a specific position and never again\r\n  , once: function(pos, fn, isEased){\r\n      var c = this.last()\r\n      if(!isEased) pos = c.ease(pos)\r\n\r\n      c.once[pos] = fn\r\n\r\n      return this\r\n    }\r\n\r\n  , _callStart: function() {\r\n      setTimeout(function(){this.start()}.bind(this), 0)\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n, parent: SVG.Element\r\n\r\n  // Add method to parent elements\r\n, construct: {\r\n    // Get fx module or create a new one, then animate with given duration and ease\r\n    animate: function(o, ease, delay) {\r\n      return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay)\r\n    }\r\n  , delay: function(delay){\r\n      return (this.fx || (this.fx = new SVG.FX(this))).delay(delay)\r\n    }\r\n  , stop: function(jumpToEnd, clearQueue) {\r\n      if (this.fx)\r\n        this.fx.stop(jumpToEnd, clearQueue)\r\n\r\n      return this\r\n    }\r\n  , finish: function() {\r\n      if (this.fx)\r\n        this.fx.finish()\r\n\r\n      return this\r\n    }\r\n    // Pause current animation\r\n  , pause: function() {\r\n      if (this.fx)\r\n        this.fx.pause()\r\n\r\n      return this\r\n    }\r\n    // Play paused current animation\r\n  , play: function() {\r\n      if (this.fx)\r\n        this.fx.play()\r\n\r\n      return this\r\n    }\r\n    // Set/Get the speed of the animations\r\n  , speed: function(speed) {\r\n      if (this.fx)\r\n        if (speed == null)\r\n          return this.fx.speed()\r\n        else\r\n          this.fx.speed(speed)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\n// MorphObj is used whenever no morphable object is given\r\nSVG.MorphObj = SVG.invent({\r\n\r\n  create: function(from, to){\r\n    // prepare color for morphing\r\n    if(SVG.Color.isColor(to)) return new SVG.Color(from).morph(to)\r\n    // prepare number for morphing\r\n    if(SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to)\r\n\r\n    // prepare for plain morphing\r\n    this.value = from\r\n    this.destination = to\r\n  }\r\n\r\n, extend: {\r\n    at: function(pos, real){\r\n      return real < 1 ? this.value : this.destination\r\n    },\r\n\r\n    valueOf: function(){\r\n      return this.value\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  // Add animatable attributes\r\n  attr: function(a, v, relative) {\r\n    // apply attributes individually\r\n    if (typeof a == 'object') {\r\n      for (var key in a)\r\n        this.attr(key, a[key])\r\n\r\n    } else {\r\n      this.add(a, v, 'attrs')\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable styles\r\n, style: function(s, v) {\r\n    if (typeof s == 'object')\r\n      for (var key in s)\r\n        this.style(key, s[key])\r\n\r\n    else\r\n      this.add(s, v, 'styles')\r\n\r\n    return this\r\n  }\r\n  // Animatable x-axis\r\n, x: function(x, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({x:x}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(x)\r\n    num.relative = relative\r\n    return this.add('x', num)\r\n  }\r\n  // Animatable y-axis\r\n, y: function(y, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({y:y}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(y)\r\n    num.relative = relative\r\n    return this.add('y', num)\r\n  }\r\n  // Animatable center x-axis\r\n, cx: function(x) {\r\n    return this.add('cx', new SVG.Number(x))\r\n  }\r\n  // Animatable center y-axis\r\n, cy: function(y) {\r\n    return this.add('cy', new SVG.Number(y))\r\n  }\r\n  // Add animatable move\r\n, move: function(x, y) {\r\n    return this.x(x).y(y)\r\n  }\r\n  // Add animatable center\r\n, center: function(x, y) {\r\n    return this.cx(x).cy(y)\r\n  }\r\n  // Add animatable size\r\n, size: function(width, height) {\r\n    if (this.target() instanceof SVG.Text) {\r\n      // animate font size for Text elements\r\n      this.attr('font-size', width)\r\n\r\n    } else {\r\n      // animate bbox based size for all other elements\r\n      var box\r\n\r\n      if(!width || !height){\r\n        box = this.target().bbox()\r\n      }\r\n\r\n      if(!width){\r\n        width = box.width / box.height  * height\r\n      }\r\n\r\n      if(!height){\r\n        height = box.height / box.width  * width\r\n      }\r\n\r\n      this.add('width' , new SVG.Number(width))\r\n          .add('height', new SVG.Number(height))\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable width\r\n, width: function(width) {\r\n    return this.add('width', new SVG.Number(width))\r\n  }\r\n  // Add animatable height\r\n, height: function(height) {\r\n    return this.add('height', new SVG.Number(height))\r\n  }\r\n  // Add animatable plot\r\n, plot: function(a, b, c, d) {\r\n    // Lines can be plotted with 4 arguments\r\n    if(arguments.length == 4) {\r\n      return this.plot([a, b, c, d])\r\n    }\r\n\r\n    return this.add('plot', new (this.target().morphArray)(a))\r\n  }\r\n  // Add leading method\r\n, leading: function(value) {\r\n    return this.target().leading ?\r\n      this.add('leading', new SVG.Number(value)) :\r\n      this\r\n  }\r\n  // Add animatable viewbox\r\n, viewbox: function(x, y, width, height) {\r\n    if (this.target() instanceof SVG.Container) {\r\n      this.add('viewbox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n    return this\r\n  }\r\n, update: function(o) {\r\n    if (this.target() instanceof SVG.Stop) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        return this.update({\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        })\r\n      }\r\n\r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', o.offset)\r\n    }\r\n\r\n    return this\r\n  }\r\n})\r\n\nSVG.Box = SVG.invent({\r\n  create: function(x, y, width, height) {\r\n    if (typeof x == 'object' && !(x instanceof SVG.Element)) {\r\n      // chromes getBoundingClientRect has no x and y property\r\n      return SVG.Box.call(this, x.left != null ? x.left : x.x , x.top != null ? x.top : x.y, x.width, x.height)\r\n    } else if (arguments.length == 4) {\r\n      this.x = x\r\n      this.y = y\r\n      this.width = width\r\n      this.height = height\r\n    }\r\n\r\n    // add center, right, bottom...\r\n    fullBox(this)\r\n  }\r\n, extend: {\r\n    // Merge rect box with another, return a new instance\r\n    merge: function(box) {\r\n      var b = new this.constructor()\r\n\r\n      // merge boxes\r\n      b.x      = Math.min(this.x, box.x)\r\n      b.y      = Math.min(this.y, box.y)\r\n      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x\r\n      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y\r\n\r\n      return fullBox(b)\r\n    }\r\n\r\n  , transform: function(m) {\r\n      var xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, p, bbox\r\n\r\n      var pts = [\r\n        new SVG.Point(this.x, this.y),\r\n        new SVG.Point(this.x2, this.y),\r\n        new SVG.Point(this.x, this.y2),\r\n        new SVG.Point(this.x2, this.y2)\r\n      ]\r\n\r\n      pts.forEach(function(p) {\r\n        p = p.transform(m)\r\n        xMin = Math.min(xMin,p.x)\r\n        xMax = Math.max(xMax,p.x)\r\n        yMin = Math.min(yMin,p.y)\r\n        yMax = Math.max(yMax,p.y)\r\n      })\r\n\r\n      bbox = new this.constructor()\r\n      bbox.x = xMin\r\n      bbox.width = xMax-xMin\r\n      bbox.y = yMin\r\n      bbox.height = yMax-yMin\r\n\r\n      fullBox(bbox)\r\n\r\n      return bbox\r\n    }\r\n  }\r\n})\r\n\r\nSVG.BBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    // get values if element is given\r\n    if (element instanceof SVG.Element) {\r\n      var box\r\n\r\n      // yes this is ugly, but Firefox can be a bitch when it comes to elements that are not yet rendered\r\n      try {\r\n\r\n        if (!document.documentElement.contains){\r\n          // This is IE - it does not support contains() for top-level SVGs\r\n          var topParent = element.node\r\n          while (topParent.parentNode){\r\n            topParent = topParent.parentNode\r\n          }\r\n          if (topParent != document) throw new Exception('Element not in the dom')\r\n        } else {\r\n          // the element is NOT in the dom, throw error\r\n          if(!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')\r\n        }\r\n\r\n        // find native bbox\r\n        box = element.node.getBBox()\r\n      } catch(e) {\r\n        if(element instanceof SVG.Shape){\r\n          var clone = element.clone(SVG.parser.draw.instance).show()\r\n          box = clone.node.getBBox()\r\n          clone.remove()\r\n        }else{\r\n          box = {\r\n            x:      element.node.clientLeft\r\n          , y:      element.node.clientTop\r\n          , width:  element.node.clientWidth\r\n          , height: element.node.clientHeight\r\n          }\r\n        }\r\n      }\r\n\r\n      SVG.Box.call(this, box)\r\n    }\r\n\r\n  }\r\n\r\n  // Define ancestor\r\n, inherit: SVG.Box\r\n\r\n  // Define Parent\r\n, parent: SVG.Element\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get bounding box\r\n    bbox: function() {\r\n      return new SVG.BBox(this)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.BBox.prototype.constructor = SVG.BBox\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  tbox: function(){\r\n    console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.')\r\n    return this.rbox(this.doc())\r\n  }\r\n})\r\n\r\nSVG.RBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    if (element instanceof SVG.Element) {\r\n      SVG.Box.call(this, element.node.getBoundingClientRect())\r\n    }\r\n  }\r\n\r\n, inherit: SVG.Box\r\n\r\n  // define Parent\r\n, parent: SVG.Element\r\n\r\n, extend: {\r\n    addOffset: function() {\r\n      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\r\n      this.x += window.pageXOffset\r\n      this.y += window.pageYOffset\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get rect box\r\n    rbox: function(el) {\r\n      if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse())\r\n      return new SVG.RBox(this).addOffset()\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.RBox.prototype.constructor = SVG.RBox\r\n\nSVG.Matrix = SVG.invent({\r\n  // Initialize\r\n  create: function(source) {\r\n    var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0])\r\n\r\n    // ensure source as object\r\n    source = source instanceof SVG.Element ?\r\n      source.matrixify() :\r\n    typeof source === 'string' ?\r\n      arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) :\r\n    arguments.length == 6 ?\r\n      arrayToMatrix([].slice.call(arguments)) :\r\n    Array.isArray(source) ?\r\n      arrayToMatrix(source) :\r\n    typeof source === 'object' ?\r\n      source : base\r\n\r\n    // merge source\r\n    for (i = abcdef.length - 1; i >= 0; --i)\r\n      this[abcdef[i]] = source[abcdef[i]] != null ?\r\n        source[abcdef[i]] : base[abcdef[i]]\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Extract individual transformations\r\n    extract: function() {\r\n      // find delta transform points\r\n      var px    = deltaTransformPoint(this, 0, 1)\r\n        , py    = deltaTransformPoint(this, 1, 0)\r\n        , skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90\r\n\r\n      return {\r\n        // translation\r\n        x:        this.e\r\n      , y:        this.f\r\n      , transformedX:(this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , transformedY:(this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // skew\r\n      , skewX:    -skewX\r\n      , skewY:    180 / Math.PI * Math.atan2(py.y, py.x)\r\n        // scale\r\n      , scaleX:   Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , scaleY:   Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // rotation\r\n      , rotation: skewX\r\n      , a: this.a\r\n      , b: this.b\r\n      , c: this.c\r\n      , d: this.d\r\n      , e: this.e\r\n      , f: this.f\r\n      , matrix: new SVG.Matrix(this)\r\n      }\r\n    }\r\n    // Clone matrix\r\n  , clone: function() {\r\n      return new SVG.Matrix(this)\r\n    }\r\n    // Morph one matrix into another\r\n  , morph: function(matrix) {\r\n      // store new destination\r\n      this.destination = new SVG.Matrix(matrix)\r\n\r\n      return this\r\n    }\r\n    // Get morphed matrix at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var matrix = new SVG.Matrix({\r\n        a: this.a + (this.destination.a - this.a) * pos\r\n      , b: this.b + (this.destination.b - this.b) * pos\r\n      , c: this.c + (this.destination.c - this.c) * pos\r\n      , d: this.d + (this.destination.d - this.d) * pos\r\n      , e: this.e + (this.destination.e - this.e) * pos\r\n      , f: this.f + (this.destination.f - this.f) * pos\r\n      })\r\n\r\n      return matrix\r\n    }\r\n    // Multiplies by given matrix\r\n  , multiply: function(matrix) {\r\n      return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()))\r\n    }\r\n    // Inverses matrix\r\n  , inverse: function() {\r\n      return new SVG.Matrix(this.native().inverse())\r\n    }\r\n    // Translate matrix\r\n  , translate: function(x, y) {\r\n      return new SVG.Matrix(this.native().translate(x || 0, y || 0))\r\n    }\r\n    // Scale matrix\r\n  , scale: function(x, y, cx, cy) {\r\n      // support uniformal scale\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))\r\n    }\r\n    // Rotate matrix\r\n  , rotate: function(r, cx, cy) {\r\n      // convert degrees to radians\r\n      r = SVG.utils.radians(r)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))\r\n    }\r\n    // Flip matrix on x or y, at a given offset\r\n  , flip: function(a, o) {\r\n      return a == 'x' ?\r\n          this.scale(-1, 1, o, 0) :\r\n        a == 'y' ?\r\n          this.scale(1, -1, 0, o) :\r\n          this.scale(-1, -1, a, o != null ? o : a)\r\n    }\r\n    // Skew\r\n  , skew: function(x, y, cx, cy) {\r\n      // support uniformal skew\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      // convert degrees to radians\r\n      x = SVG.utils.radians(x)\r\n      y = SVG.utils.radians(y)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0))\r\n    }\r\n    // SkewX\r\n  , skewX: function(x, cx, cy) {\r\n      return this.skew(x, 0, cx, cy)\r\n    }\r\n    // SkewY\r\n  , skewY: function(y, cx, cy) {\r\n      return this.skew(0, y, cx, cy)\r\n    }\r\n    // Transform around a center point\r\n  , around: function(cx, cy, matrix) {\r\n      return this\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0))\r\n        .multiply(matrix)\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))\r\n    }\r\n    // Convert to native SVGMatrix\r\n  , native: function() {\r\n      // create new matrix\r\n      var matrix = SVG.parser.native.createSVGMatrix()\r\n\r\n      // update with current values\r\n      for (var i = abcdef.length - 1; i >= 0; i--)\r\n        matrix[abcdef[i]] = this[abcdef[i]]\r\n\r\n      return matrix\r\n    }\r\n    // Convert matrix to string\r\n  , toString: function() {\r\n      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')'\r\n    }\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Element\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Get current matrix\r\n    ctm: function() {\r\n      return new SVG.Matrix(this.node.getCTM())\r\n    },\r\n    // Get current screen matrix\r\n    screenCTM: function() {\r\n      /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\r\n         This is needed because FF does not return the transformation matrix\r\n         for the inner coordinate system when getScreenCTM() is called on nested svgs.\r\n         However all other Browsers do that */\r\n      if(this instanceof SVG.Nested) {\r\n        var rect = this.rect(1,1)\r\n        var m = rect.node.getScreenCTM()\r\n        rect.remove()\r\n        return new SVG.Matrix(m)\r\n      }\r\n      return new SVG.Matrix(this.node.getScreenCTM())\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\nSVG.Point = SVG.invent({\r\n  // Initialize\r\n  create: function(x,y) {\r\n    var i, source, base = {x:0, y:0}\r\n\r\n    // ensure source as object\r\n    source = Array.isArray(x) ?\r\n      {x:x[0], y:x[1]} :\r\n    typeof x === 'object' ?\r\n      {x:x.x, y:x.y} :\r\n    x != null ?\r\n      {x:x, y:(y != null ? y : x)} : base // If y has no value, then x is used has its value\r\n\r\n    // merge source\r\n    this.x = source.x\r\n    this.y = source.y\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Clone point\r\n    clone: function() {\r\n      return new SVG.Point(this)\r\n    }\r\n    // Morph one point into another\r\n  , morph: function(x, y) {\r\n      // store new destination\r\n      this.destination = new SVG.Point(x, y)\r\n\r\n      return this\r\n    }\r\n    // Get morphed point at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var point = new SVG.Point({\r\n        x: this.x + (this.destination.x - this.x) * pos\r\n      , y: this.y + (this.destination.y - this.y) * pos\r\n      })\r\n\r\n      return point\r\n    }\r\n    // Convert to native SVGPoint\r\n  , native: function() {\r\n      // create new point\r\n      var point = SVG.parser.native.createSVGPoint()\r\n\r\n      // update with current values\r\n      point.x = this.x\r\n      point.y = this.y\r\n\r\n      return point\r\n    }\r\n    // transform point with matrix\r\n  , transform: function(matrix) {\r\n      return new SVG.Point(this.native().matrixTransform(matrix.native()))\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n\r\n  // Get point\r\n  point: function(x, y) {\r\n    return new SVG.Point(x,y).transform(this.screenCTM().inverse());\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Element, {\r\n  // Set svg element attribute\r\n  attr: function(a, v, n) {\r\n    // act as full getter\r\n    if (a == null) {\r\n      // get an object of attributes\r\n      a = {}\r\n      v = this.node.attributes\r\n      for (n = v.length - 1; n >= 0; n--)\r\n        a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue\r\n\r\n      return a\r\n\r\n    } else if (typeof a == 'object') {\r\n      // apply every attribute individually if an object is passed\r\n      for (v in a) this.attr(v, a[v])\r\n\r\n    } else if (v === null) {\r\n        // remove value\r\n        this.node.removeAttribute(a)\r\n\r\n    } else if (v == null) {\r\n      // act as a getter if the first and only argument is not an object\r\n      v = this.node.getAttribute(a)\r\n      return v == null ?\r\n        SVG.defaults.attrs[a] :\r\n      SVG.regex.isNumber.test(v) ?\r\n        parseFloat(v) : v\r\n\r\n    } else {\r\n      // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\r\n      if (a == 'stroke-width')\r\n        this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)\r\n      else if (a == 'stroke')\r\n        this._stroke = v\r\n\r\n      // convert image fill and stroke to patterns\r\n      if (a == 'fill' || a == 'stroke') {\r\n        if (SVG.regex.isImage.test(v))\r\n          v = this.doc().defs().image(v, 0, 0)\r\n\r\n        if (v instanceof SVG.Image)\r\n          v = this.doc().defs().pattern(0, 0, function() {\r\n            this.add(v)\r\n          })\r\n      }\r\n\r\n      // ensure correct numeric values (also accepts NaN and Infinity)\r\n      if (typeof v === 'number')\r\n        v = new SVG.Number(v)\r\n\r\n      // ensure full hex color\r\n      else if (SVG.Color.isColor(v))\r\n        v = new SVG.Color(v)\r\n\r\n      // parse array values\r\n      else if (Array.isArray(v))\r\n        v = new SVG.Array(v)\r\n\r\n      // if the passed attribute is leading...\r\n      if (a == 'leading') {\r\n        // ... call the leading method instead\r\n        if (this.leading)\r\n          this.leading(v)\r\n      } else {\r\n        // set given attribute on node\r\n        typeof n === 'string' ?\r\n          this.node.setAttributeNS(n, a, v.toString()) :\r\n          this.node.setAttribute(a, v.toString())\r\n      }\r\n\r\n      // rebuild if required\r\n      if (this.rebuild && (a == 'font-size' || a == 'x'))\r\n        this.rebuild(a, v)\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.extend(SVG.Element, {\r\n  // Add transformations\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this\r\n      , matrix, bbox\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // get current matrix\r\n    matrix = new SVG.Matrix(target)\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.multiply(new SVG.Matrix(o)) :\r\n        // absolute\r\n        new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.rotate(o.rotation, o.cx, o.cy) :\r\n        // absolute\r\n        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      if (!relative) {\r\n        // absolute; multiply inversed values\r\n        var e = matrix.extract()\r\n        o.scaleX = o.scaleX * 1 / e.scaleX\r\n        o.scaleY = o.scaleY * 1 / e.scaleY\r\n      }\r\n\r\n      matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skew != null || o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0\r\n\r\n      if (!relative) {\r\n        // absolute; reset skew values\r\n        var e = matrix.extract()\r\n        matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse())\r\n      }\r\n\r\n      matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      if(o.flip == 'x' || o.flip == 'y') {\r\n        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      } else {\r\n        if(o.offset == null) {\r\n          bbox = target.bbox()\r\n          o.flip = bbox.cx\r\n          o.offset = bbox.cy\r\n        } else {\r\n          o.flip = o.offset\r\n        }\r\n      }\r\n\r\n      matrix = new SVG.Matrix().flip(o.flip, o.offset)\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      if (relative) {\r\n        // relative\r\n        matrix = matrix.translate(o.x, o.y)\r\n      } else {\r\n        // absolute\r\n        if (o.x != null) matrix.e = o.x\r\n        if (o.y != null) matrix.f = o.y\r\n      }\r\n    }\r\n\r\n    return this.attr('transform', matrix)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this.target()\r\n      , matrix, bbox\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = new SVG.Rotate(o.rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skewY != null ? o.skewY : 0\r\n\r\n      matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      if(o.flip == 'x' || o.flip == 'y') {\r\n        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      } else {\r\n        if(o.offset == null) {\r\n          bbox = target.bbox()\r\n          o.flip = bbox.cx\r\n          o.offset = bbox.cy\r\n        } else {\r\n          o.flip = o.offset\r\n        }\r\n      }\r\n\r\n      matrix = new SVG.Matrix().flip(o.flip, o.offset)\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      matrix = new SVG.Translate(o.x, o.y)\r\n    }\r\n\r\n    if(!matrix) return this\r\n\r\n    matrix.relative = relative\r\n\r\n    this.last().transforms.push(matrix)\r\n\r\n    return this._callStart()\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Reset all transformations\r\n  untransform: function() {\r\n    return this.attr('transform', null)\r\n  },\r\n  // merge the whole transformation chain into one matrix and returns it\r\n  matrixify: function() {\r\n\r\n    var matrix = (this.attr('transform') || '')\r\n      // split transformations\r\n      .split(SVG.regex.transforms).slice(0,-1).map(function(str){\r\n        // generate key => value pairs\r\n        var kv = str.trim().split('(')\r\n        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function(str){ return parseFloat(str) })]\r\n      })\r\n      // merge every transformation into one matrix\r\n      .reduce(function(matrix, transform){\r\n\r\n        if(transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))\r\n        return matrix[transform[0]].apply(matrix, transform[1])\r\n\r\n      }, new SVG.Matrix())\r\n\r\n    return matrix\r\n  },\r\n  // add an element to another parent without changing the visual representation on the screen\r\n  toParent: function(parent) {\r\n    if(this == parent) return this\r\n    var ctm = this.screenCTM()\r\n    var pCtm = parent.screenCTM().inverse()\r\n\r\n    this.addTo(parent).untransform().transform(pCtm.multiply(ctm))\r\n\r\n    return this\r\n  },\r\n  // same as above with parent equals root-svg\r\n  toDoc: function() {\r\n    return this.toParent(this.doc())\r\n  }\r\n\r\n})\r\n\r\nSVG.Transformation = SVG.invent({\r\n\r\n  create: function(source, inversed){\r\n\r\n    if(arguments.length > 1 && typeof inversed != 'boolean'){\r\n      return this.constructor.call(this, [].slice.call(arguments))\r\n    }\r\n\r\n    if(Array.isArray(source)){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[i]\r\n      }\r\n    } else if(typeof source == 'object'){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[this.arguments[i]]\r\n      }\r\n    }\r\n\r\n    this.inversed = false\r\n\r\n    if(inversed === true){\r\n      this.inversed = true\r\n    }\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    arguments: []\r\n  , method: ''\r\n\r\n  , at: function(pos){\r\n\r\n      var params = []\r\n\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        params.push(this[this.arguments[i]])\r\n      }\r\n\r\n      var m = this._undo || new SVG.Matrix()\r\n\r\n      m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos)\r\n\r\n      return this.inversed ? m.inverse() : m\r\n\r\n    }\r\n\r\n  , undo: function(o){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]]\r\n      }\r\n\r\n      // The method SVG.Matrix.extract which was used before calling this\r\n      // method to obtain a value for the parameter o doesn't return a cx and\r\n      // a cy so we use the ones that were provided to this object at its creation\r\n      o.cx = this.cx\r\n      o.cy = this.cy\r\n\r\n      this._undo = new SVG[capitalize(this.method)](o, true).at(1)\r\n\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.Translate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['transformedX', 'transformedY']\r\n  , method: 'translate'\r\n  }\r\n\r\n})\r\n\r\nSVG.Rotate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['rotation', 'cx', 'cy']\r\n  , method: 'rotate'\r\n  , at: function(pos){\r\n      var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy)\r\n      return this.inversed ? m.inverse() : m\r\n    }\r\n  , undo: function(o){\r\n      this._undo = o\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Scale = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['scaleX', 'scaleY', 'cx', 'cy']\r\n  , method: 'scale'\r\n  }\r\n\r\n})\r\n\r\nSVG.Skew = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['skewX', 'skewY', 'cx', 'cy']\r\n  , method: 'skew'\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Element, {\r\n  // Dynamic style generator\r\n  style: function(s, v) {\r\n    if (arguments.length == 0) {\r\n      // get full style\r\n      return this.node.style.cssText || ''\r\n\r\n    } else if (arguments.length < 2) {\r\n      // apply every style individually if an object is passed\r\n      if (typeof s == 'object') {\r\n        for (v in s) this.style(v, s[v])\r\n\r\n      } else if (SVG.regex.isCss.test(s)) {\r\n        // parse css string\r\n        s = s.split(/\\s*;\\s*/)\r\n          // filter out suffix ; and stuff like ;;\r\n          .filter(function(e) { return !!e })\r\n          .map(function(e){ return e.split(/\\s*:\\s*/) })\r\n\r\n        // apply every definition individually\r\n        while (v = s.pop()) {\r\n          this.style(v[0], v[1])\r\n        }\r\n      } else {\r\n        // act as a getter if the first and only argument is not an object\r\n        return this.node.style[camelCase(s)]\r\n      }\r\n\r\n    } else {\r\n      this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.Parent = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Returns all child elements\r\n    children: function() {\r\n      return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {\r\n        return SVG.adopt(node)\r\n      })\r\n    }\r\n    // Add given element at a position\r\n  , add: function(element, i) {\r\n      if (i == null)\r\n        this.node.appendChild(element.node)\r\n      else if (element.node != this.node.childNodes[i])\r\n        this.node.insertBefore(element.node, this.node.childNodes[i])\r\n\r\n      return this\r\n    }\r\n    // Basically does the same as `add()` but returns the added element instead\r\n  , put: function(element, i) {\r\n      this.add(element, i)\r\n      return element\r\n    }\r\n    // Checks if the given element is a child\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // Gets index of given element\r\n  , index: function(element) {\r\n      return [].slice.call(this.node.childNodes).indexOf(element.node)\r\n    }\r\n    // Get a element at the given index\r\n  , get: function(i) {\r\n      return SVG.adopt(this.node.childNodes[i])\r\n    }\r\n    // Get first child\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get the last child\r\n  , last: function() {\r\n      return this.get(this.node.childNodes.length - 1)\r\n    }\r\n    // Iterates over all children and invokes a given block\r\n  , each: function(block, deep) {\r\n      var i, il\r\n        , children = this.children()\r\n\r\n      for (i = 0, il = children.length; i < il; i++) {\r\n        if (children[i] instanceof SVG.Element)\r\n          block.apply(children[i], [i, children])\r\n\r\n        if (deep && (children[i] instanceof SVG.Container))\r\n          children[i].each(block, deep)\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Remove a given child\r\n  , removeElement: function(element) {\r\n      this.node.removeChild(element.node)\r\n\r\n      return this\r\n    }\r\n    // Remove all elements in this container\r\n  , clear: function() {\r\n      // remove children\r\n      while(this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // remove defs reference\r\n      delete this._defs\r\n\r\n      return this\r\n    }\r\n  , // Get defs\r\n    defs: function() {\r\n      return this.doc().defs()\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Parent, {\r\n\r\n  ungroup: function(parent, depth) {\r\n    if(depth === 0 || this instanceof SVG.Defs || this.node == SVG.parser.draw) return this\r\n\r\n    parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent))\r\n    depth = depth || Infinity\r\n\r\n    this.each(function(){\r\n      if(this instanceof SVG.Defs) return this\r\n      if(this instanceof SVG.Parent) return this.ungroup(parent, depth-1)\r\n      return this.toParent(parent)\r\n    })\r\n\r\n    this.node.firstChild || this.remove()\r\n\r\n    return this\r\n  },\r\n\r\n  flatten: function(parent, depth) {\r\n    return this.ungroup(parent, depth)\r\n  }\r\n\r\n})\nSVG.Container = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n})\n\r\nSVG.ViewBox = SVG.invent({\r\n\r\n  create: function(source) {\r\n    var i, base = [0, 0, 0, 0]\r\n\r\n    var x, y, width, height, box, view, we, he\r\n      , wm   = 1 // width multiplier\r\n      , hm   = 1 // height multiplier\r\n      , reg  = /[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?/gi\r\n\r\n    if(source instanceof SVG.Element){\r\n\r\n      we = source\r\n      he = source\r\n      view = (source.attr('viewBox') || '').match(reg)\r\n      box = source.bbox\r\n\r\n      // get dimensions of current node\r\n      width  = new SVG.Number(source.width())\r\n      height = new SVG.Number(source.height())\r\n\r\n      // find nearest non-percentual dimensions\r\n      while (width.unit == '%') {\r\n        wm *= width.value\r\n        width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width())\r\n        we = we.parent()\r\n      }\r\n      while (height.unit == '%') {\r\n        hm *= height.value\r\n        height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height())\r\n        he = he.parent()\r\n      }\r\n\r\n      // ensure defaults\r\n      this.x      = 0\r\n      this.y      = 0\r\n      this.width  = width  * wm\r\n      this.height = height * hm\r\n      this.zoom   = 1\r\n\r\n      if (view) {\r\n        // get width and height from viewbox\r\n        x      = parseFloat(view[0])\r\n        y      = parseFloat(view[1])\r\n        width  = parseFloat(view[2])\r\n        height = parseFloat(view[3])\r\n\r\n        // calculate zoom accoring to viewbox\r\n        this.zoom = ((this.width / this.height) > (width / height)) ?\r\n          this.height / height :\r\n          this.width  / width\r\n\r\n        // calculate real pixel dimensions on parent SVG.Doc element\r\n        this.x      = x\r\n        this.y      = y\r\n        this.width  = width\r\n        this.height = height\r\n\r\n      }\r\n\r\n    }else{\r\n\r\n      // ensure source as object\r\n      source = typeof source === 'string' ?\r\n        source.match(reg).map(function(el){ return parseFloat(el) }) :\r\n      Array.isArray(source) ?\r\n        source :\r\n      typeof source == 'object' ?\r\n        [source.x, source.y, source.width, source.height] :\r\n      arguments.length == 4 ?\r\n        [].slice.call(arguments) :\r\n        base\r\n\r\n      this.x = source[0]\r\n      this.y = source[1]\r\n      this.width = source[2]\r\n      this.height = source[3]\r\n    }\r\n\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    toString: function() {\r\n      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height\r\n    }\r\n  , morph: function(x, y, width, height){\r\n      this.destination = new SVG.ViewBox(x, y, width, height)\r\n      return this\r\n    }\r\n\r\n  , at: function(pos) {\r\n\r\n      if(!this.destination) return this\r\n\r\n      return new SVG.ViewBox([\r\n          this.x + (this.destination.x - this.x) * pos\r\n        , this.y + (this.destination.y - this.y) * pos\r\n        , this.width + (this.destination.width - this.width) * pos\r\n        , this.height + (this.destination.height - this.height) * pos\r\n      ])\r\n\r\n    }\r\n\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Container\r\n\r\n  // Add parent method\r\n, construct: {\r\n\r\n    // get/set viewbox\r\n    viewbox: function(x, y, width, height) {\r\n      if (arguments.length == 0)\r\n        // act as a getter if there are no arguments\r\n        return new SVG.ViewBox(this)\r\n\r\n      // otherwise act as a setter\r\n      return this.attr('viewBox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n  }\r\n\r\n})\n// Add events to elements\r\n;[  'click'\r\n  , 'dblclick'\r\n  , 'mousedown'\r\n  , 'mouseup'\r\n  , 'mouseover'\r\n  , 'mouseout'\r\n  , 'mousemove'\r\n  // , 'mouseenter' -> not supported by IE\r\n  // , 'mouseleave' -> not supported by IE\r\n  , 'touchstart'\r\n  , 'touchmove'\r\n  , 'touchleave'\r\n  , 'touchend'\r\n  , 'touchcancel' ].forEach(function(event) {\r\n\r\n  // add event to SVG.Element\r\n  SVG.Element.prototype[event] = function(f) {\r\n    // bind event to element rather than element node\r\n    SVG.on(this.node, event, f)\r\n    return this\r\n  }\r\n})\r\n\r\n// Initialize listeners stack\r\nSVG.listeners = []\r\nSVG.handlerMap = []\r\nSVG.listenerId = 0\r\n\r\n// Add event binder in the SVG namespace\r\nSVG.on = function(node, event, listener, binding, options) {\r\n  // create listener, get object-index\r\n  var l     = listener.bind(binding || node.instance || node)\r\n    , index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1\r\n    , ev    = event.split('.')[0]\r\n    , ns    = event.split('.')[1] || '*'\r\n\r\n\r\n  // ensure valid object\r\n  SVG.listeners[index]         = SVG.listeners[index]         || {}\r\n  SVG.listeners[index][ev]     = SVG.listeners[index][ev]     || {}\r\n  SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {}\r\n\r\n  if(!listener._svgjsListenerId)\r\n    listener._svgjsListenerId = ++SVG.listenerId\r\n\r\n  // reference listener\r\n  SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l\r\n\r\n  // add listener\r\n  node.addEventListener(ev, l, options || false)\r\n}\r\n\r\n// Add event unbinder in the SVG namespace\r\nSVG.off = function(node, event, listener) {\r\n  var index = SVG.handlerMap.indexOf(node)\r\n    , ev    = event && event.split('.')[0]\r\n    , ns    = event && event.split('.')[1]\r\n    , namespace = ''\r\n\r\n  if(index == -1) return\r\n\r\n  if (listener) {\r\n    if(typeof listener == 'function') listener = listener._svgjsListenerId\r\n    if(!listener) return\r\n\r\n    // remove listener reference\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {\r\n      // remove listener\r\n      node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false)\r\n\r\n      delete SVG.listeners[index][ev][ns || '*'][listener]\r\n    }\r\n\r\n  } else if (ns && ev) {\r\n    // remove all listeners for a namespaced event\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {\r\n      for (listener in SVG.listeners[index][ev][ns])\r\n        SVG.off(node, [ev, ns].join('.'), listener)\r\n\r\n      delete SVG.listeners[index][ev][ns]\r\n    }\r\n\r\n  } else if (ns){\r\n    // remove all listeners for a specific namespace\r\n    for(event in SVG.listeners[index]){\r\n        for(namespace in SVG.listeners[index][event]){\r\n            if(ns === namespace){\r\n                SVG.off(node, [event, ns].join('.'))\r\n            }\r\n        }\r\n    }\r\n\r\n  } else if (ev) {\r\n    // remove all listeners for the event\r\n    if (SVG.listeners[index][ev]) {\r\n      for (namespace in SVG.listeners[index][ev])\r\n        SVG.off(node, [ev, namespace].join('.'))\r\n\r\n      delete SVG.listeners[index][ev]\r\n    }\r\n\r\n  } else {\r\n    // remove all listeners on a given node\r\n    for (event in SVG.listeners[index])\r\n      SVG.off(node, event)\r\n\r\n    delete SVG.listeners[index]\r\n    delete SVG.handlerMap[index]\r\n\r\n  }\r\n}\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Bind given event to listener\r\n  on: function(event, listener, binding, options) {\r\n    SVG.on(this.node, event, listener, binding, options)\r\n\r\n    return this\r\n  }\r\n  // Unbind event from listener\r\n, off: function(event, listener) {\r\n    SVG.off(this.node, event, listener)\r\n\r\n    return this\r\n  }\r\n  // Fire given event\r\n, fire: function(event, data) {\r\n\r\n    // Dispatch event\r\n    if(event instanceof window.Event){\r\n        this.node.dispatchEvent(event)\r\n    }else{\r\n        this.node.dispatchEvent(event = new window.CustomEvent(event, {detail:data, cancelable: true}))\r\n    }\r\n\r\n    this._event = event\r\n    return this\r\n  }\r\n, event: function() {\r\n    return this._event\r\n  }\r\n})\r\n\n\r\nSVG.Defs = SVG.invent({\r\n  // Initialize node\r\n  create: 'defs'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n})\nSVG.G = SVG.invent({\r\n  // Initialize node\r\n  create: 'g'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.transform('x') : this.transform({ x: x - this.x() }, true)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.transform('y') : this.transform({ y: y - this.y() }, true)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2)\r\n    }\r\n  , gbox: function() {\r\n\r\n      var bbox  = this.bbox()\r\n        , trans = this.transform()\r\n\r\n      bbox.x  += trans.x\r\n      bbox.x2 += trans.x\r\n      bbox.cx += trans.x\r\n\r\n      bbox.y  += trans.y\r\n      bbox.y2 += trans.y\r\n      bbox.cy += trans.y\r\n\r\n      return bbox\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a group element\r\n    group: function() {\r\n      return this.put(new SVG.G)\r\n    }\r\n  }\r\n})\r\n\n// ### This module adds backward / forward functionality to elements.\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Get all siblings, including myself\r\n  siblings: function() {\r\n    return this.parent().children()\r\n  }\r\n  // Get the curent position siblings\r\n, position: function() {\r\n    return this.parent().index(this)\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, next: function() {\r\n    return this.siblings()[this.position() + 1]\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, previous: function() {\r\n    return this.siblings()[this.position() - 1]\r\n  }\r\n  // Send given element one step forward\r\n, forward: function() {\r\n    var i = this.position() + 1\r\n      , p = this.parent()\r\n\r\n    // move node one step forward\r\n    p.removeElement(this).add(this, i)\r\n\r\n    // make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element one step backward\r\n, backward: function() {\r\n    var i = this.position()\r\n\r\n    if (i > 0)\r\n      this.parent().removeElement(this).add(this, i - 1)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the front\r\n, front: function() {\r\n    var p = this.parent()\r\n\r\n    // Move node forward\r\n    p.node.appendChild(this.node)\r\n\r\n    // Make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the back\r\n, back: function() {\r\n    if (this.position() > 0)\r\n      this.parent().removeElement(this).add(this, 0)\r\n\r\n    return this\r\n  }\r\n  // Inserts a given element before the targeted element\r\n, before: function(element) {\r\n    element.remove()\r\n\r\n    var i = this.position()\r\n\r\n    this.parent().add(element, i)\r\n\r\n    return this\r\n  }\r\n  // Insters a given element after the targeted element\r\n, after: function(element) {\r\n    element.remove()\r\n\r\n    var i = this.position()\r\n\r\n    this.parent().add(element, i + 1)\r\n\r\n    return this\r\n  }\r\n\r\n})\nSVG.Mask = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('mask'))\r\n\r\n    // keep references to masked elements\r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unmask all masked elements and remove itself\r\n    remove: function() {\r\n      // unmask all targets\r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unmask()\r\n      this.targets = []\r\n\r\n      // remove mask from parent\r\n      this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create masking element\r\n    mask: function() {\r\n      return this.defs().put(new SVG.Mask)\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Distribute mask to svg element\r\n  maskWith: function(element) {\r\n    // use given mask or create a new one\r\n    this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element)\r\n\r\n    // store reverence on self in mask\r\n    this.masker.targets.push(this)\r\n\r\n    // apply mask\r\n    return this.attr('mask', 'url(\"#' + this.masker.attr('id') + '\")')\r\n  }\r\n  // Unmask element\r\n, unmask: function() {\r\n    delete this.masker\r\n    return this.attr('mask', null)\r\n  }\r\n\r\n})\r\n\nSVG.ClipPath = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('clipPath'))\r\n\r\n    // keep references to clipped elements\r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unclip all clipped elements and remove itself\r\n    remove: function() {\r\n      // unclip all targets\r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unclip()\r\n      this.targets = []\r\n\r\n      // remove clipPath from parent\r\n      this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create clipping element\r\n    clip: function() {\r\n      return this.defs().put(new SVG.ClipPath)\r\n    }\r\n  }\r\n})\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Distribute clipPath to svg element\r\n  clipWith: function(element) {\r\n    // use given clip or create a new one\r\n    this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element)\r\n\r\n    // store reverence on self in mask\r\n    this.clipper.targets.push(this)\r\n\r\n    // apply mask\r\n    return this.attr('clip-path', 'url(\"#' + this.clipper.attr('id') + '\")')\r\n  }\r\n  // Unclip element\r\n, unclip: function() {\r\n    delete this.clipper\r\n    return this.attr('clip-path', null)\r\n  }\r\n\r\n})\nSVG.Gradient = SVG.invent({\r\n  // Initialize node\r\n  create: function(type) {\r\n    this.constructor.call(this, SVG.create(type + 'Gradient'))\r\n\r\n    // store type\r\n    this.type = type\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add a color stop\r\n    at: function(offset, color, opacity) {\r\n      return this.put(new SVG.Stop).update(offset, color, opacity)\r\n    }\r\n    // Update gradient\r\n  , update: function(block) {\r\n      // remove all stops\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'gradientTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create gradient element in defs\r\n    gradient: function(type, block) {\r\n      return this.defs().gradient(type, block)\r\n    }\r\n  }\r\n})\r\n\r\n// Add animatable methods to both gradient and fx module\r\nSVG.extend(SVG.Gradient, SVG.FX, {\r\n  // From position\r\n  from: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :\r\n      this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })\r\n  }\r\n  // To position\r\n, to: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :\r\n      this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })\r\n  }\r\n})\r\n\r\n// Base gradient generation\r\nSVG.extend(SVG.Defs, {\r\n  // define gradient\r\n  gradient: function(type, block) {\r\n    return this.put(new SVG.Gradient(type)).update(block)\r\n  }\r\n\r\n})\r\n\r\nSVG.Stop = SVG.invent({\r\n  // Initialize node\r\n  create: 'stop'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // add color stops\r\n    update: function(o) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        o = {\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        }\r\n      }\r\n\r\n      // set attributes\r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.Pattern = SVG.invent({\r\n  // Initialize node\r\n  create: 'pattern'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Return the fill id\r\n    fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Update pattern by rebuilding\r\n  , update: function(block) {\r\n      // remove content\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'patternTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create pattern element in defs\r\n    pattern: function(width, height, block) {\r\n      return this.defs().pattern(width, height, block)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Define gradient\r\n  pattern: function(width, height, block) {\r\n    return this.put(new SVG.Pattern).update(block).attr({\r\n      x:            0\r\n    , y:            0\r\n    , width:        width\r\n    , height:       height\r\n    , patternUnits: 'userSpaceOnUse'\r\n    })\r\n  }\r\n\r\n})\nSVG.Doc = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    if (element) {\r\n      // ensure the presence of a dom element\r\n      element = typeof element == 'string' ?\r\n        document.getElementById(element) :\r\n        element\r\n\r\n      // If the target is an svg element, use that element as the main wrapper.\r\n      // This allows svg.js to work with svg documents as well.\r\n      if (element.nodeName == 'svg') {\r\n        this.constructor.call(this, element)\r\n      } else {\r\n        this.constructor.call(this, SVG.create('svg'))\r\n        element.appendChild(this.node)\r\n        this.size('100%', '100%')\r\n      }\r\n\r\n      // set svg element attributes and ensure defs node\r\n      this.namespace().defs()\r\n    }\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add namespaces\r\n    namespace: function() {\r\n      return this\r\n        .attr({ xmlns: SVG.ns, version: '1.1' })\r\n        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)\r\n        .attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns)\r\n    }\r\n    // Creates and returns defs element\r\n  , defs: function() {\r\n      if (!this._defs) {\r\n        var defs\r\n\r\n        // Find or create a defs element in this instance\r\n        if (defs = this.node.getElementsByTagName('defs')[0])\r\n          this._defs = SVG.adopt(defs)\r\n        else\r\n          this._defs = new SVG.Defs\r\n\r\n        // Make sure the defs node is at the end of the stack\r\n        this.node.appendChild(this._defs.node)\r\n      }\r\n\r\n      return this._defs\r\n    }\r\n    // custom parent method\r\n  , parent: function() {\r\n      return this.node.parentNode.nodeName == '#document' ? null : this.node.parentNode\r\n    }\r\n    // Fix for possible sub-pixel offset. See:\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=608812\r\n  , spof: function(spof) {\r\n      var pos = this.node.getScreenCTM()\r\n\r\n      if (pos)\r\n        this\r\n          .style('left', (-pos.e % 1) + 'px')\r\n          .style('top',  (-pos.f % 1) + 'px')\r\n\r\n      return this\r\n    }\r\n\r\n      // Removes the doc from the DOM\r\n  , remove: function() {\r\n      if(this.parent()) {\r\n        this.parent().removeChild(this.node)\r\n      }\r\n\r\n      return this\r\n    }\r\n  , clear: function() {\r\n      // remove children\r\n      while(this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // remove defs reference\r\n      delete this._defs\r\n\r\n      // add back parser\r\n      if(!SVG.parser.draw.parentNode)\r\n        this.node.appendChild(SVG.parser.draw)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.Shape = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n})\n\r\nSVG.Bare = SVG.invent({\r\n  // Initialize\r\n  create: function(element, inherit) {\r\n    // construct element\r\n    this.constructor.call(this, SVG.create(element))\r\n\r\n    // inherit custom methods\r\n    if (inherit)\r\n      for (var method in inherit.prototype)\r\n        if (typeof inherit.prototype[method] === 'function')\r\n          this[method] = inherit.prototype[method]\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Insert some plain text\r\n    words: function(text) {\r\n      // remove contents\r\n      while (this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // create text node\r\n      this.node.appendChild(document.createTextNode(text))\r\n\r\n      return this\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Create an element that is not described by SVG.js\r\n  element: function(element, inherit) {\r\n    return this.put(new SVG.Bare(element, inherit))\r\n  }\r\n})\r\n\nSVG.Symbol = SVG.invent({\r\n  // Initialize node\r\n  create: 'symbol'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n, construct: {\r\n    // create symbol\r\n    symbol: function() {\r\n      return this.put(new SVG.Symbol)\r\n    }\r\n  }\r\n})\r\n\nSVG.Use = SVG.invent({\r\n  // Initialize node\r\n  create: 'use'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Use element as a reference\r\n    element: function(element, file) {\r\n      // Set lined element\r\n      return this.attr('href', (file || '') + '#' + element, SVG.xlink)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a use element\r\n    use: function(element, file) {\r\n      return this.put(new SVG.Use).element(element, file)\r\n    }\r\n  }\r\n})\nSVG.Rect = SVG.invent({\r\n  // Initialize node\r\n  create: 'rect'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a rect element\r\n    rect: function(width, height) {\r\n      return this.put(new SVG.Rect()).size(width, height)\r\n    }\r\n  }\r\n})\nSVG.Circle = SVG.invent({\r\n  // Initialize node\r\n  create: 'circle'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create circle element, based on ellipse\r\n    circle: function(size) {\r\n      return this.put(new SVG.Circle).rx(new SVG.Number(size).divide(2)).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Circle, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('r', rx)\r\n  }\r\n  // Alias radius x value\r\n, ry: function(ry) {\r\n    return this.rx(ry)\r\n  }\r\n})\r\n\r\nSVG.Ellipse = SVG.invent({\r\n  // Initialize node\r\n  create: 'ellipse'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create an ellipse\r\n    ellipse: function(width, height) {\r\n      return this.put(new SVG.Ellipse).size(width, height).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('rx', rx)\r\n  }\r\n  // Radius y value\r\n, ry: function(ry) {\r\n    return this.attr('ry', ry)\r\n  }\r\n})\r\n\r\n// Add common method\r\nSVG.extend(SVG.Circle, SVG.Ellipse, {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.attr('cx') : this.attr('cx', x)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.attr('cy') : this.attr('cy', y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.rx() * 2 : this.rx(new SVG.Number(width).divide(2))\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.ry() * 2 : this.ry(new SVG.Number(height).divide(2))\r\n    }\r\n    // Custom size function\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .rx(new SVG.Number(p.width).divide(2))\r\n        .ry(new SVG.Number(p.height).divide(2))\r\n    }\r\n})\nSVG.Line = SVG.invent({\r\n  // Initialize node\r\n  create: 'line'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Get array\r\n    array: function() {\r\n      return new SVG.PointArray([\r\n        [ this.attr('x1'), this.attr('y1') ]\r\n      , [ this.attr('x2'), this.attr('y2') ]\r\n      ])\r\n    }\r\n    // Overwrite native plot() method\r\n  , plot: function(x1, y1, x2, y2) {\r\n      if (x1 == null)\r\n        return this.array()\r\n      else if (typeof y1 !== 'undefined')\r\n        x1 = { x1: x1, y1: y1, x2: x2, y2: y2 }\r\n      else\r\n        x1 = new SVG.PointArray(x1).toLine()\r\n\r\n      return this.attr(x1)\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr(this.array().move(x, y).toLine())\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr(this.array().size(p.width, p.height).toLine())\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a line element\r\n    line: function(x1, y1, x2, y2) {\r\n      // make sure plot is called as a setter\r\n      // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray\r\n      return SVG.Line.prototype.plot.apply(\r\n        this.put(new SVG.Line)\r\n      , x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]\r\n      )\r\n    }\r\n  }\r\n})\r\n\nSVG.Polyline = SVG.invent({\r\n  // Initialize node\r\n  create: 'polyline'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polyline element\r\n    polyline: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polyline).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.Polygon = SVG.invent({\r\n  // Initialize node\r\n  create: 'polygon'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polygon element\r\n    polygon: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polygon).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\n// Add polygon-specific functions\r\nSVG.extend(SVG.Polyline, SVG.Polygon, {\r\n  // Get array\r\n  array: function() {\r\n    return this._array || (this._array = new SVG.PointArray(this.attr('points')))\r\n  }\r\n  // Plot new path\r\n, plot: function(p) {\r\n    return (p == null) ?\r\n      this.array() :\r\n      this.clear().attr('points', typeof p == 'string' ? p : (this._array = new SVG.PointArray(p)))\r\n  }\r\n  // Clear array cache\r\n, clear: function() {\r\n    delete this._array\r\n    return this\r\n  }\r\n  // Move by left top corner\r\n, move: function(x, y) {\r\n    return this.attr('points', this.array().move(x, y))\r\n  }\r\n  // Set element size to given width and height\r\n, size: function(width, height) {\r\n    var p = proportionalSize(this, width, height)\r\n\r\n    return this.attr('points', this.array().size(p.width, p.height))\r\n  }\r\n\r\n})\r\n\n// unify all point to point elements\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\r\n  // Define morphable array\r\n  morphArray:  SVG.PointArray\r\n  // Move by left top corner over x-axis\r\n, x: function(x) {\r\n    return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n  }\r\n  // Move by left top corner over y-axis\r\n, y: function(y) {\r\n    return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n  }\r\n  // Set width of element\r\n, width: function(width) {\r\n    var b = this.bbox()\r\n\r\n    return width == null ? b.width : this.size(width, b.height)\r\n  }\r\n  // Set height of element\r\n, height: function(height) {\r\n    var b = this.bbox()\r\n\r\n    return height == null ? b.height : this.size(b.width, height)\r\n  }\r\n})\nSVG.Path = SVG.invent({\r\n  // Initialize node\r\n  create: 'path'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Define morphable array\r\n    morphArray:  SVG.PathArray\r\n    // Get array\r\n  , array: function() {\r\n      return this._array || (this._array = new SVG.PathArray(this.attr('d')))\r\n    }\r\n    // Plot new path\r\n  , plot: function(d) {\r\n      return (d == null) ?\r\n        this.array() :\r\n        this.clear().attr('d', typeof d == 'string' ? d : (this._array = new SVG.PathArray(d)))\r\n    }\r\n    // Clear array cache\r\n  , clear: function() {\r\n      delete this._array\r\n      return this\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr('d', this.array().move(x, y))\r\n    }\r\n    // Move by left top corner over x-axis\r\n  , x: function(x) {\r\n      return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n    }\r\n    // Move by left top corner over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr('d', this.array().size(p.width, p.height))\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.bbox().width : this.size(width, this.bbox().height)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.bbox().height : this.size(this.bbox().width, height)\r\n    }\r\n\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped path element\r\n    path: function(d) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Path).plot(d || new SVG.PathArray)\r\n    }\r\n  }\r\n})\r\n\nSVG.Image = SVG.invent({\r\n  // Initialize node\r\n  create: 'image'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // (re)load image\r\n    load: function(url) {\r\n      if (!url) return this\r\n\r\n      var self = this\r\n        , img  = new window.Image()\r\n\r\n      // preload image\r\n      SVG.on(img, 'load', function() {\r\n        var p = self.parent(SVG.Pattern)\r\n\r\n        if(p === null) return\r\n\r\n        // ensure image size\r\n        if (self.width() == 0 && self.height() == 0)\r\n          self.size(img.width, img.height)\r\n\r\n        // ensure pattern size if not set\r\n        if (p && p.width() == 0 && p.height() == 0)\r\n          p.size(self.width(), self.height())\r\n\r\n        // callback\r\n        if (typeof self._loaded === 'function')\r\n          self._loaded.call(self, {\r\n            width:  img.width\r\n          , height: img.height\r\n          , ratio:  img.width / img.height\r\n          , url:    url\r\n          })\r\n      })\r\n\r\n      SVG.on(img, 'error', function(e){\r\n        if (typeof self._error === 'function'){\r\n            self._error.call(self, e)\r\n        }\r\n      })\r\n\r\n      return this.attr('href', (img.src = this.src = url), SVG.xlink)\r\n    }\r\n    // Add loaded callback\r\n  , loaded: function(loaded) {\r\n      this._loaded = loaded\r\n      return this\r\n    }\r\n\r\n  , error: function(error) {\r\n      this._error = error\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // create image element, load image and set its size\r\n    image: function(source, width, height) {\r\n      return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)\r\n    }\r\n  }\r\n\r\n})\nSVG.Text = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('text'))\r\n\r\n    this.dom.leading = new SVG.Number(1.3)    // store leading value for rebuilding\r\n    this._rebuild = true                      // enable automatic updating of dy values\r\n    this._build   = false                     // disable build mode for adding multiple lines\r\n\r\n    // set default font\r\n    this.attr('font-family', SVG.defaults.attrs['font-family'])\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      // act as getter\r\n      if (x == null)\r\n        return this.attr('x')\r\n\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      var oy = this.attr('y')\r\n        , o  = typeof oy === 'number' ? oy - this.bbox().y : 0\r\n\r\n      // act as getter\r\n      if (y == null)\r\n        return typeof oy === 'number' ? oy - o : oy\r\n\r\n      return this.attr('y', typeof y === 'number' ? y + o : y)\r\n    }\r\n    // Move center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)\r\n    }\r\n    // Move center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)\r\n    }\r\n    // Set the text content\r\n  , text: function(text) {\r\n      // act as getter\r\n      if (typeof text === 'undefined'){\r\n        var text = ''\r\n        var children = this.node.childNodes\r\n        for(var i = 0, len = children.length; i < len; ++i){\r\n\r\n          // add newline if its not the first child and newLined is set to true\r\n          if(i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true){\r\n            text += '\\n'\r\n          }\r\n\r\n          // add content of this node\r\n          text += children[i].textContent\r\n        }\r\n\r\n        return text\r\n      }\r\n\r\n      // remove existing content\r\n      this.clear().build(true)\r\n\r\n      if (typeof text === 'function') {\r\n        // call block\r\n        text.call(this, this)\r\n\r\n      } else {\r\n        // store text and make sure text is not blank\r\n        text = text.split('\\n')\r\n\r\n        // build new lines\r\n        for (var i = 0, il = text.length; i < il; i++)\r\n          this.tspan(text[i]).newLine()\r\n      }\r\n\r\n      // disable build mode and rebuild lines\r\n      return this.build(false).rebuild()\r\n    }\r\n    // Set font size\r\n  , size: function(size) {\r\n      return this.attr('font-size', size).rebuild()\r\n    }\r\n    // Set / get leading\r\n  , leading: function(value) {\r\n      // act as getter\r\n      if (value == null)\r\n        return this.dom.leading\r\n\r\n      // act as setter\r\n      this.dom.leading = new SVG.Number(value)\r\n\r\n      return this.rebuild()\r\n    }\r\n    // Get all the first level lines\r\n  , lines: function() {\r\n      var node = (this.textPath && this.textPath() || this).node\r\n\r\n      // filter tspans and map them to SVG.js instances\r\n      var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function(el){\r\n        return SVG.adopt(el)\r\n      })\r\n\r\n      // return an instance of SVG.set\r\n      return new SVG.Set(lines)\r\n    }\r\n    // Rebuild appearance type\r\n  , rebuild: function(rebuild) {\r\n      // store new rebuild flag if given\r\n      if (typeof rebuild == 'boolean')\r\n        this._rebuild = rebuild\r\n\r\n      // define position of all lines\r\n      if (this._rebuild) {\r\n        var self = this\r\n          , blankLineOffset = 0\r\n          , dy = this.dom.leading * new SVG.Number(this.attr('font-size'))\r\n\r\n        this.lines().each(function() {\r\n          if (this.dom.newLined) {\r\n            if (!self.textPath())\r\n              this.attr('x', self.attr('x'))\r\n            if(this.text() == '\\n') {\r\n              blankLineOffset += dy\r\n            }else{\r\n              this.attr('dy', dy + blankLineOffset)\r\n              blankLineOffset = 0\r\n            }\r\n          }\r\n        })\r\n\r\n        this.fire('rebuild')\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Enable / disable build mode\r\n  , build: function(build) {\r\n      this._build = !!build\r\n      return this\r\n    }\r\n    // overwrite method from parent to set data properly\r\n  , setData: function(o){\r\n      this.dom = o\r\n      this.dom.leading = new SVG.Number(o.leading || 1.3)\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create text element\r\n    text: function(text) {\r\n      return this.put(new SVG.Text).text(text)\r\n    }\r\n    // Create plain text element\r\n  , plain: function(text) {\r\n      return this.put(new SVG.Text).plain(text)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Tspan = SVG.invent({\r\n  // Initialize node\r\n  create: 'tspan'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set text content\r\n    text: function(text) {\r\n      if(text == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '')\r\n\r\n      typeof text === 'function' ? text.call(this, this) : this.plain(text)\r\n\r\n      return this\r\n    }\r\n    // Shortcut dx\r\n  , dx: function(dx) {\r\n      return this.attr('dx', dx)\r\n    }\r\n    // Shortcut dy\r\n  , dy: function(dy) {\r\n      return this.attr('dy', dy)\r\n    }\r\n    // Create new line\r\n  , newLine: function() {\r\n      // fetch text parent\r\n      var t = this.parent(SVG.Text)\r\n\r\n      // mark new line\r\n      this.dom.newLined = true\r\n\r\n      // apply new hyÂ¡n\r\n      return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x())\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Text, SVG.Tspan, {\r\n  // Create plain text node\r\n  plain: function(text) {\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // create text node\r\n    this.node.appendChild(document.createTextNode(text))\r\n\r\n    return this\r\n  }\r\n  // Create a tspan\r\n, tspan: function(text) {\r\n    var node  = (this.textPath && this.textPath() || this).node\r\n      , tspan = new SVG.Tspan\r\n\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // add new tspan\r\n    node.appendChild(tspan.node)\r\n\r\n    return tspan.text(text)\r\n  }\r\n  // Clear all lines\r\n, clear: function() {\r\n    var node = (this.textPath && this.textPath() || this).node\r\n\r\n    // remove existing child nodes\r\n    while (node.hasChildNodes())\r\n      node.removeChild(node.lastChild)\r\n\r\n    return this\r\n  }\r\n  // Get length of text element\r\n, length: function() {\r\n    return this.node.getComputedTextLength()\r\n  }\r\n})\r\n\nSVG.TextPath = SVG.invent({\r\n  // Initialize node\r\n  create: 'textPath'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n  // Define parent class\r\n, parent: SVG.Text\r\n\r\n  // Add parent method\r\n, construct: {\r\n    morphArray: SVG.PathArray\r\n    // Create path for text to run on\r\n  , path: function(d) {\r\n      // create textPath element\r\n      var path  = new SVG.TextPath\r\n        , track = this.doc().defs().path(d)\r\n\r\n      // move lines to textpath\r\n      while (this.node.hasChildNodes())\r\n        path.node.appendChild(this.node.firstChild)\r\n\r\n      // add textPath element as child node\r\n      this.node.appendChild(path.node)\r\n\r\n      // link textPath to path and add content\r\n      path.attr('href', '#' + track, SVG.xlink)\r\n\r\n      return this\r\n    }\r\n    // return the array of the path track element\r\n  , array: function() {\r\n      var track = this.track()\r\n\r\n      return track ? track.array() : null\r\n    }\r\n    // Plot path if any\r\n  , plot: function(d) {\r\n      var track = this.track()\r\n        , pathArray = null\r\n\r\n      if (track) {\r\n        pathArray = track.plot(d)\r\n      }\r\n\r\n      return (d == null) ? pathArray : this\r\n    }\r\n    // Get the path track element\r\n  , track: function() {\r\n      var path = this.textPath()\r\n\r\n      if (path)\r\n        return path.reference('href')\r\n    }\r\n    // Get the textPath child\r\n  , textPath: function() {\r\n      if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath')\r\n        return SVG.adopt(this.node.firstChild)\r\n    }\r\n  }\r\n})\r\n\nSVG.Nested = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('svg'))\r\n\r\n    this.style('overflow', 'visible')\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create nested svg document\r\n    nested: function() {\r\n      return this.put(new SVG.Nested)\r\n    }\r\n  }\r\n})\nSVG.A = SVG.invent({\r\n  // Initialize node\r\n  create: 'a'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Link url\r\n    to: function(url) {\r\n      return this.attr('href', url, SVG.xlink)\r\n    }\r\n    // Link show attribute\r\n  , show: function(target) {\r\n      return this.attr('show', target, SVG.xlink)\r\n    }\r\n    // Link target attribute\r\n  , target: function(target) {\r\n      return this.attr('target', target)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a hyperlink element\r\n    link: function(url) {\r\n      return this.put(new SVG.A).to(url)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Create a hyperlink element\r\n  linkTo: function(url) {\r\n    var link = new SVG.A\r\n\r\n    if (typeof url == 'function')\r\n      url.call(link, link)\r\n    else\r\n      link.to(url)\r\n\r\n    return this.parent().put(link).put(this)\r\n  }\r\n\r\n})\nSVG.Marker = SVG.invent({\r\n  // Initialize node\r\n  create: 'marker'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set width of element\r\n    width: function(width) {\r\n      return this.attr('markerWidth', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('markerHeight', height)\r\n    }\r\n    // Set marker refX and refY\r\n  , ref: function(x, y) {\r\n      return this.attr('refX', x).attr('refY', y)\r\n    }\r\n    // Update marker\r\n  , update: function(block) {\r\n      // remove all content\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , toString: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    marker: function(width, height, block) {\r\n      // Create marker element in defs\r\n      return this.defs().marker(width, height, block)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Create marker\r\n  marker: function(width, height, block) {\r\n    // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\r\n    return this.put(new SVG.Marker)\r\n      .size(width, height)\r\n      .ref(width / 2, height / 2)\r\n      .viewbox(0, 0, width, height)\r\n      .attr('orient', 'auto')\r\n      .update(block)\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {\r\n  // Create and attach markers\r\n  marker: function(marker, width, height, block) {\r\n    var attr = ['marker']\r\n\r\n    // Build attribute name\r\n    if (marker != 'all') attr.push(marker)\r\n    attr = attr.join('-')\r\n\r\n    // Set marker attribute\r\n    marker = arguments[1] instanceof SVG.Marker ?\r\n      arguments[1] :\r\n      this.doc().marker(width, height, block)\r\n\r\n    return this.attr(attr, marker)\r\n  }\r\n\r\n})\n// Define list of available attributes for stroke and fill\r\nvar sugar = {\r\n  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']\r\n, fill:   ['color', 'opacity', 'rule']\r\n, prefix: function(t, a) {\r\n    return a == 'color' ? t : t + '-' + a\r\n  }\r\n}\r\n\r\n// Add sugar for fill and stroke\r\n;['fill', 'stroke'].forEach(function(m) {\r\n  var i, extension = {}\r\n\r\n  extension[m] = function(o) {\r\n    if (typeof o == 'undefined')\r\n      return this\r\n    if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))\r\n      this.attr(m, o)\r\n\r\n    else\r\n      // set all attributes from sugar.fill and sugar.stroke list\r\n      for (i = sugar[m].length - 1; i >= 0; i--)\r\n        if (o[sugar[m][i]] != null)\r\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])\r\n\r\n    return this\r\n  }\r\n\r\n  SVG.extend(SVG.Element, SVG.FX, extension)\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, SVG.FX, {\r\n  // Map rotation to transform\r\n  rotate: function(d, cx, cy) {\r\n    return this.transform({ rotation: d, cx: cx, cy: cy })\r\n  }\r\n  // Map skew to transform\r\n, skew: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ skew: x, cx: y, cy: cx }) :\r\n      this.transform({ skewX: x, skewY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map scale to transform\r\n, scale: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ scale: x, cx: y, cy: cx }) :\r\n      this.transform({ scaleX: x, scaleY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map translate to transform\r\n, translate: function(x, y) {\r\n    return this.transform({ x: x, y: y })\r\n  }\r\n  // Map flip to transform\r\n, flip: function(a, o) {\r\n    o = typeof a == 'number' ? a : o\r\n    return this.transform({ flip: a || 'both', offset: o })\r\n  }\r\n  // Map matrix to transform\r\n, matrix: function(m) {\r\n    return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m))\r\n  }\r\n  // Opacity\r\n, opacity: function(value) {\r\n    return this.attr('opacity', value)\r\n  }\r\n  // Relative move over x axis\r\n, dx: function(x) {\r\n    return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true)\r\n  }\r\n  // Relative move over y axis\r\n, dy: function(y) {\r\n    return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true)\r\n  }\r\n  // Relative move over x and y axes\r\n, dmove: function(x, y) {\r\n    return this.dx(x).dy(y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {\r\n  // Add x and y radius\r\n  radius: function(x, y) {\r\n    var type = (this._target || this).type;\r\n    return type == 'radial' || type == 'circle' ?\r\n      this.attr('r', new SVG.Number(x)) :\r\n      this.rx(x).ry(y == null ? x : y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Path, {\r\n  // Get path length\r\n  length: function() {\r\n    return this.node.getTotalLength()\r\n  }\r\n  // Get point at length\r\n, pointAt: function(length) {\r\n    return this.node.getPointAtLength(length)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {\r\n  // Set font\r\n  font: function(a, v) {\r\n    if (typeof a == 'object') {\r\n      for (v in a) this.font(v, a[v])\r\n    }\r\n\r\n    return a == 'leading' ?\r\n        this.leading(v) :\r\n      a == 'anchor' ?\r\n        this.attr('text-anchor', v) :\r\n      a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ?\r\n        this.attr('font-'+ a, v) :\r\n        this.attr(a, v)\r\n  }\r\n})\r\n\nSVG.Set = SVG.invent({\r\n  // Initialize\r\n  create: function(members) {\r\n    // Set initial state\r\n    Array.isArray(members) ? this.members = members : this.clear()\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add element to set\r\n    add: function() {\r\n      var i, il, elements = [].slice.call(arguments)\r\n\r\n      for (i = 0, il = elements.length; i < il; i++)\r\n        this.members.push(elements[i])\r\n\r\n      return this\r\n    }\r\n    // Remove element from set\r\n  , remove: function(element) {\r\n      var i = this.index(element)\r\n\r\n      // remove given child\r\n      if (i > -1)\r\n        this.members.splice(i, 1)\r\n\r\n      return this\r\n    }\r\n    // Iterate over all members\r\n  , each: function(block) {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        block.apply(this.members[i], [i, this.members])\r\n\r\n      return this\r\n    }\r\n    // Restore to defaults\r\n  , clear: function() {\r\n      // initialize store\r\n      this.members = []\r\n\r\n      return this\r\n    }\r\n    // Get the length of a set\r\n  , length: function() {\r\n      return this.members.length\r\n    }\r\n    // Checks if a given element is present in set\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // retuns index of given element in set\r\n  , index: function(element) {\r\n      return this.members.indexOf(element)\r\n    }\r\n    // Get member at given index\r\n  , get: function(i) {\r\n      return this.members[i]\r\n    }\r\n    // Get first member\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get last member\r\n  , last: function() {\r\n      return this.get(this.members.length - 1)\r\n    }\r\n    // Default value\r\n  , valueOf: function() {\r\n      return this.members\r\n    }\r\n    // Get the bounding box of all members included or empty box if set has no items\r\n  , bbox: function(){\r\n      // return an empty box of there are no members\r\n      if (this.members.length == 0)\r\n        return new SVG.RBox()\r\n\r\n      // get the first rbox and update the target bbox\r\n      var rbox = this.members[0].rbox(this.members[0].doc())\r\n\r\n      this.each(function() {\r\n        // user rbox for correct position and visual representation\r\n        rbox = rbox.merge(this.rbox(this.doc()))\r\n      })\r\n\r\n      return rbox\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a new set\r\n    set: function(members) {\r\n      return new SVG.Set(members)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.FX.Set = SVG.invent({\r\n  // Initialize node\r\n  create: function(set) {\r\n    // store reference to set\r\n    this.set = set\r\n  }\r\n\r\n})\r\n\r\n// Alias methods\r\nSVG.Set.inherit = function() {\r\n  var m\r\n    , methods = []\r\n\r\n  // gather shape methods\r\n  for(var m in SVG.Shape.prototype)\r\n    if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply shape aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        if (this.members[i] && typeof this.members[i][method] == 'function')\r\n          this.members[i][method].apply(this.members[i], arguments)\r\n\r\n      return method == 'animate' ? (this.fx || (this.fx = new SVG.FX.Set(this))) : this\r\n    }\r\n  })\r\n\r\n  // clear methods for the next round\r\n  methods = []\r\n\r\n  // gather fx methods\r\n  for(var m in SVG.FX.prototype)\r\n    if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply fx aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.FX.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.set.members.length; i < il; i++)\r\n        this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)\r\n\r\n      return this\r\n    }\r\n  })\r\n}\r\n\r\n\r\n\n\r\nSVG.extend(SVG.Element, {\r\n  // Store data values on svg nodes\r\n  data: function(a, v, r) {\r\n    if (typeof a == 'object') {\r\n      for (v in a)\r\n        this.data(v, a[v])\r\n\r\n    } else if (arguments.length < 2) {\r\n      try {\r\n        return JSON.parse(this.attr('data-' + a))\r\n      } catch(e) {\r\n        return this.attr('data-' + a)\r\n      }\r\n\r\n    } else {\r\n      this.attr(\r\n        'data-' + a\r\n      , v === null ?\r\n          null :\r\n        r === true || typeof v === 'string' || typeof v === 'number' ?\r\n          v :\r\n          JSON.stringify(v)\r\n      )\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.extend(SVG.Element, {\r\n  // Remember arbitrary data\r\n  remember: function(k, v) {\r\n    // remember every item in an object individually\r\n    if (typeof arguments[0] == 'object')\r\n      for (var v in k)\r\n        this.remember(v, k[v])\r\n\r\n    // retrieve memory\r\n    else if (arguments.length == 1)\r\n      return this.memory()[k]\r\n\r\n    // store memory\r\n    else\r\n      this.memory()[k] = v\r\n\r\n    return this\r\n  }\r\n\r\n  // Erase a given memory\r\n, forget: function() {\r\n    if (arguments.length == 0)\r\n      this._memory = {}\r\n    else\r\n      for (var i = arguments.length - 1; i >= 0; i--)\r\n        delete this.memory()[arguments[i]]\r\n\r\n    return this\r\n  }\r\n\r\n  // Initialize or return local memory object\r\n, memory: function() {\r\n    return this._memory || (this._memory = {})\r\n  }\r\n\r\n})\n// Method for getting an element by id\r\nSVG.get = function(id) {\r\n  var node = document.getElementById(idFromReference(id) || id)\r\n  return SVG.adopt(node)\r\n}\r\n\r\n// Select elements by query string\r\nSVG.select = function(query, parent) {\r\n  return new SVG.Set(\r\n    SVG.utils.map((parent || document).querySelectorAll(query), function(node) {\r\n      return SVG.adopt(node)\r\n    })\r\n  )\r\n}\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Scoped select method\r\n  select: function(query) {\r\n    return SVG.select(query, this.node)\r\n  }\r\n\r\n})\nfunction pathRegReplace(a, b, c, d) {\r\n  return c + d.replace(SVG.regex.dots, ' .')\r\n}\r\n\r\n// creates deep clone of array\r\nfunction array_clone(arr){\r\n  var clone = arr.slice(0)\r\n  for(var i = clone.length; i--;){\r\n    if(Array.isArray(clone[i])){\r\n      clone[i] = array_clone(clone[i])\r\n    }\r\n  }\r\n  return clone\r\n}\r\n\r\n// tests if a given element is instance of an object\r\nfunction is(el, obj){\r\n  return el instanceof obj\r\n}\r\n\r\n// tests if a given selector matches an element\r\nfunction matches(el, selector) {\r\n  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\r\n}\r\n\r\n// Convert dash-separated-string to camelCase\r\nfunction camelCase(s) {\r\n  return s.toLowerCase().replace(/-(.)/g, function(m, g) {\r\n    return g.toUpperCase()\r\n  })\r\n}\r\n\r\n// Capitalize first letter of a string\r\nfunction capitalize(s) {\r\n  return s.charAt(0).toUpperCase() + s.slice(1)\r\n}\r\n\r\n// Ensure to six-based hex\r\nfunction fullHex(hex) {\r\n  return hex.length == 4 ?\r\n    [ '#',\r\n      hex.substring(1, 2), hex.substring(1, 2)\r\n    , hex.substring(2, 3), hex.substring(2, 3)\r\n    , hex.substring(3, 4), hex.substring(3, 4)\r\n    ].join('') : hex\r\n}\r\n\r\n// Component to hex value\r\nfunction compToHex(comp) {\r\n  var hex = comp.toString(16)\r\n  return hex.length == 1 ? '0' + hex : hex\r\n}\r\n\r\n// Calculate proportional width and height values when necessary\r\nfunction proportionalSize(element, width, height) {\r\n  if (width == null || height == null) {\r\n    var box = element.bbox()\r\n\r\n    if (width == null)\r\n      width = box.width / box.height * height\r\n    else if (height == null)\r\n      height = box.height / box.width * width\r\n  }\r\n\r\n  return {\r\n    width:  width\r\n  , height: height\r\n  }\r\n}\r\n\r\n// Delta transform point\r\nfunction deltaTransformPoint(matrix, x, y) {\r\n  return {\r\n    x: x * matrix.a + y * matrix.c + 0\r\n  , y: x * matrix.b + y * matrix.d + 0\r\n  }\r\n}\r\n\r\n// Map matrix array to object\r\nfunction arrayToMatrix(a) {\r\n  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }\r\n}\r\n\r\n// Parse matrix if required\r\nfunction parseMatrix(matrix) {\r\n  if (!(matrix instanceof SVG.Matrix))\r\n    matrix = new SVG.Matrix(matrix)\r\n\r\n  return matrix\r\n}\r\n\r\n// Add centre point to transform object\r\nfunction ensureCentre(o, target) {\r\n  o.cx = o.cx == null ? target.bbox().cx : o.cx\r\n  o.cy = o.cy == null ? target.bbox().cy : o.cy\r\n}\r\n\r\n// PathArray Helpers\r\nfunction arrayToString(a) {\r\n  for (var i = 0, il = a.length, s = ''; i < il; i++) {\r\n    s += a[i][0]\r\n\r\n    if (a[i][1] != null) {\r\n      s += a[i][1]\r\n\r\n      if (a[i][2] != null) {\r\n        s += ' '\r\n        s += a[i][2]\r\n\r\n        if (a[i][3] != null) {\r\n          s += ' '\r\n          s += a[i][3]\r\n          s += ' '\r\n          s += a[i][4]\r\n\r\n          if (a[i][5] != null) {\r\n            s += ' '\r\n            s += a[i][5]\r\n            s += ' '\r\n            s += a[i][6]\r\n\r\n            if (a[i][7] != null) {\r\n              s += ' '\r\n              s += a[i][7]\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return s + ' '\r\n}\r\n\r\n// Deep new id assignment\r\nfunction assignNewId(node) {\r\n  // do the same for SVG child nodes as well\r\n  for (var i = node.childNodes.length - 1; i >= 0; i--)\r\n    if (node.childNodes[i] instanceof window.SVGElement)\r\n      assignNewId(node.childNodes[i])\r\n\r\n  return SVG.adopt(node).id(SVG.eid(node.nodeName))\r\n}\r\n\r\n// Add more bounding box properties\r\nfunction fullBox(b) {\r\n  if (b.x == null) {\r\n    b.x      = 0\r\n    b.y      = 0\r\n    b.width  = 0\r\n    b.height = 0\r\n  }\r\n\r\n  b.w  = b.width\r\n  b.h  = b.height\r\n  b.x2 = b.x + b.width\r\n  b.y2 = b.y + b.height\r\n  b.cx = b.x + b.width / 2\r\n  b.cy = b.y + b.height / 2\r\n\r\n  return b\r\n}\r\n\r\n// Get id from reference string\r\nfunction idFromReference(url) {\r\n  var m = url.toString().match(SVG.regex.reference)\r\n\r\n  if (m) return m[1]\r\n}\r\n\r\n// Create matrix array for looping\r\nvar abcdef = 'abcdef'.split('')\n// Add CustomEvent to IE9 and IE10\r\nif (typeof window.CustomEvent !== 'function') {\r\n  // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\r\n  var CustomEvent = function(event, options) {\r\n    options = options || { bubbles: false, cancelable: false, detail: undefined }\r\n    var e = document.createEvent('CustomEvent')\r\n    e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)\r\n    return e\r\n  }\r\n\r\n  CustomEvent.prototype = window.Event.prototype\r\n\r\n  window.CustomEvent = CustomEvent\r\n}\r\n\r\n// requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish\r\n(function(w) {\r\n  var lastTime = 0\r\n  var vendors = ['moz', 'webkit']\r\n\r\n  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n    w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']\r\n    w.cancelAnimationFrame  = w[vendors[x] + 'CancelAnimationFrame'] ||\r\n                              w[vendors[x] + 'CancelRequestAnimationFrame']\r\n  }\r\n\r\n  w.requestAnimationFrame = w.requestAnimationFrame ||\r\n    function(callback) {\r\n      var currTime = new Date().getTime()\r\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime))\r\n\r\n      var id = w.setTimeout(function() {\r\n        callback(currTime + timeToCall)\r\n      }, timeToCall)\r\n\r\n      lastTime = currTime + timeToCall\r\n      return id\r\n    }\r\n\r\n  w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;\r\n\r\n}(window))\r\n\r\nreturn SVG\r\n\r\n}));\r//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3ZnanMvZGlzdC9zdmcuanM/MGFkNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQUE7QUFDTCxHQUFHO0FBQ0gsZ0ZBQWdGO0FBQ2hGLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCLFdBQVcsVUFBVTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRTs7QUFFM0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxJQUFJOztBQUVwQztBQUNBOztBQUVBO0FBQ0EsOEJBQThCLEdBQUc7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLHlDQUF5QztBQUN0Rjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUOztBQUVBLFNBQVM7QUFDVDs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7O0FBRUEsT0FBTztBQUNQOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQ0FBc0MseUJBQXlCO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0QsUUFBUTtBQUN2RTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGNBQWM7QUFDbEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCxpRUFBaUU7O0FBRXJIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsbUNBQW1DOztBQUUzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxTQUFTOztBQUV0RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUk7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLE9BQU8sZUFBZTtBQUN0QjtBQUNBLE9BQU8sYUFBYTtBQUNwQjtBQUNBLE9BQU8sMkJBQTJCOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7O0FBRUE7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHlCQUF5QjtBQUNuRyxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBLHlCQUF5QjtBQUN6QixnQ0FBZ0M7QUFDaEMsK0JBQStCLGFBQWE7QUFDNUMsMkJBQTJCLDRCQUE0Qjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDJDQUEyQyx3QkFBd0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1RUFBdUUsOEJBQThCO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxrQkFBa0I7QUFDakY7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGtCQUFrQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBK0M7QUFDaEUsaUJBQWlCLCtDQUErQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBK0M7QUFDaEUsaUJBQWlCLCtDQUErQztBQUNoRTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0Msc0JBQXNCLHFDQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQsc0JBQXNCLHVDQUF1QztBQUM3RDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrQkFBK0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsUUFBUTtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBLENBQUMiLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiogc3ZnLmpzIC0gQSBsaWdodHdlaWdodCBsaWJyYXJ5IGZvciBtYW5pcHVsYXRpbmcgYW5kIGFuaW1hdGluZyBTVkcuXG4qIEB2ZXJzaW9uIDIuNi4yXG4qIGh0dHBzOi8vc3ZnZG90anMuZ2l0aHViLmlvL1xuKlxuKiBAY29weXJpZ2h0IFdvdXQgRmllcmVucyA8d291dEBtaWNrLXdvdXQuY29tPlxuKiBAbGljZW5zZSBNSVRcbipcbiogQlVJTFQ6IE1vbiBKdW4gMDUgMjAxNyAxMTozMzoyMyBHTVQrMDIwMCAoTWl0dGVsZXVyb3DDpGlzY2hlIFNvbW1lcnplaXQpXG4qLztcbihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIGZhY3Rvcnkocm9vdCwgcm9vdC5kb2N1bWVudClcclxuICAgIH0pXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gcm9vdC5kb2N1bWVudCA/IGZhY3Rvcnkocm9vdCwgcm9vdC5kb2N1bWVudCkgOiBmdW5jdGlvbih3KXsgcmV0dXJuIGZhY3Rvcnkodywgdy5kb2N1bWVudCkgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICByb290LlNWRyA9IGZhY3Rvcnkocm9vdCwgcm9vdC5kb2N1bWVudClcclxuICB9XHJcbn0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQpIHtcclxuXHJcbi8vIFRoZSBtYWluIHdyYXBwaW5nIGVsZW1lbnRcclxudmFyIFNWRyA9IHRoaXMuU1ZHID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gIGlmIChTVkcuc3VwcG9ydGVkKSB7XHJcbiAgICBlbGVtZW50ID0gbmV3IFNWRy5Eb2MoZWxlbWVudClcclxuXHJcbiAgICBpZighU1ZHLnBhcnNlci5kcmF3KVxyXG4gICAgICBTVkcucHJlcGFyZSgpXHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnRcclxuICB9XHJcbn1cclxuXHJcbi8vIERlZmF1bHQgbmFtZXNwYWNlc1xyXG5TVkcubnMgICAgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXHJcblNWRy54bWxucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLydcclxuU1ZHLnhsaW5rID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnXHJcblNWRy5zdmdqcyA9ICdodHRwOi8vc3ZnanMuY29tL3N2Z2pzJ1xyXG5cclxuLy8gU3ZnIHN1cHBvcnQgdGVzdFxyXG5TVkcuc3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiAhISBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiZcclxuICAgICAgICAgISEgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWRy5ucywnc3ZnJykuY3JlYXRlU1ZHUmVjdFxyXG59KSgpXHJcblxyXG4vLyBEb24ndCBib3RoZXIgdG8gY29udGludWUgaWYgU1ZHIGlzIG5vdCBzdXBwb3J0ZWRcclxuaWYgKCFTVkcuc3VwcG9ydGVkKSByZXR1cm4gZmFsc2VcclxuXHJcbi8vIEVsZW1lbnQgaWQgc2VxdWVuY2VcclxuU1ZHLmRpZCAgPSAxMDAwXHJcblxyXG4vLyBHZXQgbmV4dCBuYW1lZCBlbGVtZW50IGlkXHJcblNWRy5laWQgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgcmV0dXJuICdTdmdqcycgKyBjYXBpdGFsaXplKG5hbWUpICsgKFNWRy5kaWQrKylcclxufVxyXG5cclxuLy8gTWV0aG9kIGZvciBlbGVtZW50IGNyZWF0aW9uXHJcblNWRy5jcmVhdGUgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgLy8gY3JlYXRlIGVsZW1lbnRcclxuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5zLCBuYW1lKVxyXG5cclxuICAvLyBhcHBseSB1bmlxdWUgaWRcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmVpZChuYW1lKSlcclxuXHJcbiAgcmV0dXJuIGVsZW1lbnRcclxufVxyXG5cclxuLy8gTWV0aG9kIGZvciBleHRlbmRpbmcgb2JqZWN0c1xyXG5TVkcuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIG1vZHVsZXMsIG1ldGhvZHMsIGtleSwgaVxyXG5cclxuICAvLyBHZXQgbGlzdCBvZiBtb2R1bGVzXHJcbiAgbW9kdWxlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxyXG5cclxuICAvLyBHZXQgb2JqZWN0IHdpdGggZXh0ZW5zaW9uc1xyXG4gIG1ldGhvZHMgPSBtb2R1bGVzLnBvcCgpXHJcblxyXG4gIGZvciAoaSA9IG1vZHVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICBpZiAobW9kdWxlc1tpXSlcclxuICAgICAgZm9yIChrZXkgaW4gbWV0aG9kcylcclxuICAgICAgICBtb2R1bGVzW2ldLnByb3RvdHlwZVtrZXldID0gbWV0aG9kc1trZXldXHJcblxyXG4gIC8vIE1ha2Ugc3VyZSBTVkcuU2V0IGluaGVyaXRzIGFueSBuZXdseSBhZGRlZCBtZXRob2RzXHJcbiAgaWYgKFNWRy5TZXQgJiYgU1ZHLlNldC5pbmhlcml0KVxyXG4gICAgU1ZHLlNldC5pbmhlcml0KClcclxufVxyXG5cclxuLy8gSW52ZW50IG5ldyBlbGVtZW50XHJcblNWRy5pbnZlbnQgPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAvLyBDcmVhdGUgZWxlbWVudCBpbml0aWFsaXplclxyXG4gIHZhciBpbml0aWFsaXplciA9IHR5cGVvZiBjb25maWcuY3JlYXRlID09ICdmdW5jdGlvbicgP1xyXG4gICAgY29uZmlnLmNyZWF0ZSA6XHJcbiAgICBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUoY29uZmlnLmNyZWF0ZSkpXHJcbiAgICB9XHJcblxyXG4gIC8vIEluaGVyaXQgcHJvdG90eXBlXHJcbiAgaWYgKGNvbmZpZy5pbmhlcml0KVxyXG4gICAgaW5pdGlhbGl6ZXIucHJvdG90eXBlID0gbmV3IGNvbmZpZy5pbmhlcml0XHJcblxyXG4gIC8vIEV4dGVuZCB3aXRoIG1ldGhvZHNcclxuICBpZiAoY29uZmlnLmV4dGVuZClcclxuICAgIFNWRy5leHRlbmQoaW5pdGlhbGl6ZXIsIGNvbmZpZy5leHRlbmQpXHJcblxyXG4gIC8vIEF0dGFjaCBjb25zdHJ1Y3QgbWV0aG9kIHRvIHBhcmVudFxyXG4gIGlmIChjb25maWcuY29uc3RydWN0KVxyXG4gICAgU1ZHLmV4dGVuZChjb25maWcucGFyZW50IHx8IFNWRy5Db250YWluZXIsIGNvbmZpZy5jb25zdHJ1Y3QpXHJcblxyXG4gIHJldHVybiBpbml0aWFsaXplclxyXG59XHJcblxyXG4vLyBBZG9wdCBleGlzdGluZyBzdmcgZWxlbWVudHNcclxuU1ZHLmFkb3B0ID0gZnVuY3Rpb24obm9kZSkge1xyXG4gIC8vIGNoZWNrIGZvciBwcmVzZW5jZSBvZiBub2RlXHJcbiAgaWYgKCFub2RlKSByZXR1cm4gbnVsbFxyXG5cclxuICAvLyBtYWtlIHN1cmUgYSBub2RlIGlzbid0IGFscmVhZHkgYWRvcHRlZFxyXG4gIGlmIChub2RlLmluc3RhbmNlKSByZXR1cm4gbm9kZS5pbnN0YW5jZVxyXG5cclxuICAvLyBpbml0aWFsaXplIHZhcmlhYmxlc1xyXG4gIHZhciBlbGVtZW50XHJcblxyXG4gIC8vIGFkb3B0IHdpdGggZWxlbWVudC1zcGVjaWZpYyBzZXR0aW5nc1xyXG4gIGlmIChub2RlLm5vZGVOYW1lID09ICdzdmcnKVxyXG4gICAgZWxlbWVudCA9IG5vZGUucGFyZW50Tm9kZSBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50ID8gbmV3IFNWRy5OZXN0ZWQgOiBuZXcgU1ZHLkRvY1xyXG4gIGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT0gJ2xpbmVhckdyYWRpZW50JylcclxuICAgIGVsZW1lbnQgPSBuZXcgU1ZHLkdyYWRpZW50KCdsaW5lYXInKVxyXG4gIGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT0gJ3JhZGlhbEdyYWRpZW50JylcclxuICAgIGVsZW1lbnQgPSBuZXcgU1ZHLkdyYWRpZW50KCdyYWRpYWwnKVxyXG4gIGVsc2UgaWYgKFNWR1tjYXBpdGFsaXplKG5vZGUubm9kZU5hbWUpXSlcclxuICAgIGVsZW1lbnQgPSBuZXcgU1ZHW2NhcGl0YWxpemUobm9kZS5ub2RlTmFtZSldXHJcbiAgZWxzZVxyXG4gICAgZWxlbWVudCA9IG5ldyBTVkcuRWxlbWVudChub2RlKVxyXG5cclxuICAvLyBlbnN1cmUgcmVmZXJlbmNlc1xyXG4gIGVsZW1lbnQudHlwZSAgPSBub2RlLm5vZGVOYW1lXHJcbiAgZWxlbWVudC5ub2RlICA9IG5vZGVcclxuICBub2RlLmluc3RhbmNlID0gZWxlbWVudFxyXG5cclxuICAvLyBTVkcuQ2xhc3Mgc3BlY2lmaWMgcHJlcGFyYXRpb25zXHJcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTVkcuRG9jKVxyXG4gICAgZWxlbWVudC5uYW1lc3BhY2UoKS5kZWZzKClcclxuXHJcbiAgLy8gcHVsbCBzdmdqcyBkYXRhIGZyb20gdGhlIGRvbSAoZ2V0QXR0cmlidXRlTlMgZG9lc24ndCB3b3JrIGluIGh0bWw1KVxyXG4gIGVsZW1lbnQuc2V0RGF0YShKU09OLnBhcnNlKG5vZGUuZ2V0QXR0cmlidXRlKCdzdmdqczpkYXRhJykpIHx8IHt9KVxyXG5cclxuICByZXR1cm4gZWxlbWVudFxyXG59XHJcblxyXG4vLyBJbml0aWFsaXplIHBhcnNpbmcgZWxlbWVudFxyXG5TVkcucHJlcGFyZSA9IGZ1bmN0aW9uKCkge1xyXG4gIC8vIFNlbGVjdCBkb2N1bWVudCBib2R5IGFuZCBjcmVhdGUgaW52aXNpYmxlIHN2ZyBlbGVtZW50XHJcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdXHJcbiAgICAsIGRyYXcgPSAoYm9keSA/IG5ldyBTVkcuRG9jKGJvZHkpIDogU1ZHLmFkb3B0KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkubmVzdGVkKCkpLnNpemUoMiwgMClcclxuXHJcbiAgLy8gQ3JlYXRlIHBhcnNlciBvYmplY3RcclxuICBTVkcucGFyc2VyID0ge1xyXG4gICAgYm9keTogYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcclxuICAsIGRyYXc6IGRyYXcuc3R5bGUoJ29wYWNpdHk6MDtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMDAlO3RvcDotMTAwJTtvdmVyZmxvdzpoaWRkZW4nKS5ub2RlXHJcbiAgLCBwb2x5OiBkcmF3LnBvbHlsaW5lKCkubm9kZVxyXG4gICwgcGF0aDogZHJhdy5wYXRoKCkubm9kZVxyXG4gICwgbmF0aXZlOiBTVkcuY3JlYXRlKCdzdmcnKVxyXG4gIH1cclxufVxyXG5cclxuU1ZHLnBhcnNlciA9IHtcclxuICBuYXRpdmU6IFNWRy5jcmVhdGUoJ3N2ZycpXHJcbn1cclxuXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpIHtcclxuICBpZighU1ZHLnBhcnNlci5kcmF3KVxyXG4gICAgU1ZHLnByZXBhcmUoKVxyXG59LCBmYWxzZSlcclxuXG4vLyBTdG9yYWdlIGZvciByZWd1bGFyIGV4cHJlc3Npb25zXHJcblNWRy5yZWdleCA9IHtcclxuICAvLyBQYXJzZSB1bml0IHZhbHVlXHJcbiAgbnVtYmVyQW5kVW5pdDogICAgL14oWystXT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/KShbYS16JV0qKSQvaVxyXG5cclxuICAvLyBQYXJzZSBoZXggdmFsdWVcclxuLCBoZXg6ICAgICAgICAgICAgICAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pXHJcblxyXG4gIC8vIFBhcnNlIHJnYiB2YWx1ZVxyXG4sIHJnYjogICAgICAgICAgICAgIC9yZ2JcXCgoXFxkKyksKFxcZCspLChcXGQrKVxcKS9cclxuXHJcbiAgLy8gUGFyc2UgcmVmZXJlbmNlIGlkXHJcbiwgcmVmZXJlbmNlOiAgICAgICAgLyMoW2EtejAtOVxcLV9dKykvaVxyXG5cclxuICAvLyBzcGxpdHMgYSB0cmFuc2Zvcm1hdGlvbiBjaGFpblxyXG4sIHRyYW5zZm9ybXM6ICAgICAgIC9cXClcXHMqLD9cXHMqL1xyXG5cclxuICAvLyBXaGl0ZXNwYWNlXHJcbiwgd2hpdGVzcGFjZTogICAgICAgL1xccy9nXHJcblxyXG4gIC8vIFRlc3QgaGV4IHZhbHVlXHJcbiwgaXNIZXg6ICAgICAgICAgICAgL14jW2EtZjAtOV17Myw2fSQvaVxyXG5cclxuICAvLyBUZXN0IHJnYiB2YWx1ZVxyXG4sIGlzUmdiOiAgICAgICAgICAgIC9ecmdiXFwoL1xyXG5cclxuICAvLyBUZXN0IGNzcyBkZWNsYXJhdGlvblxyXG4sIGlzQ3NzOiAgICAgICAgICAgIC9bXjpdKzpbXjtdKzs/L1xyXG5cclxuICAvLyBUZXN0IGZvciBibGFuayBzdHJpbmdcclxuLCBpc0JsYW5rOiAgICAgICAgICAvXihcXHMrKT8kL1xyXG5cclxuICAvLyBUZXN0IGZvciBudW1lcmljIHN0cmluZ1xyXG4sIGlzTnVtYmVyOiAgICAgICAgIC9eWystXT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pXHJcblxyXG4gIC8vIFRlc3QgZm9yIHBlcmNlbnQgdmFsdWVcclxuLCBpc1BlcmNlbnQ6ICAgICAgICAvXi0/W1xcZFxcLl0rJSQvXHJcblxyXG4gIC8vIFRlc3QgZm9yIGltYWdlIHVybFxyXG4sIGlzSW1hZ2U6ICAgICAgICAgIC9cXC4oanBnfGpwZWd8cG5nfGdpZnxzdmcpKFxcP1tePV0rLiopPy9pXHJcblxyXG4gIC8vIHNwbGl0IGF0IHdoaXRlc3BhY2UgYW5kIGNvbW1hXHJcbiwgZGVsaW1pdGVyOiAgICAgICAgL1tcXHMsXSsvXHJcblxyXG4gIC8vIFRoZSBmb2xsb3dpbmcgcmVnZXggYXJlIHVzZWQgdG8gcGFyc2UgdGhlIGQgYXR0cmlidXRlIG9mIGEgcGF0aFxyXG5cclxuICAvLyBNYXRjaGVzIGFsbCBoeXBoZW5zIHdoaWNoIGFyZSBub3QgYWZ0ZXIgYW4gZXhwb25lbnRcclxuLCBoeXBoZW46ICAgICAgICAgICAvKFteZV0pXFwtL2dpXHJcblxyXG4gIC8vIFJlcGxhY2VzIGFuZCB0ZXN0cyBmb3IgYWxsIHBhdGggbGV0dGVyc1xyXG4sIHBhdGhMZXR0ZXJzOiAgICAgIC9bTUxIVkNTUVRBWl0vZ2lcclxuXHJcbiAgLy8geWVzIHdlIG5lZWQgdGhpcyBvbmUsIHRvb1xyXG4sIGlzUGF0aExldHRlcjogICAgIC9bTUxIVkNTUVRBWl0vaVxyXG5cclxuICAvLyBtYXRjaGVzIDAuMTU0LjIzLjQ1XHJcbiwgbnVtYmVyc1dpdGhEb3RzOiAgLygoXFxkP1xcLlxcZCsoPzplWystXT9cXGQrKT8pKCg/OlxcLlxcZCsoPzplWystXT9cXGQrKT8pKykpKy9naVxyXG5cclxuICAvLyBtYXRjaGVzIC5cclxuLCBkb3RzOiAgICAgICAgICAgICAvXFwuL2dcclxufVxyXG5cblNWRy51dGlscyA9IHtcclxuICAvLyBNYXAgZnVuY3Rpb25cclxuICBtYXA6IGZ1bmN0aW9uKGFycmF5LCBibG9jaykge1xyXG4gICAgdmFyIGlcclxuICAgICAgLCBpbCA9IGFycmF5Lmxlbmd0aFxyXG4gICAgICAsIHJlc3VsdCA9IFtdXHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgIHJlc3VsdC5wdXNoKGJsb2NrKGFycmF5W2ldKSlcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICAvLyBGaWx0ZXIgZnVuY3Rpb25cclxuLCBmaWx0ZXI6IGZ1bmN0aW9uKGFycmF5LCBibG9jaykge1xyXG4gICAgdmFyIGlcclxuICAgICAgLCBpbCA9IGFycmF5Lmxlbmd0aFxyXG4gICAgICAsIHJlc3VsdCA9IFtdXHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgIGlmIChibG9jayhhcnJheVtpXSkpXHJcbiAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pXHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgLy8gRGVncmVlcyB0byByYWRpYW5zXHJcbiwgcmFkaWFuczogZnVuY3Rpb24oZCkge1xyXG4gICAgcmV0dXJuIGQgJSAzNjAgKiBNYXRoLlBJIC8gMTgwXHJcbiAgfVxyXG5cclxuICAvLyBSYWRpYW5zIHRvIGRlZ3JlZXNcclxuLCBkZWdyZWVzOiBmdW5jdGlvbihyKSB7XHJcbiAgICByZXR1cm4gciAqIDE4MCAvIE1hdGguUEkgJSAzNjBcclxuICB9XHJcblxyXG4sIGZpbHRlclNWR0VsZW1lbnRzOiBmdW5jdGlvbihub2Rlcykge1xyXG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKCBub2RlcywgZnVuY3Rpb24oZWwpIHsgcmV0dXJuIGVsIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQgfSlcclxuICB9XHJcblxyXG59XG5cclxuU1ZHLmRlZmF1bHRzID0ge1xyXG4gIC8vIERlZmF1bHQgYXR0cmlidXRlIHZhbHVlc1xyXG4gIGF0dHJzOiB7XHJcbiAgICAvLyBmaWxsIGFuZCBzdHJva2VcclxuICAgICdmaWxsLW9wYWNpdHknOiAgICAgMVxyXG4gICwgJ3N0cm9rZS1vcGFjaXR5JzogICAxXHJcbiAgLCAnc3Ryb2tlLXdpZHRoJzogICAgIDBcclxuICAsICdzdHJva2UtbGluZWpvaW4nOiAgJ21pdGVyJ1xyXG4gICwgJ3N0cm9rZS1saW5lY2FwJzogICAnYnV0dCdcclxuICAsIGZpbGw6ICAgICAgICAgICAgICAgJyMwMDAwMDAnXHJcbiAgLCBzdHJva2U6ICAgICAgICAgICAgICcjMDAwMDAwJ1xyXG4gICwgb3BhY2l0eTogICAgICAgICAgICAxXHJcbiAgICAvLyBwb3NpdGlvblxyXG4gICwgeDogICAgICAgICAgICAgICAgICAwXHJcbiAgLCB5OiAgICAgICAgICAgICAgICAgIDBcclxuICAsIGN4OiAgICAgICAgICAgICAgICAgMFxyXG4gICwgY3k6ICAgICAgICAgICAgICAgICAwXHJcbiAgICAvLyBzaXplXHJcbiAgLCB3aWR0aDogICAgICAgICAgICAgIDBcclxuICAsIGhlaWdodDogICAgICAgICAgICAgMFxyXG4gICAgLy8gcmFkaXVzXHJcbiAgLCByOiAgICAgICAgICAgICAgICAgIDBcclxuICAsIHJ4OiAgICAgICAgICAgICAgICAgMFxyXG4gICwgcnk6ICAgICAgICAgICAgICAgICAwXHJcbiAgICAvLyBncmFkaWVudFxyXG4gICwgb2Zmc2V0OiAgICAgICAgICAgICAwXHJcbiAgLCAnc3RvcC1vcGFjaXR5JzogICAgIDFcclxuICAsICdzdG9wLWNvbG9yJzogICAgICAgJyMwMDAwMDAnXHJcbiAgICAvLyB0ZXh0XHJcbiAgLCAnZm9udC1zaXplJzogICAgICAgIDE2XHJcbiAgLCAnZm9udC1mYW1pbHknOiAgICAgICdIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmJ1xyXG4gICwgJ3RleHQtYW5jaG9yJzogICAgICAnc3RhcnQnXHJcbiAgfVxyXG5cclxufVxuLy8gTW9kdWxlIGZvciBjb2xvciBjb252ZXJ0aW9uc1xyXG5TVkcuQ29sb3IgPSBmdW5jdGlvbihjb2xvcikge1xyXG4gIHZhciBtYXRjaFxyXG5cclxuICAvLyBpbml0aWFsaXplIGRlZmF1bHRzXHJcbiAgdGhpcy5yID0gMFxyXG4gIHRoaXMuZyA9IDBcclxuICB0aGlzLmIgPSAwXHJcblxyXG4gIGlmKCFjb2xvcikgcmV0dXJuXHJcblxyXG4gIC8vIHBhcnNlIGNvbG9yXHJcbiAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcclxuICAgIGlmIChTVkcucmVnZXguaXNSZ2IudGVzdChjb2xvcikpIHtcclxuICAgICAgLy8gZ2V0IHJnYiB2YWx1ZXNcclxuICAgICAgbWF0Y2ggPSBTVkcucmVnZXgucmdiLmV4ZWMoY29sb3IucmVwbGFjZShTVkcucmVnZXgud2hpdGVzcGFjZSwnJykpXHJcblxyXG4gICAgICAvLyBwYXJzZSBudW1lcmljIHZhbHVlc1xyXG4gICAgICB0aGlzLnIgPSBwYXJzZUludChtYXRjaFsxXSlcclxuICAgICAgdGhpcy5nID0gcGFyc2VJbnQobWF0Y2hbMl0pXHJcbiAgICAgIHRoaXMuYiA9IHBhcnNlSW50KG1hdGNoWzNdKVxyXG5cclxuICAgIH0gZWxzZSBpZiAoU1ZHLnJlZ2V4LmlzSGV4LnRlc3QoY29sb3IpKSB7XHJcbiAgICAgIC8vIGdldCBoZXggdmFsdWVzXHJcbiAgICAgIG1hdGNoID0gU1ZHLnJlZ2V4LmhleC5leGVjKGZ1bGxIZXgoY29sb3IpKVxyXG5cclxuICAgICAgLy8gcGFyc2UgbnVtZXJpYyB2YWx1ZXNcclxuICAgICAgdGhpcy5yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDE2KVxyXG4gICAgICB0aGlzLmcgPSBwYXJzZUludChtYXRjaFsyXSwgMTYpXHJcbiAgICAgIHRoaXMuYiA9IHBhcnNlSW50KG1hdGNoWzNdLCAxNilcclxuXHJcbiAgICB9XHJcblxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbG9yID09PSAnb2JqZWN0Jykge1xyXG4gICAgdGhpcy5yID0gY29sb3IuclxyXG4gICAgdGhpcy5nID0gY29sb3IuZ1xyXG4gICAgdGhpcy5iID0gY29sb3IuYlxyXG5cclxuICB9XHJcblxyXG59XHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5Db2xvciwge1xyXG4gIC8vIERlZmF1bHQgdG8gaGV4IGNvbnZlcnNpb25cclxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b0hleCgpXHJcbiAgfVxyXG4gIC8vIEJ1aWxkIGhleCB2YWx1ZVxyXG4sIHRvSGV4OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAnIydcclxuICAgICAgKyBjb21wVG9IZXgodGhpcy5yKVxyXG4gICAgICArIGNvbXBUb0hleCh0aGlzLmcpXHJcbiAgICAgICsgY29tcFRvSGV4KHRoaXMuYilcclxuICB9XHJcbiAgLy8gQnVpbGQgcmdiIHZhbHVlXHJcbiwgdG9SZ2I6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICdyZ2IoJyArIFt0aGlzLnIsIHRoaXMuZywgdGhpcy5iXS5qb2luKCkgKyAnKSdcclxuICB9XHJcbiAgLy8gQ2FsY3VsYXRlIHRydWUgYnJpZ2h0bmVzc1xyXG4sIGJyaWdodG5lc3M6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLnIgLyAyNTUgKiAwLjMwKVxyXG4gICAgICAgICArICh0aGlzLmcgLyAyNTUgKiAwLjU5KVxyXG4gICAgICAgICArICh0aGlzLmIgLyAyNTUgKiAwLjExKVxyXG4gIH1cclxuICAvLyBNYWtlIGNvbG9yIG1vcnBoYWJsZVxyXG4sIG1vcnBoOiBmdW5jdGlvbihjb2xvcikge1xyXG4gICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuQ29sb3IoY29sb3IpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgLy8gR2V0IG1vcnBoZWQgY29sb3IgYXQgZ2l2ZW4gcG9zaXRpb25cclxuLCBhdDogZnVuY3Rpb24ocG9zKSB7XHJcbiAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXHJcbiAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzXHJcblxyXG4gICAgLy8gbm9ybWFsaXNlIHBvc1xyXG4gICAgcG9zID0gcG9zIDwgMCA/IDAgOiBwb3MgPiAxID8gMSA6IHBvc1xyXG5cclxuICAgIC8vIGdlbmVyYXRlIG1vcnBoZWQgY29sb3JcclxuICAgIHJldHVybiBuZXcgU1ZHLkNvbG9yKHtcclxuICAgICAgcjogfn4odGhpcy5yICsgKHRoaXMuZGVzdGluYXRpb24uciAtIHRoaXMucikgKiBwb3MpXHJcbiAgICAsIGc6IH5+KHRoaXMuZyArICh0aGlzLmRlc3RpbmF0aW9uLmcgLSB0aGlzLmcpICogcG9zKVxyXG4gICAgLCBiOiB+fih0aGlzLmIgKyAodGhpcy5kZXN0aW5hdGlvbi5iIC0gdGhpcy5iKSAqIHBvcylcclxuICAgIH0pXHJcbiAgfVxyXG5cclxufSlcclxuXHJcbi8vIFRlc3RlcnNcclxuXHJcbi8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYSBjb2xvciBzdHJpbmdcclxuU1ZHLkNvbG9yLnRlc3QgPSBmdW5jdGlvbihjb2xvcikge1xyXG4gIGNvbG9yICs9ICcnXHJcbiAgcmV0dXJuIFNWRy5yZWdleC5pc0hleC50ZXN0KGNvbG9yKVxyXG4gICAgICB8fCBTVkcucmVnZXguaXNSZ2IudGVzdChjb2xvcilcclxufVxyXG5cclxuLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhIHJnYiBvYmplY3RcclxuU1ZHLkNvbG9yLmlzUmdiID0gZnVuY3Rpb24oY29sb3IpIHtcclxuICByZXR1cm4gY29sb3IgJiYgdHlwZW9mIGNvbG9yLnIgPT0gJ251bWJlcidcclxuICAgICAgICAgICAgICAgJiYgdHlwZW9mIGNvbG9yLmcgPT0gJ251bWJlcidcclxuICAgICAgICAgICAgICAgJiYgdHlwZW9mIGNvbG9yLmIgPT0gJ251bWJlcidcclxufVxyXG5cclxuLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhIGNvbG9yXHJcblNWRy5Db2xvci5pc0NvbG9yID0gZnVuY3Rpb24oY29sb3IpIHtcclxuICByZXR1cm4gU1ZHLkNvbG9yLmlzUmdiKGNvbG9yKSB8fCBTVkcuQ29sb3IudGVzdChjb2xvcilcclxufVxuLy8gTW9kdWxlIGZvciBhcnJheSBjb252ZXJzaW9uXHJcblNWRy5BcnJheSA9IGZ1bmN0aW9uKGFycmF5LCBmYWxsYmFjaykge1xyXG4gIGFycmF5ID0gKGFycmF5IHx8IFtdKS52YWx1ZU9mKClcclxuXHJcbiAgLy8gaWYgYXJyYXkgaXMgZW1wdHkgYW5kIGZhbGxiYWNrIGlzIHByb3ZpZGVkLCB1c2UgZmFsbGJhY2tcclxuICBpZiAoYXJyYXkubGVuZ3RoID09IDAgJiYgZmFsbGJhY2spXHJcbiAgICBhcnJheSA9IGZhbGxiYWNrLnZhbHVlT2YoKVxyXG5cclxuICAvLyBwYXJzZSBhcnJheVxyXG4gIHRoaXMudmFsdWUgPSB0aGlzLnBhcnNlKGFycmF5KVxyXG59XHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5BcnJheSwge1xyXG4gIC8vIE1ha2UgYXJyYXkgbW9ycGhhYmxlXHJcbiAgbW9ycGg6IGZ1bmN0aW9uKGFycmF5KSB7XHJcbiAgICB0aGlzLmRlc3RpbmF0aW9uID0gdGhpcy5wYXJzZShhcnJheSlcclxuXHJcbiAgICAvLyBub3JtYWxpemUgbGVuZ3RoIG9mIGFycmF5c1xyXG4gICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoICE9IHRoaXMuZGVzdGluYXRpb24ubGVuZ3RoKSB7XHJcbiAgICAgIHZhciBsYXN0VmFsdWUgICAgICAgPSB0aGlzLnZhbHVlW3RoaXMudmFsdWUubGVuZ3RoIC0gMV1cclxuICAgICAgICAsIGxhc3REZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb25bdGhpcy5kZXN0aW5hdGlvbi5sZW5ndGggLSAxXVxyXG5cclxuICAgICAgd2hpbGUodGhpcy52YWx1ZS5sZW5ndGggPiB0aGlzLmRlc3RpbmF0aW9uLmxlbmd0aClcclxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLnB1c2gobGFzdERlc3RpbmF0aW9uKVxyXG4gICAgICB3aGlsZSh0aGlzLnZhbHVlLmxlbmd0aCA8IHRoaXMuZGVzdGluYXRpb24ubGVuZ3RoKVxyXG4gICAgICAgIHRoaXMudmFsdWUucHVzaChsYXN0VmFsdWUpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgLy8gQ2xlYW4gdXAgYW55IGR1cGxpY2F0ZSBwb2ludHNcclxuLCBzZXR0bGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gZmluZCBhbGwgdW5pcXVlIHZhbHVlc1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy52YWx1ZS5sZW5ndGgsIHNlZW4gPSBbXTsgaSA8IGlsOyBpKyspXHJcbiAgICAgIGlmIChzZWVuLmluZGV4T2YodGhpcy52YWx1ZVtpXSkgPT0gLTEpXHJcbiAgICAgICAgc2Vlbi5wdXNoKHRoaXMudmFsdWVbaV0pXHJcblxyXG4gICAgLy8gc2V0IG5ldyB2YWx1ZVxyXG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPSBzZWVuXHJcbiAgfVxyXG4gIC8vIEdldCBtb3JwaGVkIGFycmF5IGF0IGdpdmVuIHBvc2l0aW9uXHJcbiwgYXQ6IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxyXG4gICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpc1xyXG5cclxuICAgIC8vIGdlbmVyYXRlIG1vcnBoZWQgYXJyYXlcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMudmFsdWUubGVuZ3RoLCBhcnJheSA9IFtdOyBpIDwgaWw7IGkrKylcclxuICAgICAgYXJyYXkucHVzaCh0aGlzLnZhbHVlW2ldICsgKHRoaXMuZGVzdGluYXRpb25baV0gLSB0aGlzLnZhbHVlW2ldKSAqIHBvcylcclxuXHJcbiAgICByZXR1cm4gbmV3IFNWRy5BcnJheShhcnJheSlcclxuICB9XHJcbiAgLy8gQ29udmVydCBhcnJheSB0byBzdHJpbmdcclxuLCB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5qb2luKCcgJylcclxuICB9XHJcbiAgLy8gUmVhbCB2YWx1ZVxyXG4sIHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmFsdWVcclxuICB9XHJcbiAgLy8gUGFyc2Ugd2hpdGVzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nXHJcbiwgcGFyc2U6IGZ1bmN0aW9uKGFycmF5KSB7XHJcbiAgICBhcnJheSA9IGFycmF5LnZhbHVlT2YoKVxyXG5cclxuICAgIC8vIGlmIGFscmVhZHkgaXMgYW4gYXJyYXksIG5vIG5lZWQgdG8gcGFyc2UgaXRcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkgcmV0dXJuIGFycmF5XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc3BsaXQoYXJyYXkpXHJcbiAgfVxyXG4gIC8vIFN0cmlwIHVubmVjZXNzYXJ5IHdoaXRlc3BhY2VcclxuLCBzcGxpdDogZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gc3RyaW5nLnRyaW0oKS5zcGxpdChTVkcucmVnZXguZGVsaW1pdGVyKS5tYXAocGFyc2VGbG9hdClcclxuICB9XHJcbiAgLy8gUmV2ZXJzZSBhcnJheVxyXG4sIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy52YWx1ZS5yZXZlcnNlKClcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuLCBjbG9uZTogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY2xvbmUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpXHJcbiAgICBjbG9uZS52YWx1ZSA9IGFycmF5X2Nsb25lKHRoaXMudmFsdWUpXHJcbiAgICByZXR1cm4gY2xvbmVcclxuICB9XHJcbn0pXG4vLyBQb2x5IHBvaW50cyBhcnJheVxyXG5TVkcuUG9pbnRBcnJheSA9IGZ1bmN0aW9uKGFycmF5LCBmYWxsYmFjaykge1xyXG4gIFNWRy5BcnJheS5jYWxsKHRoaXMsIGFycmF5LCBmYWxsYmFjayB8fCBbWzAsMF1dKVxyXG59XHJcblxyXG4vLyBJbmhlcml0IGZyb20gU1ZHLkFycmF5XHJcblNWRy5Qb2ludEFycmF5LnByb3RvdHlwZSA9IG5ldyBTVkcuQXJyYXlcclxuU1ZHLlBvaW50QXJyYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU1ZHLlBvaW50QXJyYXlcclxuXHJcblNWRy5leHRlbmQoU1ZHLlBvaW50QXJyYXksIHtcclxuICAvLyBDb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xyXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgIC8vIGNvbnZlcnQgdG8gYSBwb2x5IHBvaW50IHN0cmluZ1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy52YWx1ZS5sZW5ndGgsIGFycmF5ID0gW107IGkgPCBpbDsgaSsrKVxyXG4gICAgICBhcnJheS5wdXNoKHRoaXMudmFsdWVbaV0uam9pbignLCcpKVxyXG5cclxuICAgIHJldHVybiBhcnJheS5qb2luKCcgJylcclxuICB9XHJcbiAgLy8gQ29udmVydCBhcnJheSB0byBsaW5lIG9iamVjdFxyXG4sIHRvTGluZTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4MTogdGhpcy52YWx1ZVswXVswXVxyXG4gICAgLCB5MTogdGhpcy52YWx1ZVswXVsxXVxyXG4gICAgLCB4MjogdGhpcy52YWx1ZVsxXVswXVxyXG4gICAgLCB5MjogdGhpcy52YWx1ZVsxXVsxXVxyXG4gICAgfVxyXG4gIH1cclxuICAvLyBHZXQgbW9ycGhlZCBhcnJheSBhdCBnaXZlbiBwb3NpdGlvblxyXG4sIGF0OiBmdW5jdGlvbihwb3MpIHtcclxuICAgIC8vIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcclxuICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXNcclxuXHJcbiAgICAvLyBnZW5lcmF0ZSBtb3JwaGVkIHBvaW50IHN0cmluZ1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy52YWx1ZS5sZW5ndGgsIGFycmF5ID0gW107IGkgPCBpbDsgaSsrKVxyXG4gICAgICBhcnJheS5wdXNoKFtcclxuICAgICAgICB0aGlzLnZhbHVlW2ldWzBdICsgKHRoaXMuZGVzdGluYXRpb25baV1bMF0gLSB0aGlzLnZhbHVlW2ldWzBdKSAqIHBvc1xyXG4gICAgICAsIHRoaXMudmFsdWVbaV1bMV0gKyAodGhpcy5kZXN0aW5hdGlvbltpXVsxXSAtIHRoaXMudmFsdWVbaV1bMV0pICogcG9zXHJcbiAgICAgIF0pXHJcblxyXG4gICAgcmV0dXJuIG5ldyBTVkcuUG9pbnRBcnJheShhcnJheSlcclxuICB9XHJcbiAgLy8gUGFyc2UgcG9pbnQgc3RyaW5nIGFuZCBmbGF0IGFycmF5XHJcbiwgcGFyc2U6IGZ1bmN0aW9uKGFycmF5KSB7XHJcbiAgICB2YXIgcG9pbnRzID0gW11cclxuXHJcbiAgICBhcnJheSA9IGFycmF5LnZhbHVlT2YoKVxyXG5cclxuICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcclxuICAgICAgLy8gYW5kIGl0IGlzIG5vdCBmbGF0LCB0aGVyZSBpcyBubyBuZWVkIHRvIHBhcnNlIGl0XHJcbiAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJyYXlbMF0pKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7IC8vIEVsc2UsIGl0IGlzIGNvbnNpZGVyZWQgYXMgYSBzdHJpbmdcclxuICAgICAgLy8gcGFyc2UgcG9pbnRzXHJcbiAgICAgIGFycmF5ID0gYXJyYXkudHJpbSgpLnNwbGl0KFNWRy5yZWdleC5kZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHZhbGlkYXRlIHBvaW50cyAtIGh0dHBzOi8vc3Znd2cub3JnL3N2ZzItZHJhZnQvc2hhcGVzLmh0bWwjRGF0YVR5cGVQb2ludHNcclxuICAgIC8vIE9kZCBudW1iZXIgb2YgY29vcmRpbmF0ZXMgaXMgYW4gZXJyb3IuIEluIHN1Y2ggY2FzZXMsIGRyb3AgdGhlIGxhc3Qgb2RkIGNvb3JkaW5hdGUuXHJcbiAgICBpZiAoYXJyYXkubGVuZ3RoICUgMiAhPT0gMCkgYXJyYXkucG9wKClcclxuXHJcbiAgICAvLyB3cmFwIHBvaW50cyBpbiB0d28tdHVwbGVzIGFuZCBwYXJzZSBwb2ludHMgYXMgZmxvYXRzXHJcbiAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkgPSBpICsgMilcclxuICAgICAgcG9pbnRzLnB1c2goWyBhcnJheVtpXSwgYXJyYXlbaSsxXSBdKVxyXG5cclxuICAgIHJldHVybiBwb2ludHNcclxuICB9XHJcbiAgLy8gTW92ZSBwb2ludCBzdHJpbmdcclxuLCBtb3ZlOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB2YXIgYm94ID0gdGhpcy5iYm94KClcclxuXHJcbiAgICAvLyBnZXQgcmVsYXRpdmUgb2Zmc2V0XHJcbiAgICB4IC09IGJveC54XHJcbiAgICB5IC09IGJveC55XHJcblxyXG4gICAgLy8gbW92ZSBldmVyeSBwb2ludFxyXG4gICAgaWYgKCFpc05hTih4KSAmJiAhaXNOYU4oeSkpXHJcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgIHRoaXMudmFsdWVbaV0gPSBbdGhpcy52YWx1ZVtpXVswXSArIHgsIHRoaXMudmFsdWVbaV1bMV0gKyB5XVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIFJlc2l6ZSBwb2x5IHN0cmluZ1xyXG4sIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHZhciBpLCBib3ggPSB0aGlzLmJib3goKVxyXG5cclxuICAgIC8vIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9mIGFsbCBwb2ludHMgYWNjb3JkaW5nIHRvIG5ldyBzaXplXHJcbiAgICBmb3IgKGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGlmKGJveC53aWR0aCkgdGhpcy52YWx1ZVtpXVswXSA9ICgodGhpcy52YWx1ZVtpXVswXSAtIGJveC54KSAqIHdpZHRoKSAgLyBib3gud2lkdGggICsgYm94LnhcclxuICAgICAgaWYoYm94LmhlaWdodCkgdGhpcy52YWx1ZVtpXVsxXSA9ICgodGhpcy52YWx1ZVtpXVsxXSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICAvLyBHZXQgYm91bmRpbmcgYm94IG9mIHBvaW50c1xyXG4sIGJib3g6IGZ1bmN0aW9uKCkge1xyXG4gICAgU1ZHLnBhcnNlci5wb2x5LnNldEF0dHJpYnV0ZSgncG9pbnRzJywgdGhpcy50b1N0cmluZygpKVxyXG5cclxuICAgIHJldHVybiBTVkcucGFyc2VyLnBvbHkuZ2V0QkJveCgpXHJcbiAgfVxyXG59KVxyXG5cbnZhciBwYXRoSGFuZGxlcnMgPSB7XHJcbiAgTTogZnVuY3Rpb24oYywgcCwgcDApIHtcclxuICAgIHAueCA9IHAwLnggPSBjWzBdXHJcbiAgICBwLnkgPSBwMC55ID0gY1sxXVxyXG5cclxuICAgIHJldHVybiBbJ00nLCBwLngsIHAueV1cclxuICB9LFxyXG4gIEw6IGZ1bmN0aW9uKGMsIHApIHtcclxuICAgIHAueCA9IGNbMF1cclxuICAgIHAueSA9IGNbMV1cclxuICAgIHJldHVybiBbJ0wnLCBjWzBdLCBjWzFdXVxyXG4gIH0sXHJcbiAgSDogZnVuY3Rpb24oYywgcCkge1xyXG4gICAgcC54ID0gY1swXVxyXG4gICAgcmV0dXJuIFsnSCcsIGNbMF1dXHJcbiAgfSxcclxuICBWOiBmdW5jdGlvbihjLCBwKSB7XHJcbiAgICBwLnkgPSBjWzBdXHJcbiAgICByZXR1cm4gWydWJywgY1swXV1cclxuICB9LFxyXG4gIEM6IGZ1bmN0aW9uKGMsIHApIHtcclxuICAgIHAueCA9IGNbNF1cclxuICAgIHAueSA9IGNbNV1cclxuICAgIHJldHVybiBbJ0MnLCBjWzBdLCBjWzFdLCBjWzJdLCBjWzNdLCBjWzRdLCBjWzVdXVxyXG4gIH0sXHJcbiAgUzogZnVuY3Rpb24oYywgcCkge1xyXG4gICAgcC54ID0gY1syXVxyXG4gICAgcC55ID0gY1szXVxyXG4gICAgcmV0dXJuIFsnUycsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM11dXHJcbiAgfSxcclxuICBROiBmdW5jdGlvbihjLCBwKSB7XHJcbiAgICBwLnggPSBjWzJdXHJcbiAgICBwLnkgPSBjWzNdXHJcbiAgICByZXR1cm4gWydRJywgY1swXSwgY1sxXSwgY1syXSwgY1szXV1cclxuICB9LFxyXG4gIFQ6IGZ1bmN0aW9uKGMsIHApIHtcclxuICAgIHAueCA9IGNbMF1cclxuICAgIHAueSA9IGNbMV1cclxuICAgIHJldHVybiBbJ1QnLCBjWzBdLCBjWzFdXVxyXG4gIH0sXHJcbiAgWjogZnVuY3Rpb24oYywgcCwgcDApIHtcclxuICAgIHAueCA9IHAwLnhcclxuICAgIHAueSA9IHAwLnlcclxuICAgIHJldHVybiBbJ1onXVxyXG4gIH0sXHJcbiAgQTogZnVuY3Rpb24oYywgcCkge1xyXG4gICAgcC54ID0gY1s1XVxyXG4gICAgcC55ID0gY1s2XVxyXG4gICAgcmV0dXJuIFsnQScsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM10sIGNbNF0sIGNbNV0sIGNbNl1dXHJcbiAgfVxyXG59XHJcblxyXG52YXIgbWxodnF0Y3NhID0gJ21saHZxdGNzYXonLnNwbGl0KCcnKVxyXG5cclxuZm9yKHZhciBpID0gMCwgaWwgPSBtbGh2cXRjc2EubGVuZ3RoOyBpIDwgaWw7ICsraSl7XHJcbiAgcGF0aEhhbmRsZXJzW21saHZxdGNzYVtpXV0gPSAoZnVuY3Rpb24oaSl7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oYywgcCwgcDApIHtcclxuICAgICAgaWYoaSA9PSAnSCcpIGNbMF0gPSBjWzBdICsgcC54XHJcbiAgICAgIGVsc2UgaWYoaSA9PSAnVicpIGNbMF0gPSBjWzBdICsgcC55XHJcbiAgICAgIGVsc2UgaWYoaSA9PSAnQScpe1xyXG4gICAgICAgIGNbNV0gPSBjWzVdICsgcC54LFxyXG4gICAgICAgIGNbNl0gPSBjWzZdICsgcC55XHJcbiAgICAgIH1cclxuICAgICAgZWxzZVxyXG4gICAgICAgIGZvcih2YXIgaiA9IDAsIGpsID0gYy5sZW5ndGg7IGogPCBqbDsgKytqKSB7XHJcbiAgICAgICAgICBjW2pdID0gY1tqXSArIChqJTIgPyBwLnkgOiBwLngpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHBhdGhIYW5kbGVyc1tpXShjLCBwLCBwMClcclxuICAgIH1cclxuICB9KShtbGh2cXRjc2FbaV0udG9VcHBlckNhc2UoKSlcclxufVxyXG5cclxuLy8gUGF0aCBwb2ludHMgYXJyYXlcclxuU1ZHLlBhdGhBcnJheSA9IGZ1bmN0aW9uKGFycmF5LCBmYWxsYmFjaykge1xyXG4gIFNWRy5BcnJheS5jYWxsKHRoaXMsIGFycmF5LCBmYWxsYmFjayB8fCBbWydNJywgMCwgMF1dKVxyXG59XHJcblxyXG4vLyBJbmhlcml0IGZyb20gU1ZHLkFycmF5XHJcblNWRy5QYXRoQXJyYXkucHJvdG90eXBlID0gbmV3IFNWRy5BcnJheVxyXG5TVkcuUGF0aEFycmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWRy5QYXRoQXJyYXlcclxuXHJcblNWRy5leHRlbmQoU1ZHLlBhdGhBcnJheSwge1xyXG4gIC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXHJcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGFycmF5VG9TdHJpbmcodGhpcy52YWx1ZSlcclxuICB9XHJcbiAgLy8gTW92ZSBwYXRoIHN0cmluZ1xyXG4sIG1vdmU6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIC8vIGdldCBib3VuZGluZyBib3ggb2YgY3VycmVudCBzaXR1YXRpb25cclxuICAgIHZhciBib3ggPSB0aGlzLmJib3goKVxyXG5cclxuICAgIC8vIGdldCByZWxhdGl2ZSBvZmZzZXRcclxuICAgIHggLT0gYm94LnhcclxuICAgIHkgLT0gYm94LnlcclxuXHJcbiAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSkge1xyXG4gICAgICAvLyBtb3ZlIGV2ZXJ5IHBvaW50XHJcbiAgICAgIGZvciAodmFyIGwsIGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgbCA9IHRoaXMudmFsdWVbaV1bMF1cclxuXHJcbiAgICAgICAgaWYgKGwgPT0gJ00nIHx8IGwgPT0gJ0wnIHx8IGwgPT0gJ1QnKSAge1xyXG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSArPSB4XHJcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzJdICs9IHlcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChsID09ICdIJykgIHtcclxuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gKz0geFxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKGwgPT0gJ1YnKSAge1xyXG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSArPSB5XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAobCA9PSAnQycgfHwgbCA9PSAnUycgfHwgbCA9PSAnUScpICB7XHJcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdICs9IHhcclxuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMl0gKz0geVxyXG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVszXSArPSB4XHJcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzRdICs9IHlcclxuXHJcbiAgICAgICAgICBpZiAobCA9PSAnQycpICB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVbaV1bNV0gKz0geFxyXG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzZdICs9IHlcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChsID09ICdBJykgIHtcclxuICAgICAgICAgIHRoaXMudmFsdWVbaV1bNl0gKz0geFxyXG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVs3XSArPSB5XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIFJlc2l6ZSBwYXRoIHN0cmluZ1xyXG4sIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIC8vIGdldCBib3VuZGluZyBib3ggb2YgY3VycmVudCBzaXR1YXRpb25cclxuICAgIHZhciBpLCBsLCBib3ggPSB0aGlzLmJib3goKVxyXG5cclxuICAgIC8vIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9mIGFsbCBwb2ludHMgYWNjb3JkaW5nIHRvIG5ldyBzaXplXHJcbiAgICBmb3IgKGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGwgPSB0aGlzLnZhbHVlW2ldWzBdXHJcblxyXG4gICAgICBpZiAobCA9PSAnTScgfHwgbCA9PSAnTCcgfHwgbCA9PSAnVCcpICB7XHJcbiAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSA9ICgodGhpcy52YWx1ZVtpXVsxXSAtIGJveC54KSAqIHdpZHRoKSAgLyBib3gud2lkdGggICsgYm94LnhcclxuICAgICAgICB0aGlzLnZhbHVlW2ldWzJdID0gKCh0aGlzLnZhbHVlW2ldWzJdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxyXG5cclxuICAgICAgfSBlbHNlIGlmIChsID09ICdIJykgIHtcclxuICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKCh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LngpICogd2lkdGgpICAvIGJveC53aWR0aCAgKyBib3gueFxyXG5cclxuICAgICAgfSBlbHNlIGlmIChsID09ICdWJykgIHtcclxuICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKCh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxyXG5cclxuICAgICAgfSBlbHNlIGlmIChsID09ICdDJyB8fCBsID09ICdTJyB8fCBsID09ICdRJykgIHtcclxuICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKCh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LngpICogd2lkdGgpICAvIGJveC53aWR0aCAgKyBib3gueFxyXG4gICAgICAgIHRoaXMudmFsdWVbaV1bMl0gPSAoKHRoaXMudmFsdWVbaV1bMl0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XHJcbiAgICAgICAgdGhpcy52YWx1ZVtpXVszXSA9ICgodGhpcy52YWx1ZVtpXVszXSAtIGJveC54KSAqIHdpZHRoKSAgLyBib3gud2lkdGggICsgYm94LnhcclxuICAgICAgICB0aGlzLnZhbHVlW2ldWzRdID0gKCh0aGlzLnZhbHVlW2ldWzRdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxyXG5cclxuICAgICAgICBpZiAobCA9PSAnQycpICB7XHJcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzVdID0gKCh0aGlzLnZhbHVlW2ldWzVdIC0gYm94LngpICogd2lkdGgpICAvIGJveC53aWR0aCAgKyBib3gueFxyXG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVs2XSA9ICgodGhpcy52YWx1ZVtpXVs2XSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKGwgPT0gJ0EnKSAge1xyXG4gICAgICAgIC8vIHJlc2l6ZSByYWRpaVxyXG4gICAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSAodGhpcy52YWx1ZVtpXVsxXSAqIHdpZHRoKSAgLyBib3gud2lkdGhcclxuICAgICAgICB0aGlzLnZhbHVlW2ldWzJdID0gKHRoaXMudmFsdWVbaV1bMl0gKiBoZWlnaHQpIC8gYm94LmhlaWdodFxyXG5cclxuICAgICAgICAvLyBtb3ZlIHBvc2l0aW9uIHZhbHVlc1xyXG4gICAgICAgIHRoaXMudmFsdWVbaV1bNl0gPSAoKHRoaXMudmFsdWVbaV1bNl0gLSBib3gueCkgKiB3aWR0aCkgIC8gYm94LndpZHRoICArIGJveC54XHJcbiAgICAgICAgdGhpcy52YWx1ZVtpXVs3XSA9ICgodGhpcy52YWx1ZVtpXVs3XSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcclxuICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICAvLyBUZXN0IGlmIHRoZSBwYXNzZWQgcGF0aCBhcnJheSB1c2UgdGhlIHNhbWUgcGF0aCBkYXRhIGNvbW1hbmRzIGFzIHRoaXMgcGF0aCBhcnJheVxyXG4sIGVxdWFsQ29tbWFuZHM6IGZ1bmN0aW9uKHBhdGhBcnJheSkge1xyXG4gICAgdmFyIGksIGlsLCBlcXVhbENvbW1hbmRzXHJcblxyXG4gICAgcGF0aEFycmF5ID0gbmV3IFNWRy5QYXRoQXJyYXkocGF0aEFycmF5KVxyXG5cclxuICAgIGVxdWFsQ29tbWFuZHMgPSB0aGlzLnZhbHVlLmxlbmd0aCA9PT0gcGF0aEFycmF5LnZhbHVlLmxlbmd0aFxyXG4gICAgZm9yKGkgPSAwLCBpbCA9IHRoaXMudmFsdWUubGVuZ3RoOyBlcXVhbENvbW1hbmRzICYmIGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgIGVxdWFsQ29tbWFuZHMgPSB0aGlzLnZhbHVlW2ldWzBdID09PSBwYXRoQXJyYXkudmFsdWVbaV1bMF1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXF1YWxDb21tYW5kc1xyXG4gIH1cclxuICAvLyBNYWtlIHBhdGggYXJyYXkgbW9ycGhhYmxlXHJcbiwgbW9ycGg6IGZ1bmN0aW9uKHBhdGhBcnJheSkge1xyXG4gICAgcGF0aEFycmF5ID0gbmV3IFNWRy5QYXRoQXJyYXkocGF0aEFycmF5KVxyXG5cclxuICAgIGlmKHRoaXMuZXF1YWxDb21tYW5kcyhwYXRoQXJyYXkpKSB7XHJcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBwYXRoQXJyYXlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBudWxsXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgLy8gR2V0IG1vcnBoZWQgcGF0aCBhcnJheSBhdCBnaXZlbiBwb3NpdGlvblxyXG4sIGF0OiBmdW5jdGlvbihwb3MpIHtcclxuICAgIC8vIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcclxuICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXNcclxuXHJcbiAgICB2YXIgc291cmNlQXJyYXkgPSB0aGlzLnZhbHVlXHJcbiAgICAgICwgZGVzdGluYXRpb25BcnJheSA9IHRoaXMuZGVzdGluYXRpb24udmFsdWVcclxuICAgICAgLCBhcnJheSA9IFtdLCBwYXRoQXJyYXkgPSBuZXcgU1ZHLlBhdGhBcnJheSgpXHJcbiAgICAgICwgaSwgaWwsIGosIGpsXHJcblxyXG4gICAgLy8gQW5pbWF0ZSBoYXMgc3BlY2lmaWVkIGluIHRoZSBTVkcgc3BlY1xyXG4gICAgLy8gU2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHMTEvcGF0aHMuaHRtbCNQYXRoRWxlbWVudFxyXG4gICAgZm9yIChpID0gMCwgaWwgPSBzb3VyY2VBcnJheS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgIGFycmF5W2ldID0gW3NvdXJjZUFycmF5W2ldWzBdXVxyXG4gICAgICBmb3IoaiA9IDEsIGpsID0gc291cmNlQXJyYXlbaV0ubGVuZ3RoOyBqIDwgamw7IGorKykge1xyXG4gICAgICAgIGFycmF5W2ldW2pdID0gc291cmNlQXJyYXlbaV1bal0gKyAoZGVzdGluYXRpb25BcnJheVtpXVtqXSAtIHNvdXJjZUFycmF5W2ldW2pdKSAqIHBvc1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEZvciB0aGUgdHdvIGZsYWdzIG9mIHRoZSBlbGxpcHRpY2FsIGFyYyBjb21tYW5kLCB0aGUgU1ZHIHNwZWMgc2F5OlxyXG4gICAgICAvLyBGbGFncyBhbmQgYm9vbGVhbnMgYXJlIGludGVycG9sYXRlZCBhcyBmcmFjdGlvbnMgYmV0d2VlbiB6ZXJvIGFuZCBvbmUsIHdpdGggYW55IG5vbi16ZXJvIHZhbHVlIGNvbnNpZGVyZWQgdG8gYmUgYSB2YWx1ZSBvZiBvbmUvdHJ1ZVxyXG4gICAgICAvLyBFbGxpcHRpY2FsIGFyYyBjb21tYW5kIGFzIGFuIGFycmF5IGZvbGxvd2VkIGJ5IGNvcnJlc3BvbmRpbmcgaW5kZXhlczpcclxuICAgICAgLy8gWydBJywgcngsIHJ5LCB4LWF4aXMtcm90YXRpb24sIGxhcmdlLWFyYy1mbGFnLCBzd2VlcC1mbGFnLCB4LCB5XVxyXG4gICAgICAvLyAgIDAgICAgMSAgIDIgICAgICAgIDMgICAgICAgICAgICAgICAgIDQgICAgICAgICAgICAgNSAgICAgIDYgIDdcclxuICAgICAgaWYoYXJyYXlbaV1bMF0gPT09ICdBJykge1xyXG4gICAgICAgIGFycmF5W2ldWzRdID0gKyhhcnJheVtpXVs0XSAhPSAwKVxyXG4gICAgICAgIGFycmF5W2ldWzVdID0gKyhhcnJheVtpXVs1XSAhPSAwKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlyZWN0bHkgbW9kaWZ5IHRoZSB2YWx1ZSBvZiBhIHBhdGggYXJyYXksIHRoaXMgaXMgZG9uZSB0aGlzIHdheSBmb3IgcGVyZm9ybWFuY2VcclxuICAgIHBhdGhBcnJheS52YWx1ZSA9IGFycmF5XHJcbiAgICByZXR1cm4gcGF0aEFycmF5XHJcbiAgfVxyXG4gIC8vIEFic29sdXRpemUgYW5kIHBhcnNlIHBhdGggdG8gYXJyYXlcclxuLCBwYXJzZTogZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIC8vIGlmIGl0J3MgYWxyZWFkeSBhIHBhdGhhcnJheSwgbm8gbmVlZCB0byBwYXJzZSBpdFxyXG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgU1ZHLlBhdGhBcnJheSkgcmV0dXJuIGFycmF5LnZhbHVlT2YoKVxyXG5cclxuICAgIC8vIHByZXBhcmUgZm9yIHBhcnNpbmdcclxuICAgIHZhciBpLCB4MCwgeTAsIHMsIHNlZywgYXJyXHJcbiAgICAgICwgeCA9IDBcclxuICAgICAgLCB5ID0gMFxyXG4gICAgICAsIHBhcmFtQ250ID0geyAnTSc6MiwgJ0wnOjIsICdIJzoxLCAnVic6MSwgJ0MnOjYsICdTJzo0LCAnUSc6NCwgJ1QnOjIsICdBJzo3LCAnWic6MCB9XHJcblxyXG4gICAgaWYodHlwZW9mIGFycmF5ID09ICdzdHJpbmcnKXtcclxuXHJcbiAgICAgIGFycmF5ID0gYXJyYXlcclxuICAgICAgICAucmVwbGFjZShTVkcucmVnZXgubnVtYmVyc1dpdGhEb3RzLCBwYXRoUmVnUmVwbGFjZSkgLy8gY29udmVydCA0NS4xMjMuMTIzIHRvIDQ1LjEyMyAuMTIzXHJcbiAgICAgICAgLnJlcGxhY2UoU1ZHLnJlZ2V4LnBhdGhMZXR0ZXJzLCAnICQmICcpIC8vIHB1dCBzb21lIHJvb20gYmV0d2VlbiBsZXR0ZXJzIGFuZCBudW1iZXJzXHJcbiAgICAgICAgLnJlcGxhY2UoU1ZHLnJlZ2V4Lmh5cGhlbiwgJyQxIC0nKSAgICAgIC8vIGFkZCBzcGFjZSBiZWZvcmUgaHlwaGVuXHJcbiAgICAgICAgLnRyaW0oKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaW1cclxuICAgICAgICAuc3BsaXQoU1ZHLnJlZ2V4LmRlbGltaXRlcikgICAvLyBzcGxpdCBpbnRvIGFycmF5XHJcblxyXG4gICAgfWVsc2V7XHJcbiAgICAgIGFycmF5ID0gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cnIpe1xyXG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuY2FsbChwcmV2LCBjdXJyKVxyXG4gICAgICB9LCBbXSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBhcnJheSBub3cgaXMgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgcGFydHMgb2YgYSBwYXRoIGUuZy4gWydNJywgJzAnLCAnMCcsICdMJywgJzMwJywgJzMwJyAuLi5dXHJcbiAgICB2YXIgYXJyID0gW11cclxuICAgICAgLCBwID0gbmV3IFNWRy5Qb2ludCgpXHJcbiAgICAgICwgcDAgPSBuZXcgU1ZHLlBvaW50KClcclxuICAgICAgLCBpbmRleCA9IDBcclxuICAgICAgLCBsZW4gPSBhcnJheS5sZW5ndGhcclxuXHJcbiAgICBkb3tcclxuICAgICAgLy8gVGVzdCBpZiB3ZSBoYXZlIGEgcGF0aCBsZXR0ZXJcclxuICAgICAgaWYoU1ZHLnJlZ2V4LmlzUGF0aExldHRlci50ZXN0KGFycmF5W2luZGV4XSkpe1xyXG4gICAgICAgIHMgPSBhcnJheVtpbmRleF1cclxuICAgICAgICArK2luZGV4XHJcbiAgICAgIC8vIElmIGxhc3QgbGV0dGVyIHdhcyBhIG1vdmUgY29tbWFuZCBhbmQgd2UgZ290IG5vIG5ldywgaXQgZGVmYXVsdHMgdG8gW0xdaW5lXHJcbiAgICAgIH1lbHNlIGlmKHMgPT0gJ00nKXtcclxuICAgICAgICBzID0gJ0wnXHJcbiAgICAgIH1lbHNlIGlmKHMgPT0gJ20nKXtcclxuICAgICAgICBzID0gJ2wnXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFyci5wdXNoKHBhdGhIYW5kbGVyc1tzXS5jYWxsKG51bGwsXHJcbiAgICAgICAgICBhcnJheS5zbGljZShpbmRleCwgKGluZGV4ID0gaW5kZXggKyBwYXJhbUNudFtzLnRvVXBwZXJDYXNlKCldKSkubWFwKHBhcnNlRmxvYXQpLFxyXG4gICAgICAgICAgcCwgcDBcclxuICAgICAgICApXHJcbiAgICAgIClcclxuXHJcbiAgICB9d2hpbGUobGVuID4gaW5kZXgpXHJcblxyXG4gICAgcmV0dXJuIGFyclxyXG5cclxuICB9XHJcbiAgLy8gR2V0IGJvdW5kaW5nIGJveCBvZiBwYXRoXHJcbiwgYmJveDogZnVuY3Rpb24oKSB7XHJcbiAgICBTVkcucGFyc2VyLnBhdGguc2V0QXR0cmlidXRlKCdkJywgdGhpcy50b1N0cmluZygpKVxyXG5cclxuICAgIHJldHVybiBTVkcucGFyc2VyLnBhdGguZ2V0QkJveCgpXHJcbiAgfVxyXG5cclxufSlcclxuXG4vLyBNb2R1bGUgZm9yIHVuaXQgY29udmVydGlvbnNcclxuU1ZHLk51bWJlciA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKHZhbHVlLCB1bml0KSB7XHJcbiAgICAvLyBpbml0aWFsaXplIGRlZmF1bHRzXHJcbiAgICB0aGlzLnZhbHVlID0gMFxyXG4gICAgdGhpcy51bml0ICA9IHVuaXQgfHwgJydcclxuXHJcbiAgICAvLyBwYXJzZSB2YWx1ZVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgLy8gZW5zdXJlIGEgdmFsaWQgbnVtZXJpYyB2YWx1ZVxyXG4gICAgICB0aGlzLnZhbHVlID0gaXNOYU4odmFsdWUpID8gMCA6ICFpc0Zpbml0ZSh2YWx1ZSkgPyAodmFsdWUgPCAwID8gLTMuNGUrMzggOiArMy40ZSszOCkgOiB2YWx1ZVxyXG5cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICB1bml0ID0gdmFsdWUubWF0Y2goU1ZHLnJlZ2V4Lm51bWJlckFuZFVuaXQpXHJcblxyXG4gICAgICBpZiAodW5pdCkge1xyXG4gICAgICAgIC8vIG1ha2UgdmFsdWUgbnVtZXJpY1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBwYXJzZUZsb2F0KHVuaXRbMV0pXHJcblxyXG4gICAgICAgIC8vIG5vcm1hbGl6ZVxyXG4gICAgICAgIGlmICh1bml0WzVdID09ICclJylcclxuICAgICAgICAgIHRoaXMudmFsdWUgLz0gMTAwXHJcbiAgICAgICAgZWxzZSBpZiAodW5pdFs1XSA9PSAncycpXHJcbiAgICAgICAgICB0aGlzLnZhbHVlICo9IDEwMDBcclxuXHJcbiAgICAgICAgLy8gc3RvcmUgdW5pdFxyXG4gICAgICAgIHRoaXMudW5pdCA9IHVuaXRbNV1cclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNWRy5OdW1iZXIpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUudmFsdWVPZigpXHJcbiAgICAgICAgdGhpcy51bml0ICA9IHZhbHVlLnVuaXRcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICB9XHJcbiAgLy8gQWRkIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIFN0cmluZ2FsaXplXHJcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgdGhpcy51bml0ID09ICclJyA/XHJcbiAgICAgICAgICB+fih0aGlzLnZhbHVlICogMWU4KSAvIDFlNjpcclxuICAgICAgICB0aGlzLnVuaXQgPT0gJ3MnID9cclxuICAgICAgICAgIHRoaXMudmFsdWUgLyAxZTMgOlxyXG4gICAgICAgICAgdGhpcy52YWx1ZVxyXG4gICAgICApICsgdGhpcy51bml0XHJcbiAgICB9XHJcbiAgLCB0b0pTT046IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXHJcbiAgICB9XHJcbiAgLCAvLyBDb252ZXJ0IHRvIHByaW1pdGl2ZVxyXG4gICAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXHJcbiAgICB9XHJcbiAgICAvLyBBZGQgbnVtYmVyXHJcbiAgLCBwbHVzOiBmdW5jdGlvbihudW1iZXIpIHtcclxuICAgICAgbnVtYmVyID0gbmV3IFNWRy5OdW1iZXIobnVtYmVyKVxyXG4gICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcyArIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KVxyXG4gICAgfVxyXG4gICAgLy8gU3VidHJhY3QgbnVtYmVyXHJcbiAgLCBtaW51czogZnVuY3Rpb24obnVtYmVyKSB7XHJcbiAgICAgIG51bWJlciA9IG5ldyBTVkcuTnVtYmVyKG51bWJlcilcclxuICAgICAgcmV0dXJuIG5ldyBTVkcuTnVtYmVyKHRoaXMgLSBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdClcclxuICAgIH1cclxuICAgIC8vIE11bHRpcGx5IG51bWJlclxyXG4gICwgdGltZXM6IGZ1bmN0aW9uKG51bWJlcikge1xyXG4gICAgICBudW1iZXIgPSBuZXcgU1ZHLk51bWJlcihudW1iZXIpXHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLk51bWJlcih0aGlzICogbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpXHJcbiAgICB9XHJcbiAgICAvLyBEaXZpZGUgbnVtYmVyXHJcbiAgLCBkaXZpZGU6IGZ1bmN0aW9uKG51bWJlcikge1xyXG4gICAgICBudW1iZXIgPSBuZXcgU1ZHLk51bWJlcihudW1iZXIpXHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLk51bWJlcih0aGlzIC8gbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpXHJcbiAgICB9XHJcbiAgICAvLyBDb252ZXJ0IHRvIGRpZmZlcmVudCB1bml0XHJcbiAgLCB0bzogZnVuY3Rpb24odW5pdCkge1xyXG4gICAgICB2YXIgbnVtYmVyID0gbmV3IFNWRy5OdW1iZXIodGhpcylcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgdW5pdCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgbnVtYmVyLnVuaXQgPSB1bml0XHJcblxyXG4gICAgICByZXR1cm4gbnVtYmVyXHJcbiAgICB9XHJcbiAgICAvLyBNYWtlIG51bWJlciBtb3JwaGFibGVcclxuICAsIG1vcnBoOiBmdW5jdGlvbihudW1iZXIpIHtcclxuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuTnVtYmVyKG51bWJlcilcclxuXHJcbiAgICAgIGlmKG51bWJlci5yZWxhdGl2ZSkge1xyXG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24udmFsdWUgKz0gdGhpcy52YWx1ZVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICAgLy8gR2V0IG1vcnBoZWQgbnVtYmVyIGF0IGdpdmVuIHBvc2l0aW9uXHJcbiAgLCBhdDogZnVuY3Rpb24ocG9zKSB7XHJcbiAgICAgIC8vIE1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcclxuICAgICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpc1xyXG5cclxuICAgICAgLy8gR2VuZXJhdGUgbmV3IG1vcnBoZWQgbnVtYmVyXHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLk51bWJlcih0aGlzLmRlc3RpbmF0aW9uKVxyXG4gICAgICAgICAgLm1pbnVzKHRoaXMpXHJcbiAgICAgICAgICAudGltZXMocG9zKVxyXG4gICAgICAgICAgLnBsdXModGhpcylcclxuICAgIH1cclxuXHJcbiAgfVxyXG59KVxyXG5cblxyXG5TVkcuRWxlbWVudCA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgLy8gbWFrZSBzdHJva2UgdmFsdWUgYWNjZXNzaWJsZSBkeW5hbWljYWxseVxyXG4gICAgdGhpcy5fc3Ryb2tlID0gU1ZHLmRlZmF1bHRzLmF0dHJzLnN0cm9rZVxyXG4gICAgdGhpcy5fZXZlbnQgPSBudWxsXHJcblxyXG4gICAgLy8gaW5pdGlhbGl6ZSBkYXRhIG9iamVjdFxyXG4gICAgdGhpcy5kb20gPSB7fVxyXG5cclxuICAgIC8vIGNyZWF0ZSBjaXJjdWxhciByZWZlcmVuY2VcclxuICAgIGlmICh0aGlzLm5vZGUgPSBub2RlKSB7XHJcbiAgICAgIHRoaXMudHlwZSA9IG5vZGUubm9kZU5hbWVcclxuICAgICAgdGhpcy5ub2RlLmluc3RhbmNlID0gdGhpc1xyXG5cclxuICAgICAgLy8gc3RvcmUgY3VycmVudCBhdHRyaWJ1dGUgdmFsdWVcclxuICAgICAgdGhpcy5fc3Ryb2tlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3N0cm9rZScpIHx8IHRoaXMuX3N0cm9rZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIE1vdmUgb3ZlciB4LWF4aXNcclxuICAgIHg6IGZ1bmN0aW9uKHgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHgpXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIG92ZXIgeS1heGlzXHJcbiAgLCB5OiBmdW5jdGlvbih5KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3knLCB5KVxyXG4gICAgfVxyXG4gICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcclxuICAsIGN4OiBmdW5jdGlvbih4KSB7XHJcbiAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLngoKSArIHRoaXMud2lkdGgoKSAvIDIgOiB0aGlzLngoeCAtIHRoaXMud2lkdGgoKSAvIDIpXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xyXG4gICwgY3k6IGZ1bmN0aW9uKHkpIHtcclxuICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMueSgpICsgdGhpcy5oZWlnaHQoKSAvIDIgOiB0aGlzLnkoeSAtIHRoaXMuaGVpZ2h0KCkgLyAyKVxyXG4gICAgfVxyXG4gICAgLy8gTW92ZSBlbGVtZW50IHRvIGdpdmVuIHggYW5kIHkgdmFsdWVzXHJcbiAgLCBtb3ZlOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLngoeCkueSh5KVxyXG4gICAgfVxyXG4gICAgLy8gTW92ZSBlbGVtZW50IGJ5IGl0cyBjZW50ZXJcclxuICAsIGNlbnRlcjogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jeCh4KS5jeSh5KVxyXG4gICAgfVxyXG4gICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcclxuICAsIHdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCd3aWR0aCcsIHdpZHRoKVxyXG4gICAgfVxyXG4gICAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XHJcbiAgLCBoZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXHJcbiAgICB9XHJcbiAgICAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcclxuICAsIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgdmFyIHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIC53aWR0aChuZXcgU1ZHLk51bWJlcihwLndpZHRoKSlcclxuICAgICAgICAuaGVpZ2h0KG5ldyBTVkcuTnVtYmVyKHAuaGVpZ2h0KSlcclxuICAgIH1cclxuICAgIC8vIENsb25lIGVsZW1lbnRcclxuICAsIGNsb25lOiBmdW5jdGlvbihwYXJlbnQsIHdpdGhEYXRhKSB7XHJcbiAgICAgIC8vIHdyaXRlIGRvbSBkYXRhIHRvIHRoZSBkb20gc28gdGhlIGNsb25lIGNhbiBwaWNrdXAgdGhlIGRhdGFcclxuICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpXHJcblxyXG4gICAgICAvLyBjbG9uZSBlbGVtZW50IGFuZCBhc3NpZ24gbmV3IGlkXHJcbiAgICAgIHZhciBjbG9uZSA9IGFzc2lnbk5ld0lkKHRoaXMubm9kZS5jbG9uZU5vZGUodHJ1ZSkpXHJcblxyXG4gICAgICAvLyBpbnNlcnQgdGhlIGNsb25lIGluIHRoZSBnaXZlbiBwYXJlbnQgb3IgYWZ0ZXIgbXlzZWxmXHJcbiAgICAgIGlmKHBhcmVudCkgcGFyZW50LmFkZChjbG9uZSlcclxuICAgICAgZWxzZSB0aGlzLmFmdGVyKGNsb25lKVxyXG5cclxuICAgICAgcmV0dXJuIGNsb25lXHJcbiAgICB9XHJcbiAgICAvLyBSZW1vdmUgZWxlbWVudFxyXG4gICwgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMucGFyZW50KCkpXHJcbiAgICAgICAgdGhpcy5wYXJlbnQoKS5yZW1vdmVFbGVtZW50KHRoaXMpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICAgLy8gUmVwbGFjZSBlbGVtZW50XHJcbiAgLCByZXBsYWNlOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuYWZ0ZXIoZWxlbWVudCkucmVtb3ZlKClcclxuXHJcbiAgICAgIHJldHVybiBlbGVtZW50XHJcbiAgICB9XHJcbiAgICAvLyBBZGQgZWxlbWVudCB0byBnaXZlbiBjb250YWluZXIgYW5kIHJldHVybiBzZWxmXHJcbiAgLCBhZGRUbzogZnVuY3Rpb24ocGFyZW50KSB7XHJcbiAgICAgIHJldHVybiBwYXJlbnQucHV0KHRoaXMpXHJcbiAgICB9XHJcbiAgICAvLyBBZGQgZWxlbWVudCB0byBnaXZlbiBjb250YWluZXIgYW5kIHJldHVybiBjb250YWluZXJcclxuICAsIHB1dEluOiBmdW5jdGlvbihwYXJlbnQpIHtcclxuICAgICAgcmV0dXJuIHBhcmVudC5hZGQodGhpcylcclxuICAgIH1cclxuICAgIC8vIEdldCAvIHNldCBpZFxyXG4gICwgaWQ6IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2lkJywgaWQpXHJcbiAgICB9XHJcbiAgICAvLyBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgaW5zaWRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGVsZW1lbnRcclxuICAsIGluc2lkZTogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICB2YXIgYm94ID0gdGhpcy5iYm94KClcclxuXHJcbiAgICAgIHJldHVybiB4ID4gYm94LnhcclxuICAgICAgICAgICYmIHkgPiBib3gueVxyXG4gICAgICAgICAgJiYgeCA8IGJveC54ICsgYm94LndpZHRoXHJcbiAgICAgICAgICAmJiB5IDwgYm94LnkgKyBib3guaGVpZ2h0XHJcbiAgICB9XHJcbiAgICAvLyBTaG93IGVsZW1lbnRcclxuICAsIHNob3c6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScsICcnKVxyXG4gICAgfVxyXG4gICAgLy8gSGlkZSBlbGVtZW50XHJcbiAgLCBoaWRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpXHJcbiAgICB9XHJcbiAgICAvLyBJcyBlbGVtZW50IHZpc2libGU/XHJcbiAgLCB2aXNpYmxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc3R5bGUoJ2Rpc3BsYXknKSAhPSAnbm9uZSdcclxuICAgIH1cclxuICAgIC8vIFJldHVybiBpZCBvbiBzdHJpbmcgY29udmVyc2lvblxyXG4gICwgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdpZCcpXHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm4gYXJyYXkgb2YgY2xhc3NlcyBvbiB0aGUgbm9kZVxyXG4gICwgY2xhc3NlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBhdHRyID0gdGhpcy5hdHRyKCdjbGFzcycpXHJcblxyXG4gICAgICByZXR1cm4gYXR0ciA9PSBudWxsID8gW10gOiBhdHRyLnRyaW0oKS5zcGxpdChTVkcucmVnZXguZGVsaW1pdGVyKVxyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgY2xhc3MgZXhpc3RzIG9uIHRoZSBub2RlLCBmYWxzZSBvdGhlcndpc2VcclxuICAsIGhhc0NsYXNzOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNsYXNzZXMoKS5pbmRleE9mKG5hbWUpICE9IC0xXHJcbiAgICB9XHJcbiAgICAvLyBBZGQgY2xhc3MgdG8gdGhlIG5vZGVcclxuICAsIGFkZENsYXNzOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgIGlmICghdGhpcy5oYXNDbGFzcyhuYW1lKSkge1xyXG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuY2xhc3NlcygpXHJcbiAgICAgICAgYXJyYXkucHVzaChuYW1lKVxyXG4gICAgICAgIHRoaXMuYXR0cignY2xhc3MnLCBhcnJheS5qb2luKCcgJykpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBSZW1vdmUgY2xhc3MgZnJvbSB0aGUgbm9kZVxyXG4gICwgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgaWYgKHRoaXMuaGFzQ2xhc3MobmFtZSkpIHtcclxuICAgICAgICB0aGlzLmF0dHIoJ2NsYXNzJywgdGhpcy5jbGFzc2VzKCkuZmlsdGVyKGZ1bmN0aW9uKGMpIHtcclxuICAgICAgICAgIHJldHVybiBjICE9IG5hbWVcclxuICAgICAgICB9KS5qb2luKCcgJykpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBUb2dnbGUgdGhlIHByZXNlbmNlIG9mIGEgY2xhc3Mgb24gdGhlIG5vZGVcclxuICAsIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmhhc0NsYXNzKG5hbWUpID8gdGhpcy5yZW1vdmVDbGFzcyhuYW1lKSA6IHRoaXMuYWRkQ2xhc3MobmFtZSlcclxuICAgIH1cclxuICAgIC8vIEdldCByZWZlcmVuY2VkIGVsZW1lbnQgZm9ybSBhdHRyaWJ1dGUgdmFsdWVcclxuICAsIHJlZmVyZW5jZTogZnVuY3Rpb24oYXR0cikge1xyXG4gICAgICByZXR1cm4gU1ZHLmdldCh0aGlzLmF0dHIoYXR0cikpXHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBwYXJlbnQgZWxlbWVudCBpbnN0YW5jZVxyXG4gICwgcGFyZW50OiBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzXHJcblxyXG4gICAgICAvLyBjaGVjayBmb3IgcGFyZW50XHJcbiAgICAgIGlmKCFwYXJlbnQubm9kZS5wYXJlbnROb2RlKSByZXR1cm4gbnVsbFxyXG5cclxuICAgICAgLy8gZ2V0IHBhcmVudCBlbGVtZW50XHJcbiAgICAgIHBhcmVudCA9IFNWRy5hZG9wdChwYXJlbnQubm9kZS5wYXJlbnROb2RlKVxyXG5cclxuICAgICAgaWYoIXR5cGUpIHJldHVybiBwYXJlbnRcclxuXHJcbiAgICAgIC8vIGxvb3AgdHJvdWdoIGFuY2VzdG9ycyBpZiB0eXBlIGlzIGdpdmVuXHJcbiAgICAgIHdoaWxlKHBhcmVudCAmJiBwYXJlbnQubm9kZSBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50KXtcclxuICAgICAgICBpZih0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnQubWF0Y2hlcyh0eXBlKSA6IHBhcmVudCBpbnN0YW5jZW9mIHR5cGUpIHJldHVybiBwYXJlbnRcclxuICAgICAgICBwYXJlbnQgPSBTVkcuYWRvcHQocGFyZW50Lm5vZGUucGFyZW50Tm9kZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gR2V0IHBhcmVudCBkb2N1bWVudFxyXG4gICwgZG9jOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBTVkcuRG9jID8gdGhpcyA6IHRoaXMucGFyZW50KFNWRy5Eb2MpXHJcbiAgICB9XHJcbiAgICAvLyByZXR1cm4gYXJyYXkgb2YgYWxsIGFuY2VzdG9ycyBvZiBnaXZlbiB0eXBlIHVwIHRvIHRoZSByb290IHN2Z1xyXG4gICwgcGFyZW50czogZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICB2YXIgcGFyZW50cyA9IFtdLCBwYXJlbnQgPSB0aGlzXHJcblxyXG4gICAgICBkb3tcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KHR5cGUpXHJcbiAgICAgICAgaWYoIXBhcmVudCB8fCAhcGFyZW50Lm5vZGUpIGJyZWFrXHJcblxyXG4gICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpXHJcbiAgICAgIH0gd2hpbGUocGFyZW50LnBhcmVudClcclxuXHJcbiAgICAgIHJldHVybiBwYXJlbnRzXHJcbiAgICB9XHJcbiAgICAvLyBtYXRjaGVzIHRoZSBlbGVtZW50IHZzIGEgY3NzIHNlbGVjdG9yXHJcbiAgLCBtYXRjaGVzOiBmdW5jdGlvbihzZWxlY3Rvcil7XHJcbiAgICAgIHJldHVybiBtYXRjaGVzKHRoaXMubm9kZSwgc2VsZWN0b3IpXHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBzdmcgbm9kZSB0byBjYWxsIG5hdGl2ZSBzdmcgbWV0aG9kcyBvbiBpdFxyXG4gICwgbmF0aXZlOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubm9kZVxyXG4gICAgfVxyXG4gICAgLy8gSW1wb3J0IHJhdyBzdmdcclxuICAsIHN2ZzogZnVuY3Rpb24oc3ZnKSB7XHJcbiAgICAgIC8vIGNyZWF0ZSB0ZW1wb3JhcnkgaG9sZGVyXHJcbiAgICAgIHZhciB3ZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3ZnJylcclxuXHJcbiAgICAgIC8vIGFjdCBhcyBhIHNldHRlciBpZiBzdmcgaXMgZ2l2ZW5cclxuICAgICAgaWYgKHN2ZyAmJiB0aGlzIGluc3RhbmNlb2YgU1ZHLlBhcmVudCkge1xyXG4gICAgICAgIC8vIGR1bXAgcmF3IHN2Z1xyXG4gICAgICAgIHdlbGwuaW5uZXJIVE1MID0gJzxzdmc+JyArIHN2Zy5yZXBsYWNlKC9cXG4vLCAnJykucmVwbGFjZSgvPChcXHcrKShbXjxdKz8pXFwvPi9nLCAnPCQxJDI+PC8kMT4nKSArICc8L3N2Zz4nXHJcblxyXG4gICAgICAgIC8vIHRyYW5zcGxhbnQgbm9kZXNcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB3ZWxsLmZpcnN0Q2hpbGQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHdlbGwuZmlyc3RDaGlsZC5maXJzdENoaWxkKVxyXG5cclxuICAgICAgLy8gb3RoZXJ3aXNlIGFjdCBhcyBhIGdldHRlclxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBhIHdyYXBwaW5nIHN2ZyBlbGVtZW50IGluIGNhc2Ugb2YgcGFydGlhbCBjb250ZW50XHJcbiAgICAgICAgd2VsbC5hcHBlbmRDaGlsZChzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdmcnKSlcclxuXHJcbiAgICAgICAgLy8gd3JpdGUgc3ZnanMgZGF0YSB0byB0aGUgZG9tXHJcbiAgICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpXHJcblxyXG4gICAgICAgIC8vIGluc2VydCBhIGNvcHkgb2YgdGhpcyBub2RlXHJcbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKHRoaXMubm9kZS5jbG9uZU5vZGUodHJ1ZSkpXHJcblxyXG4gICAgICAgIC8vIHJldHVybiB0YXJnZXQgZWxlbWVudFxyXG4gICAgICAgIHJldHVybiB3ZWxsLmlubmVySFRNTC5yZXBsYWNlKC9ePHN2Zz4vLCAnJykucmVwbGFjZSgvPFxcL3N2Zz4kLywgJycpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgLy8gd3JpdGUgc3ZnanMgZGF0YSB0byB0aGUgZG9tXHJcbiAgLCB3cml0ZURhdGFUb0RvbTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAvLyBkdW1wIHZhcmlhYmxlcyByZWN1cnNpdmVseVxyXG4gICAgICBpZih0aGlzLmVhY2ggfHwgdGhpcy5saW5lcyl7XHJcbiAgICAgICAgdmFyIGZuID0gdGhpcy5lYWNoID8gdGhpcyA6IHRoaXMubGluZXMoKTtcclxuICAgICAgICBmbi5lYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICB0aGlzLndyaXRlRGF0YVRvRG9tKClcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZW1vdmUgcHJldmlvdXNseSBzZXQgZGF0YVxyXG4gICAgICB0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKCdzdmdqczpkYXRhJylcclxuXHJcbiAgICAgIGlmKE9iamVjdC5rZXlzKHRoaXMuZG9tKS5sZW5ndGgpXHJcbiAgICAgICAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgnc3ZnanM6ZGF0YScsIEpTT04uc3RyaW5naWZ5KHRoaXMuZG9tKSkgLy8gc2VlICM0MjhcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgLy8gc2V0IGdpdmVuIGRhdGEgdG8gdGhlIGVsZW1lbnRzIGRhdGEgcHJvcGVydHlcclxuICAsIHNldERhdGE6IGZ1bmN0aW9uKG8pe1xyXG4gICAgICB0aGlzLmRvbSA9IG9cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAsIGlzOiBmdW5jdGlvbihvYmope1xyXG4gICAgICByZXR1cm4gaXModGhpcywgb2JqKVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXG5TVkcuZWFzaW5nID0ge1xyXG4gICctJzogZnVuY3Rpb24ocG9zKXtyZXR1cm4gcG9zfVxyXG4sICc8Pic6ZnVuY3Rpb24ocG9zKXtyZXR1cm4gLU1hdGguY29zKHBvcyAqIE1hdGguUEkpIC8gMiArIDAuNX1cclxuLCAnPic6IGZ1bmN0aW9uKHBvcyl7cmV0dXJuICBNYXRoLnNpbihwb3MgKiBNYXRoLlBJIC8gMil9XHJcbiwgJzwnOiBmdW5jdGlvbihwb3Mpe3JldHVybiAtTWF0aC5jb3MocG9zICogTWF0aC5QSSAvIDIpICsgMX1cclxufVxyXG5cclxuU1ZHLm1vcnBoID0gZnVuY3Rpb24ocG9zKXtcclxuICByZXR1cm4gZnVuY3Rpb24oZnJvbSwgdG8pIHtcclxuICAgIHJldHVybiBuZXcgU1ZHLk1vcnBoT2JqKGZyb20sIHRvKS5hdChwb3MpXHJcbiAgfVxyXG59XHJcblxyXG5TVkcuU2l0dWF0aW9uID0gU1ZHLmludmVudCh7XHJcblxyXG4gIGNyZWF0ZTogZnVuY3Rpb24obyl7XHJcbiAgICB0aGlzLmluaXQgPSBmYWxzZVxyXG4gICAgdGhpcy5yZXZlcnNlZCA9IGZhbHNlXHJcbiAgICB0aGlzLnJldmVyc2luZyA9IGZhbHNlXHJcblxyXG4gICAgdGhpcy5kdXJhdGlvbiA9IG5ldyBTVkcuTnVtYmVyKG8uZHVyYXRpb24pLnZhbHVlT2YoKVxyXG4gICAgdGhpcy5kZWxheSA9IG5ldyBTVkcuTnVtYmVyKG8uZGVsYXkpLnZhbHVlT2YoKVxyXG5cclxuICAgIHRoaXMuc3RhcnQgPSArbmV3IERhdGUoKSArIHRoaXMuZGVsYXlcclxuICAgIHRoaXMuZmluaXNoID0gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb25cclxuICAgIHRoaXMuZWFzZSA9IG8uZWFzZVxyXG5cclxuICAgIC8vIHRoaXMubG9vcCBpcyBpbmNyZW1lbnRlZCBmcm9tIDAgdG8gdGhpcy5sb29wc1xyXG4gICAgLy8gaXQgaXMgYWxzbyBpbmNyZW1lbnRlZCB3aGVuIGluIGFuIGluZmluaXRlIGxvb3AgKHdoZW4gdGhpcy5sb29wcyBpcyB0cnVlKVxyXG4gICAgdGhpcy5sb29wID0gMFxyXG4gICAgdGhpcy5sb29wcyA9IGZhbHNlXHJcblxyXG4gICAgdGhpcy5hbmltYXRpb25zID0ge1xyXG4gICAgICAvLyBmdW5jdGlvblRvQ2FsbDogW2xpc3Qgb2YgbW9ycGhhYmxlIG9iamVjdHNdXHJcbiAgICAgIC8vIGUuZy4gbW92ZTogW1NWRy5OdW1iZXIsIFNWRy5OdW1iZXJdXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hdHRycyA9IHtcclxuICAgICAgLy8gaG9sZHMgYWxsIGF0dHJpYnV0ZXMgd2hpY2ggYXJlIG5vdCByZXByZXNlbnRlZCBmcm9tIGEgZnVuY3Rpb24gc3ZnLmpzIHByb3ZpZGVzXHJcbiAgICAgIC8vIGUuZy4gc29tZUF0dHI6IFNWRy5OdW1iZXJcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0eWxlcyA9IHtcclxuICAgICAgLy8gaG9sZHMgYWxsIHN0eWxlcyB3aGljaCBzaG91bGQgYmUgYW5pbWF0ZWRcclxuICAgICAgLy8gZS5nLiBmaWxsLWNvbG9yOiBTVkcuQ29sb3JcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBbXHJcbiAgICAgIC8vIGhvbGRzIGFsbCB0cmFuc2Zvcm1hdGlvbnMgYXMgdHJhbnNmb3JtYXRpb24gb2JqZWN0c1xyXG4gICAgICAvLyBlLmcuIFtTVkcuUm90YXRlLCBTVkcuVHJhbnNsYXRlLCBTVkcuTWF0cml4XVxyXG4gICAgXVxyXG5cclxuICAgIHRoaXMub25jZSA9IHtcclxuICAgICAgLy8gZnVuY3Rpb25zIHRvIGZpcmUgYXQgYSBzcGVjaWZpYyBwb3NpdGlvblxyXG4gICAgICAvLyBlLmcuIFwiMC41XCI6IGZ1bmN0aW9uIGZvbygpe31cclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxufSlcclxuXHJcblxyXG5TVkcuRlggPSBTVkcuaW52ZW50KHtcclxuXHJcbiAgY3JlYXRlOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICB0aGlzLl90YXJnZXQgPSBlbGVtZW50XHJcbiAgICB0aGlzLnNpdHVhdGlvbnMgPSBbXVxyXG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZVxyXG4gICAgdGhpcy5zaXR1YXRpb24gPSBudWxsXHJcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXHJcbiAgICB0aGlzLmxhc3RQb3MgPSAwXHJcbiAgICB0aGlzLnBvcyA9IDBcclxuICAgIC8vIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBhbiBhbmltYXRpb24gaXMgaXRzIHBvc2l0aW9uIGluIHRoZSBjb250ZXh0IG9mIGl0cyBjb21wbGV0ZSBkdXJhdGlvbiAoaW5jbHVkaW5nIGRlbGF5IGFuZCBsb29wcylcclxuICAgIC8vIFdoZW4gcGVyZm9ybWluZyBhIGRlbGF5LCBhYnNQb3MgaXMgYmVsb3cgMCBhbmQgd2hlbiBwZXJmb3JtaW5nIGEgbG9vcCwgaXRzIHZhbHVlIGlzIGFib3ZlIDFcclxuICAgIHRoaXMuYWJzUG9zID0gMFxyXG4gICAgdGhpcy5fc3BlZWQgPSAxXHJcbiAgfVxyXG5cclxuLCBleHRlbmQ6IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldHMgb3IgcmV0dXJucyB0aGUgdGFyZ2V0IG9mIHRoaXMgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gbyBvYmplY3QgfHwgbnVtYmVyIEluIGNhc2Ugb2YgT2JqZWN0IGl0IGhvbGRzIGFsbCBwYXJhbWV0ZXJzLiBJbiBjYXNlIG9mIG51bWJlciBpdHMgdGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBlYXNlIGZ1bmN0aW9uIHx8IHN0cmluZyBGdW5jdGlvbiB3aGljaCBzaG91bGQgYmUgdXNlZCBmb3IgZWFzaW5nIG9yIGVhc2luZyBrZXl3b3JkXHJcbiAgICAgKiBAcGFyYW0gZGVsYXkgTnVtYmVyIGluZGljYXRpbmcgdGhlIGRlbGF5IGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xyXG4gICAgICogQHJldHVybiB0YXJnZXQgfHwgdGhpc1xyXG4gICAgICovXHJcbiAgICBhbmltYXRlOiBmdW5jdGlvbihvLCBlYXNlLCBkZWxheSl7XHJcblxyXG4gICAgICBpZih0eXBlb2YgbyA9PSAnb2JqZWN0Jyl7XHJcbiAgICAgICAgZWFzZSA9IG8uZWFzZVxyXG4gICAgICAgIGRlbGF5ID0gby5kZWxheVxyXG4gICAgICAgIG8gPSBvLmR1cmF0aW9uXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzaXR1YXRpb24gPSBuZXcgU1ZHLlNpdHVhdGlvbih7XHJcbiAgICAgICAgZHVyYXRpb246IG8gfHwgMTAwMCxcclxuICAgICAgICBkZWxheTogZGVsYXkgfHwgMCxcclxuICAgICAgICBlYXNlOiBTVkcuZWFzaW5nW2Vhc2UgfHwgJy0nXSB8fCBlYXNlXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICB0aGlzLnF1ZXVlKHNpdHVhdGlvbilcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXRzIGEgZGVsYXkgYmVmb3JlIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHF1ZXVlIGlzIGNhbGxlZFxyXG4gICAgICogQHBhcmFtIGRlbGF5IER1cmF0aW9uIG9mIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHJldHVybiB0aGlzLnRhcmdldCgpXHJcbiAgICAgKi9cclxuICAsIGRlbGF5OiBmdW5jdGlvbihkZWxheSl7XHJcbiAgICAgIC8vIFRoZSBkZWxheSBpcyBwZXJmb3JtZWQgYnkgYW4gZW1wdHkgc2l0dWF0aW9uIHdpdGggaXRzIGR1cmF0aW9uXHJcbiAgICAgIC8vIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIGR1cmF0aW9uIG9mIHRoZSBkZWxheVxyXG4gICAgICB2YXIgc2l0dWF0aW9uID0gbmV3IFNWRy5TaXR1YXRpb24oe1xyXG4gICAgICAgIGR1cmF0aW9uOiBkZWxheSxcclxuICAgICAgICBkZWxheTogMCxcclxuICAgICAgICBlYXNlOiBTVkcuZWFzaW5nWyctJ11cclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLnF1ZXVlKHNpdHVhdGlvbilcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldHMgb3IgcmV0dXJucyB0aGUgdGFyZ2V0IG9mIHRoaXMgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gbnVsbCB8fCB0YXJnZXQgU1ZHLkVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlIHNldCBhcyBuZXcgdGFyZ2V0XHJcbiAgICAgKiBAcmV0dXJuIHRhcmdldCB8fCB0aGlzXHJcbiAgICAgKi9cclxuICAsIHRhcmdldDogZnVuY3Rpb24odGFyZ2V0KXtcclxuICAgICAgaWYodGFyZ2V0ICYmIHRhcmdldCBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KXtcclxuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXRcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmV0dXJucyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gYXQgYSBnaXZlbiB0aW1lXHJcbiAgLCB0aW1lVG9BYnNQb3M6IGZ1bmN0aW9uKHRpbWVzdGFtcCl7XHJcbiAgICAgIHJldHVybiAodGltZXN0YW1wIC0gdGhpcy5zaXR1YXRpb24uc3RhcnQpIC8gKHRoaXMuc2l0dWF0aW9uLmR1cmF0aW9uL3RoaXMuX3NwZWVkKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHJldHVybnMgdGhlIHRpbWVzdGFtcCBmcm9tIGEgZ2l2ZW4gYWJzb2x1dGUgcG9zaXRvblxyXG4gICwgYWJzUG9zVG9UaW1lOiBmdW5jdGlvbihhYnNQb3Mpe1xyXG4gICAgICByZXR1cm4gdGhpcy5zaXR1YXRpb24uZHVyYXRpb24vdGhpcy5fc3BlZWQgKiBhYnNQb3MgKyB0aGlzLnNpdHVhdGlvbi5zdGFydFxyXG4gICAgfVxyXG5cclxuICAgIC8vIHN0YXJ0cyB0aGUgYW5pbWF0aW9ubG9vcFxyXG4gICwgc3RhcnRBbmltRnJhbWU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHRoaXMuc3RvcEFuaW1GcmFtZSgpXHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7IHRoaXMuc3RlcCgpIH0uYmluZCh0aGlzKSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBjYW5jZWxzIHRoZSBhbmltYXRpb25mcmFtZVxyXG4gICwgc3RvcEFuaW1GcmFtZTogZnVuY3Rpb24oKXtcclxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWUpXHJcbiAgICB9XHJcblxyXG4gICAgLy8ga2lja3Mgb2ZmIHRoZSBhbmltYXRpb24gLSBvbmx5IGRvZXMgc29tZXRoaW5nIHdoZW4gdGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBub3QgYWN0aXZlIGFuZCBhdCBsZWFzdCBvbmUgc2l0dWF0aW9uIGlzIHNldFxyXG4gICwgc3RhcnQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIC8vIGRvbnQgc3RhcnQgaWYgYWxyZWFkeSBzdGFydGVkXHJcbiAgICAgIGlmKCF0aGlzLmFjdGl2ZSAmJiB0aGlzLnNpdHVhdGlvbil7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgdGhpcy5zdGFydEN1cnJlbnQoKVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN0YXJ0IHRoZSBjdXJyZW50IHNpdHVhdGlvblxyXG4gICwgc3RhcnRDdXJyZW50OiBmdW5jdGlvbigpe1xyXG4gICAgICB0aGlzLnNpdHVhdGlvbi5zdGFydCA9ICtuZXcgRGF0ZSArIHRoaXMuc2l0dWF0aW9uLmRlbGF5L3RoaXMuX3NwZWVkXHJcbiAgICAgIHRoaXMuc2l0dWF0aW9uLmZpbmlzaCA9IHRoaXMuc2l0dWF0aW9uLnN0YXJ0ICsgdGhpcy5zaXR1YXRpb24uZHVyYXRpb24vdGhpcy5fc3BlZWRcclxuICAgICAgcmV0dXJuIHRoaXMuaW5pdEFuaW1hdGlvbnMoKS5zdGVwKClcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGFkZHMgYSBmdW5jdGlvbiAvIFNpdHVhdGlvbiB0byB0aGUgYW5pbWF0aW9uIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24gLyBzaXR1YXRpb24gdG8gYWRkXHJcbiAgICAgKiBAcmV0dXJuIHRoaXNcclxuICAgICAqL1xyXG4gICwgcXVldWU6IGZ1bmN0aW9uKGZuKXtcclxuICAgICAgaWYodHlwZW9mIGZuID09ICdmdW5jdGlvbicgfHwgZm4gaW5zdGFuY2VvZiBTVkcuU2l0dWF0aW9uKVxyXG4gICAgICAgIHRoaXMuc2l0dWF0aW9ucy5wdXNoKGZuKVxyXG5cclxuICAgICAgaWYoIXRoaXMuc2l0dWF0aW9uKSB0aGlzLnNpdHVhdGlvbiA9IHRoaXMuc2l0dWF0aW9ucy5zaGlmdCgpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcHVsbHMgbmV4dCBlbGVtZW50IGZyb20gdGhlIHF1ZXVlIGFuZCBleGVjdXRlIGl0XHJcbiAgICAgKiBAcmV0dXJuIHRoaXNcclxuICAgICAqL1xyXG4gICwgZGVxdWV1ZTogZnVuY3Rpb24oKXtcclxuICAgICAgLy8gc3RvcCBjdXJyZW50IGFuaW1hdGlvblxyXG4gICAgICB0aGlzLnN0b3AoKVxyXG5cclxuICAgICAgLy8gZ2V0IG5leHQgYW5pbWF0aW9uIGZyb20gcXVldWVcclxuICAgICAgdGhpcy5zaXR1YXRpb24gPSB0aGlzLnNpdHVhdGlvbnMuc2hpZnQoKVxyXG5cclxuICAgICAgaWYodGhpcy5zaXR1YXRpb24pe1xyXG4gICAgICAgIGlmKHRoaXMuc2l0dWF0aW9uIGluc3RhbmNlb2YgU1ZHLlNpdHVhdGlvbikge1xyXG4gICAgICAgICAgdGhpcy5zdGFydCgpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIElmIGl0IGlzIG5vdCBhIFNWRy5TaXR1YXRpb24sIHRoZW4gaXQgaXMgYSBmdW5jdGlvbiwgd2UgZXhlY3V0ZSBpdFxyXG4gICAgICAgICAgdGhpcy5zaXR1YXRpb24uY2FsbCh0aGlzKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvLyB1cGRhdGVzIGFsbCBhbmltYXRpb25zIHRvIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50XHJcbiAgICAvLyB0aGlzIGlzIGltcG9ydGFudCB3aGVuIG9uZSBwcm9wZXJ0eSBjb3VsZCBiZSBjaGFuZ2VkIGZyb20gYW5vdGhlciBwcm9wZXJ0eVxyXG4gICwgaW5pdEFuaW1hdGlvbnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgaSwgaiwgc291cmNlXHJcbiAgICAgIHZhciBzID0gdGhpcy5zaXR1YXRpb25cclxuXHJcbiAgICAgIGlmKHMuaW5pdCkgcmV0dXJuIHRoaXNcclxuXHJcbiAgICAgIGZvcihpIGluIHMuYW5pbWF0aW9ucyl7XHJcbiAgICAgICAgc291cmNlID0gdGhpcy50YXJnZXQoKVtpXSgpXHJcblxyXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICAgIHNvdXJjZSA9IFtzb3VyY2VdXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZighQXJyYXkuaXNBcnJheShzLmFuaW1hdGlvbnNbaV0pKSB7XHJcbiAgICAgICAgICBzLmFuaW1hdGlvbnNbaV0gPSBbcy5hbmltYXRpb25zW2ldXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9pZihzLmFuaW1hdGlvbnNbaV0ubGVuZ3RoID4gc291cmNlLmxlbmd0aCkge1xyXG4gICAgICAgIC8vICBzb3VyY2UuY29uY2F0ID0gc291cmNlLmNvbmNhdChzLmFuaW1hdGlvbnNbaV0uc2xpY2Uoc291cmNlLmxlbmd0aCwgcy5hbmltYXRpb25zW2ldLmxlbmd0aCkpXHJcbiAgICAgICAgLy99XHJcblxyXG4gICAgICAgIGZvcihqID0gc291cmNlLmxlbmd0aDsgai0tOykge1xyXG4gICAgICAgICAgLy8gVGhlIGNvbmRpdGlvbiBpcyBiZWNhdXNlIHNvbWUgbWV0aG9kcyByZXR1cm4gYSBub3JtYWwgbnVtYmVyIGluc3RlYWRcclxuICAgICAgICAgIC8vIG9mIGEgU1ZHLk51bWJlclxyXG4gICAgICAgICAgaWYocy5hbmltYXRpb25zW2ldW2pdIGluc3RhbmNlb2YgU1ZHLk51bWJlcilcclxuICAgICAgICAgICAgc291cmNlW2pdID0gbmV3IFNWRy5OdW1iZXIoc291cmNlW2pdKVxyXG5cclxuICAgICAgICAgIHMuYW5pbWF0aW9uc1tpXVtqXSA9IHNvdXJjZVtqXS5tb3JwaChzLmFuaW1hdGlvbnNbaV1bal0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IoaSBpbiBzLmF0dHJzKXtcclxuICAgICAgICBzLmF0dHJzW2ldID0gbmV3IFNWRy5Nb3JwaE9iaih0aGlzLnRhcmdldCgpLmF0dHIoaSksIHMuYXR0cnNbaV0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvcihpIGluIHMuc3R5bGVzKXtcclxuICAgICAgICBzLnN0eWxlc1tpXSA9IG5ldyBTVkcuTW9ycGhPYmoodGhpcy50YXJnZXQoKS5zdHlsZShpKSwgcy5zdHlsZXNbaV0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHMuaW5pdGlhbFRyYW5zZm9ybWF0aW9uID0gdGhpcy50YXJnZXQoKS5tYXRyaXhpZnkoKVxyXG5cclxuICAgICAgcy5pbml0ID0gdHJ1ZVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICwgY2xlYXJRdWV1ZTogZnVuY3Rpb24oKXtcclxuICAgICAgdGhpcy5zaXR1YXRpb25zID0gW11cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAsIGNsZWFyQ3VycmVudDogZnVuY3Rpb24oKXtcclxuICAgICAgdGhpcy5zaXR1YXRpb24gPSBudWxsXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvKiogc3RvcHMgdGhlIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxyXG4gICAgICogQHBhcmFtIGp1bXBUb0VuZCBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpbW1lZGlhdGVseS5cclxuICAgICAqIEBwYXJhbSBjbGVhclF1ZXVlIEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gcmVtb3ZlIHF1ZXVlZCBhbmltYXRpb24gYXMgd2VsbC5cclxuICAgICAqIEByZXR1cm4gdGhpc1xyXG4gICAgICovXHJcbiAgLCBzdG9wOiBmdW5jdGlvbihqdW1wVG9FbmQsIGNsZWFyUXVldWUpe1xyXG4gICAgICB2YXIgYWN0aXZlID0gdGhpcy5hY3RpdmVcclxuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZVxyXG5cclxuICAgICAgaWYoY2xlYXJRdWV1ZSl7XHJcbiAgICAgICAgdGhpcy5jbGVhclF1ZXVlKClcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoanVtcFRvRW5kICYmIHRoaXMuc2l0dWF0aW9uKXtcclxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzaXR1YXRpb24gaWYgaXQgd2FzIG5vdFxyXG4gICAgICAgICFhY3RpdmUgJiYgdGhpcy5zdGFydEN1cnJlbnQoKVxyXG4gICAgICAgIHRoaXMuYXRFbmQoKVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnN0b3BBbmltRnJhbWUoKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuY2xlYXJDdXJyZW50KClcclxuICAgIH1cclxuXHJcbiAgICAvKiogcmVzZXRzIHRoZSBlbGVtZW50IHRvIHRoZSBzdGF0ZSB3aGVyZSB0aGUgY3VycmVudCBlbGVtZW50IGhhcyBzdGFydGVkXHJcbiAgICAgKiBAcmV0dXJuIHRoaXNcclxuICAgICAqL1xyXG4gICwgcmVzZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGlmKHRoaXMuc2l0dWF0aW9uKXtcclxuICAgICAgICB2YXIgdGVtcCA9IHRoaXMuc2l0dWF0aW9uXHJcbiAgICAgICAgdGhpcy5zdG9wKClcclxuICAgICAgICB0aGlzLnNpdHVhdGlvbiA9IHRlbXBcclxuICAgICAgICB0aGlzLmF0U3RhcnQoKVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RvcCB0aGUgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uLCByZW1vdmUgYWxsIHF1ZXVlZCBhbmltYXRpb25zLCBhbmQgY29tcGxldGUgYWxsIGFuaW1hdGlvbnMgZm9yIHRoZSBlbGVtZW50LlxyXG4gICwgZmluaXNoOiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgdGhpcy5zdG9wKHRydWUsIGZhbHNlKVxyXG5cclxuICAgICAgd2hpbGUodGhpcy5kZXF1ZXVlKCkuc2l0dWF0aW9uICYmIHRoaXMuc3RvcCh0cnVlLCBmYWxzZSkpO1xyXG5cclxuICAgICAgdGhpcy5jbGVhclF1ZXVlKCkuY2xlYXJDdXJyZW50KClcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IHRoZSBpbnRlcm5hbCBhbmltYXRpb24gcG9pbnRlciBhdCB0aGUgc3RhcnQgcG9zaXRpb24sIGJlZm9yZSBhbnkgbG9vcHMsIGFuZCB1cGRhdGVzIHRoZSB2aXN1YWxpc2F0aW9uXHJcbiAgLCBhdFN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXQoMCwgdHJ1ZSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXQgdGhlIGludGVybmFsIGFuaW1hdGlvbiBwb2ludGVyIGF0IHRoZSBlbmQgcG9zaXRpb24sIGFmdGVyIGFsbCB0aGUgbG9vcHMsIGFuZCB1cGRhdGVzIHRoZSB2aXN1YWxpc2F0aW9uXHJcbiAgLCBhdEVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLnNpdHVhdGlvbi5sb29wcyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIC8vIElmIGluIGEgaW5maW5pdGUgbG9vcCwgd2UgZW5kIHRoZSBjdXJyZW50IGl0ZXJhdGlvblxyXG4gICAgICAgIHRoaXMuc2l0dWF0aW9uLmxvb3BzID0gdGhpcy5zaXR1YXRpb24ubG9vcCArIDFcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYodHlwZW9mIHRoaXMuc2l0dWF0aW9uLmxvb3BzID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgLy8gSWYgcGVyZm9ybWluZyBhIGZpbml0ZSBudW1iZXIgb2YgbG9vcHMsIHdlIGdvIGFmdGVyIGFsbCB0aGUgbG9vcHNcclxuICAgICAgICByZXR1cm4gdGhpcy5hdCh0aGlzLnNpdHVhdGlvbi5sb29wcywgdHJ1ZSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJZiBubyBsb29wcywgd2UganVzdCBnbyBhdCB0aGUgZW5kXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXQoMSwgdHJ1ZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldCB0aGUgaW50ZXJuYWwgYW5pbWF0aW9uIHBvaW50ZXIgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBhbmQgdXBkYXRlcyB0aGUgdmlzdWFsaXNhdGlvblxyXG4gICAgLy8gaWYgaXNBYnNQb3MgaXMgdHJ1ZSwgcG9zIGlzIHRyZWF0ZWQgYXMgYW4gYWJzb2x1dGUgcG9zaXRpb25cclxuICAsIGF0OiBmdW5jdGlvbihwb3MsIGlzQWJzUG9zKXtcclxuICAgICAgdmFyIGR1ckRpdlNwZCA9IHRoaXMuc2l0dWF0aW9uLmR1cmF0aW9uL3RoaXMuX3NwZWVkXHJcblxyXG4gICAgICB0aGlzLmFic1BvcyA9IHBvc1xyXG4gICAgICAvLyBJZiBwb3MgaXMgbm90IGFuIGFic29sdXRlIHBvc2l0aW9uLCB3ZSBjb252ZXJ0IGl0IGludG8gb25lXHJcbiAgICAgIGlmICghaXNBYnNQb3MpIHtcclxuICAgICAgICBpZiAodGhpcy5zaXR1YXRpb24ucmV2ZXJzZWQpIHRoaXMuYWJzUG9zID0gMSAtIHRoaXMuYWJzUG9zXHJcbiAgICAgICAgdGhpcy5hYnNQb3MgKz0gdGhpcy5zaXR1YXRpb24ubG9vcFxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnNpdHVhdGlvbi5zdGFydCA9ICtuZXcgRGF0ZSAtIHRoaXMuYWJzUG9zICogZHVyRGl2U3BkXHJcbiAgICAgIHRoaXMuc2l0dWF0aW9uLmZpbmlzaCA9IHRoaXMuc2l0dWF0aW9uLnN0YXJ0ICsgZHVyRGl2U3BkXHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5zdGVwKHRydWUpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXRzIG9yIHJldHVybnMgdGhlIHNwZWVkIG9mIHRoZSBhbmltYXRpb25zXHJcbiAgICAgKiBAcGFyYW0gc3BlZWQgbnVsbCB8fCBOdW1iZXIgVGhlIG5ldyBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uc1xyXG4gICAgICogQHJldHVybiBOdW1iZXIgfHwgdGhpc1xyXG4gICAgICovXHJcbiAgLCBzcGVlZDogZnVuY3Rpb24oc3BlZWQpe1xyXG4gICAgICBpZiAoc3BlZWQgPT09IDApIHJldHVybiB0aGlzLnBhdXNlKClcclxuXHJcbiAgICAgIGlmIChzcGVlZCkge1xyXG4gICAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWRcclxuICAgICAgICAvLyBXZSB1c2UgYW4gYWJzb2x1dGUgcG9zaXRpb24gaGVyZSBzbyB0aGF0IHNwZWVkIGNhbiBhZmZlY3QgdGhlIGRlbGF5IGJlZm9yZSB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXQodGhpcy5hYnNQb3MsIHRydWUpXHJcbiAgICAgIH0gZWxzZSByZXR1cm4gdGhpcy5fc3BlZWRcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIGxvb3BhYmxlXHJcbiAgLCBsb29wOiBmdW5jdGlvbih0aW1lcywgcmV2ZXJzZSkge1xyXG4gICAgICB2YXIgYyA9IHRoaXMubGFzdCgpXHJcblxyXG4gICAgICAvLyBzdG9yZSB0b3RhbCBsb29wc1xyXG4gICAgICBjLmxvb3BzID0gKHRpbWVzICE9IG51bGwpID8gdGltZXMgOiB0cnVlXHJcbiAgICAgIGMubG9vcCA9IDBcclxuXHJcbiAgICAgIGlmKHJldmVyc2UpIGMucmV2ZXJzaW5nID0gdHJ1ZVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHBhdXNlcyB0aGUgYW5pbWF0aW9uXHJcbiAgLCBwYXVzZTogZnVuY3Rpb24oKXtcclxuICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlXHJcbiAgICAgIHRoaXMuc3RvcEFuaW1GcmFtZSgpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHVucGF1c2UgdGhlIGFuaW1hdGlvblxyXG4gICwgcGxheTogZnVuY3Rpb24oKXtcclxuICAgICAgaWYoIXRoaXMucGF1c2VkKSByZXR1cm4gdGhpc1xyXG4gICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXHJcbiAgICAgIC8vIFdlIHVzZSBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBoZXJlIHNvIHRoYXQgdGhlIGRlbGF5IGJlZm9yZSB0aGUgYW5pbWF0aW9uIGNhbiBiZSBwYXVzZWRcclxuICAgICAgcmV0dXJuIHRoaXMuYXQodGhpcy5hYnNQb3MsIHRydWUpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0b2dnbGUgb3Igc2V0IHRoZSBkaXJlY3Rpb24gb2YgdGhlIGFuaW1hdGlvblxyXG4gICAgICogdHJ1ZSBzZXRzIGRpcmVjdGlvbiB0byBiYWNrd2FyZHMgd2hpbGUgZmFsc2Ugc2V0cyBpdCB0byBmb3J3YXJkc1xyXG4gICAgICogQHBhcmFtIHJldmVyc2VkIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIHJldmVyc2UgdGhlIGFuaW1hdGlvbiBvciBub3QgKGRlZmF1bHQ6IHRvZ2dsZSB0aGUgcmV2ZXJzZSBzdGF0dXMpXHJcbiAgICAgKiBAcmV0dXJuIHRoaXNcclxuICAgICAqL1xyXG4gICwgcmV2ZXJzZTogZnVuY3Rpb24ocmV2ZXJzZWQpe1xyXG4gICAgICB2YXIgYyA9IHRoaXMubGFzdCgpXHJcblxyXG4gICAgICBpZih0eXBlb2YgcmV2ZXJzZWQgPT0gJ3VuZGVmaW5lZCcpIGMucmV2ZXJzZWQgPSAhYy5yZXZlcnNlZFxyXG4gICAgICBlbHNlIGMucmV2ZXJzZWQgPSByZXZlcnNlZFxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIGEgZmxvYXQgZnJvbSAwLTEgaW5kaWNhdGluZyB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gZWFzZWQgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHJldHVybmVkIHBvc2l0aW9uIHNob3VsZCBiZSBlYXNlZCBvciBub3RcclxuICAgICAqIEByZXR1cm4gbnVtYmVyXHJcbiAgICAgKi9cclxuICAsIHByb2dyZXNzOiBmdW5jdGlvbihlYXNlSXQpe1xyXG4gICAgICByZXR1cm4gZWFzZUl0ID8gdGhpcy5zaXR1YXRpb24uZWFzZSh0aGlzLnBvcykgOiB0aGlzLnBvc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYWRkcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpcyBmaW5pc2hlZFxyXG4gICAgICogQHBhcmFtIGZuIEZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSBleGVjdXRlZCBhcyBjYWxsYmFja1xyXG4gICAgICogQHJldHVybiBudW1iZXJcclxuICAgICAqL1xyXG4gICwgYWZ0ZXI6IGZ1bmN0aW9uKGZuKXtcclxuICAgICAgdmFyIGMgPSB0aGlzLmxhc3QoKVxyXG4gICAgICAgICwgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoZSl7XHJcbiAgICAgICAgICAgIGlmKGUuZGV0YWlsLnNpdHVhdGlvbiA9PSBjKXtcclxuICAgICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGMpXHJcbiAgICAgICAgICAgICAgdGhpcy5vZmYoJ2ZpbmlzaGVkLmZ4Jywgd3JhcHBlcikgLy8gcHJldmVudCBtZW1vcnkgbGVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICB0aGlzLnRhcmdldCgpLm9uKCdmaW5pc2hlZC5meCcsIHdyYXBwZXIpXHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YXJ0KClcclxuICAgIH1cclxuXHJcbiAgICAvLyBhZGRzIGEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW5ldmVyIG9uZSBhbmltYXRpb24gc3RlcCBpcyBwZXJmb3JtZWRcclxuICAsIGR1cmluZzogZnVuY3Rpb24oZm4pe1xyXG4gICAgICB2YXIgYyA9IHRoaXMubGFzdCgpXHJcbiAgICAgICAgLCB3cmFwcGVyID0gZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgIGlmKGUuZGV0YWlsLnNpdHVhdGlvbiA9PSBjKXtcclxuICAgICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGUuZGV0YWlsLnBvcywgU1ZHLm1vcnBoKGUuZGV0YWlsLnBvcyksIGUuZGV0YWlsLmVhc2VkLCBjKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAvLyBzZWUgYWJvdmVcclxuICAgICAgdGhpcy50YXJnZXQoKS5vZmYoJ2R1cmluZy5meCcsIHdyYXBwZXIpLm9uKCdkdXJpbmcuZngnLCB3cmFwcGVyKVxyXG5cclxuICAgICAgdGhpcy5hZnRlcihmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMub2ZmKCdkdXJpbmcuZngnLCB3cmFwcGVyKVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuX2NhbGxTdGFydCgpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbHMgYWZ0ZXIgQUxMIGFuaW1hdGlvbnMgaW4gdGhlIHF1ZXVlIGFyZSBmaW5pc2hlZFxyXG4gICwgYWZ0ZXJBbGw6IGZ1bmN0aW9uKGZuKXtcclxuICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKGUpe1xyXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMpXHJcbiAgICAgICAgICAgIHRoaXMub2ZmKCdhbGxmaW5pc2hlZC5meCcsIHdyYXBwZXIpXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAvLyBzZWUgYWJvdmVcclxuICAgICAgdGhpcy50YXJnZXQoKS5vZmYoJ2FsbGZpbmlzaGVkLmZ4Jywgd3JhcHBlcikub24oJ2FsbGZpbmlzaGVkLmZ4Jywgd3JhcHBlcilcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhcnQoKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGxzIG9uIGV2ZXJ5IGFuaW1hdGlvbiBzdGVwIGZvciBhbGwgYW5pbWF0aW9uc1xyXG4gICwgZHVyaW5nQWxsOiBmdW5jdGlvbihmbil7XHJcbiAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZS5kZXRhaWwucG9zLCBTVkcubW9ycGgoZS5kZXRhaWwucG9zKSwgZS5kZXRhaWwuZWFzZWQsIGUuZGV0YWlsLnNpdHVhdGlvbilcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMudGFyZ2V0KCkub2ZmKCdkdXJpbmcuZngnLCB3cmFwcGVyKS5vbignZHVyaW5nLmZ4Jywgd3JhcHBlcilcclxuXHJcbiAgICAgIHRoaXMuYWZ0ZXJBbGwoZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLm9mZignZHVyaW5nLmZ4Jywgd3JhcHBlcilcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhcnQoKVxyXG4gICAgfVxyXG5cclxuICAsIGxhc3Q6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpdHVhdGlvbnMubGVuZ3RoID8gdGhpcy5zaXR1YXRpb25zW3RoaXMuc2l0dWF0aW9ucy5sZW5ndGgtMV0gOiB0aGlzLnNpdHVhdGlvblxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZHMgb25lIHByb3BlcnR5IHRvIHRoZSBhbmltYXRpb25zXHJcbiAgLCBhZGQ6IGZ1bmN0aW9uKG1ldGhvZCwgYXJncywgdHlwZSl7XHJcbiAgICAgIHRoaXMubGFzdCgpW3R5cGUgfHwgJ2FuaW1hdGlvbnMnXVttZXRob2RdID0gYXJnc1xyXG4gICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YXJ0KClcclxuICAgIH1cclxuXHJcbiAgICAvKiogcGVyZm9ybSBvbmUgc3RlcCBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKiAgQHBhcmFtIGlnbm9yZVRpbWUgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gaWdub3JlIHRpbWUgYW5kIHVzZSBwb3NpdGlvbiBkaXJlY3RseSBvciByZWNhbGN1bGF0ZSBwb3NpdGlvbiBiYXNlZCBvbiB0aW1lXHJcbiAgICAgKiAgQHJldHVybiB0aGlzXHJcbiAgICAgKi9cclxuICAsIHN0ZXA6IGZ1bmN0aW9uKGlnbm9yZVRpbWUpe1xyXG5cclxuICAgICAgLy8gY29udmVydCBjdXJyZW50IHRpbWUgdG8gYW4gYWJzb2x1dGUgcG9zaXRpb25cclxuICAgICAgaWYoIWlnbm9yZVRpbWUpIHRoaXMuYWJzUG9zID0gdGhpcy50aW1lVG9BYnNQb3MoK25ldyBEYXRlKVxyXG5cclxuICAgICAgLy8gVGhpcyBwYXJ0IGNvbnZlcnQgYW4gYWJzb2x1dGUgcG9zaXRpb24gdG8gYSBwb3NpdGlvblxyXG4gICAgICBpZih0aGlzLnNpdHVhdGlvbi5sb29wcyAhPT0gZmFsc2UpIHtcclxuICAgICAgICB2YXIgYWJzUG9zLCBhYnNQb3NJbnQsIGxhc3RMb29wXHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBpcyBiZWxvdyAwLCB3ZSBqdXN0IHRyZWF0IGl0IGFzIGlmIGl0IHdhcyAwXHJcbiAgICAgICAgYWJzUG9zID0gTWF0aC5tYXgodGhpcy5hYnNQb3MsIDApXHJcbiAgICAgICAgYWJzUG9zSW50ID0gTWF0aC5mbG9vcihhYnNQb3MpXHJcblxyXG4gICAgICAgIGlmKHRoaXMuc2l0dWF0aW9uLmxvb3BzID09PSB0cnVlIHx8IGFic1Bvc0ludCA8IHRoaXMuc2l0dWF0aW9uLmxvb3BzKSB7XHJcbiAgICAgICAgICB0aGlzLnBvcyA9IGFic1BvcyAtIGFic1Bvc0ludFxyXG4gICAgICAgICAgbGFzdExvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wXHJcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5sb29wID0gYWJzUG9zSW50XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuYWJzUG9zID0gdGhpcy5zaXR1YXRpb24ubG9vcHNcclxuICAgICAgICAgIHRoaXMucG9zID0gMVxyXG4gICAgICAgICAgLy8gVGhlIC0xIGhlcmUgaXMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIHRvZ2dsZSByZXZlcnNlZCB3aGVuIGFsbCB0aGUgbG9vcHMgaGF2ZSBiZWVuIGNvbXBsZXRlZFxyXG4gICAgICAgICAgbGFzdExvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wIC0gMVxyXG4gICAgICAgICAgdGhpcy5zaXR1YXRpb24ubG9vcCA9IHRoaXMuc2l0dWF0aW9uLmxvb3BzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLnNpdHVhdGlvbi5yZXZlcnNpbmcpIHtcclxuICAgICAgICAgIC8vIFRvZ2dsZSByZXZlcnNlZCBpZiBhbiBvZGQgbnVtYmVyIG9mIGxvb3BzIGFzIG9jY3VyZWQgc2luY2UgdGhlIGxhc3QgY2FsbCBvZiBzdGVwXHJcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCA9IHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkICE9IEJvb2xlYW4oKHRoaXMuc2l0dWF0aW9uLmxvb3AgLSBsYXN0TG9vcCkgJSAyKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGxvb3AsIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBtdXN0IG5vdCBiZSBhYm92ZSAxXHJcbiAgICAgICAgdGhpcy5hYnNQb3MgPSBNYXRoLm1pbih0aGlzLmFic1BvcywgMSlcclxuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuYWJzUG9zXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHdoaWxlIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBjYW4gYmUgYmVsb3cgMCwgdGhlIHBvc2l0aW9uIG11c3Qgbm90IGJlIGJlbG93IDBcclxuICAgICAgaWYodGhpcy5wb3MgPCAwKSB0aGlzLnBvcyA9IDBcclxuXHJcbiAgICAgIGlmKHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkKSB0aGlzLnBvcyA9IDEgLSB0aGlzLnBvc1xyXG5cclxuXHJcbiAgICAgIC8vIGFwcGx5IGVhc2luZ1xyXG4gICAgICB2YXIgZWFzZWQgPSB0aGlzLnNpdHVhdGlvbi5lYXNlKHRoaXMucG9zKVxyXG5cclxuICAgICAgLy8gY2FsbCBvbmNlLWNhbGxiYWNrc1xyXG4gICAgICBmb3IodmFyIGkgaW4gdGhpcy5zaXR1YXRpb24ub25jZSl7XHJcbiAgICAgICAgaWYoaSA+IHRoaXMubGFzdFBvcyAmJiBpIDw9IGVhc2VkKXtcclxuICAgICAgICAgIHRoaXMuc2l0dWF0aW9uLm9uY2VbaV0uY2FsbCh0aGlzLnRhcmdldCgpLCB0aGlzLnBvcywgZWFzZWQpXHJcbiAgICAgICAgICBkZWxldGUgdGhpcy5zaXR1YXRpb24ub25jZVtpXVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmlyZSBkdXJpbmcgY2FsbGJhY2sgd2l0aCBwb3NpdGlvbiwgZWFzZWQgcG9zaXRpb24gYW5kIGN1cnJlbnQgc2l0dWF0aW9uIGFzIHBhcmFtZXRlclxyXG4gICAgICBpZih0aGlzLmFjdGl2ZSkgdGhpcy50YXJnZXQoKS5maXJlKCdkdXJpbmcnLCB7cG9zOiB0aGlzLnBvcywgZWFzZWQ6IGVhc2VkLCBmeDogdGhpcywgc2l0dWF0aW9uOiB0aGlzLnNpdHVhdGlvbn0pXHJcblxyXG4gICAgICAvLyB0aGUgdXNlciBtYXkgY2FsbCBzdG9wIG9yIGZpbmlzaCBpbiB0aGUgZHVyaW5nIGNhbGxiYWNrXHJcbiAgICAgIC8vIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIHN0aWxsIGhhdmUgYSB2YWxpZCBzaXR1YXRpb25cclxuICAgICAgaWYoIXRoaXMuc2l0dWF0aW9uKXtcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhcHBseSB0aGUgYWN0dWFsIGFuaW1hdGlvbiB0byBldmVyeSBwcm9wZXJ0eVxyXG4gICAgICB0aGlzLmVhY2hBdCgpXHJcblxyXG4gICAgICAvLyBkbyBmaW5hbCBjb2RlIHdoZW4gc2l0dWF0aW9uIGlzIGZpbmlzaGVkXHJcbiAgICAgIGlmKCh0aGlzLnBvcyA9PSAxICYmICF0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCkgfHwgKHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkICYmIHRoaXMucG9zID09IDApKXtcclxuXHJcbiAgICAgICAgLy8gc3RvcCBhbmltYXRpb24gY2FsbGJhY2tcclxuICAgICAgICB0aGlzLnN0b3BBbmltRnJhbWUoKVxyXG5cclxuICAgICAgICAvLyBmaXJlIGZpbmlzaGVkIGNhbGxiYWNrIHdpdGggY3VycmVudCBzaXR1YXRpb24gYXMgcGFyYW1ldGVyXHJcbiAgICAgICAgdGhpcy50YXJnZXQoKS5maXJlKCdmaW5pc2hlZCcsIHtmeDp0aGlzLCBzaXR1YXRpb246IHRoaXMuc2l0dWF0aW9ufSlcclxuXHJcbiAgICAgICAgaWYoIXRoaXMuc2l0dWF0aW9ucy5sZW5ndGgpe1xyXG4gICAgICAgICAgdGhpcy50YXJnZXQoKS5maXJlKCdhbGxmaW5pc2hlZCcpXHJcblxyXG4gICAgICAgICAgLy8gUmVjaGVjayB0aGUgbGVuZ3RoIHNpbmNlIHRoZSB1c2VyIG1heSBjYWxsIGFuaW1hdGUgaW4gdGhlIGFmdGVyQWxsIGNhbGxiYWNrXHJcbiAgICAgICAgICBpZighdGhpcy5zaXR1YXRpb25zLmxlbmd0aCl7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0KCkub2ZmKCcuZngnKSAvLyB0aGVyZSBzaG91bGRudCBiZSBhbnkgYmluZGluZyBsZWZ0LCBidXQgdG8gbWFrZSBzdXJlLi4uXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHN0YXJ0IG5leHQgYW5pbWF0aW9uXHJcbiAgICAgICAgaWYodGhpcy5hY3RpdmUpIHRoaXMuZGVxdWV1ZSgpXHJcbiAgICAgICAgZWxzZSB0aGlzLmNsZWFyQ3VycmVudCgpXHJcblxyXG4gICAgICB9ZWxzZSBpZighdGhpcy5wYXVzZWQgJiYgdGhpcy5hY3RpdmUpe1xyXG4gICAgICAgIC8vIHdlIGNvbnRpbnVlIGFuaW1hdGluZyB3aGVuIHdlIGFyZSBub3QgYXQgdGhlIGVuZFxyXG4gICAgICAgIHRoaXMuc3RhcnRBbmltRnJhbWUoKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzYXZlIGxhc3QgZWFzZWQgcG9zaXRpb24gZm9yIG9uY2UgY2FsbGJhY2sgdHJpZ2dlcmluZ1xyXG4gICAgICB0aGlzLmxhc3RQb3MgPSBlYXNlZFxyXG4gICAgICByZXR1cm4gdGhpc1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBjYWxjdWxhdGVzIHRoZSBzdGVwIGZvciBldmVyeSBwcm9wZXJ0eSBhbmQgY2FsbHMgYmxvY2sgd2l0aCBpdFxyXG4gICwgZWFjaEF0OiBmdW5jdGlvbigpe1xyXG4gICAgICB2YXIgaSwgbGVuLCBhdCwgc2VsZiA9IHRoaXMsIHRhcmdldCA9IHRoaXMudGFyZ2V0KCksIHMgPSB0aGlzLnNpdHVhdGlvblxyXG5cclxuICAgICAgLy8gYXBwbHkgYW5pbWF0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHRyb3VnaCBhIG1ldGhvZFxyXG4gICAgICBmb3IoaSBpbiBzLmFuaW1hdGlvbnMpe1xyXG5cclxuICAgICAgICBhdCA9IFtdLmNvbmNhdChzLmFuaW1hdGlvbnNbaV0pLm1hcChmdW5jdGlvbihlbCl7XHJcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIGVsICE9PSAnc3RyaW5nJyAmJiBlbC5hdCA/IGVsLmF0KHMuZWFzZShzZWxmLnBvcyksIHNlbGYucG9zKSA6IGVsXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgdGFyZ2V0W2ldLmFwcGx5KHRhcmdldCwgYXQpXHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhcHBseSBhbmltYXRpb24gd2hpY2ggaGFzIHRvIGJlIGFwcGxpZWQgd2l0aCBhdHRyKClcclxuICAgICAgZm9yKGkgaW4gcy5hdHRycyl7XHJcblxyXG4gICAgICAgIGF0ID0gW2ldLmNvbmNhdChzLmF0dHJzW2ldKS5tYXAoZnVuY3Rpb24oZWwpe1xyXG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbCAhPT0gJ3N0cmluZycgJiYgZWwuYXQgPyBlbC5hdChzLmVhc2Uoc2VsZi5wb3MpLCBzZWxmLnBvcykgOiBlbFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRhcmdldC5hdHRyLmFwcGx5KHRhcmdldCwgYXQpXHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhcHBseSBhbmltYXRpb24gd2hpY2ggaGFzIHRvIGJlIGFwcGxpZWQgd2l0aCBzdHlsZSgpXHJcbiAgICAgIGZvcihpIGluIHMuc3R5bGVzKXtcclxuXHJcbiAgICAgICAgYXQgPSBbaV0uY29uY2F0KHMuc3R5bGVzW2ldKS5tYXAoZnVuY3Rpb24oZWwpe1xyXG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbCAhPT0gJ3N0cmluZycgJiYgZWwuYXQgPyBlbC5hdChzLmVhc2Uoc2VsZi5wb3MpLCBzZWxmLnBvcykgOiBlbFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRhcmdldC5zdHlsZS5hcHBseSh0YXJnZXQsIGF0KVxyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYW5pbWF0ZSBpbml0aWFsVHJhbnNmb3JtYXRpb24gd2hpY2ggaGFzIHRvIGJlIGNoYWluZWRcclxuICAgICAgaWYocy50cmFuc2Zvcm1zLmxlbmd0aCl7XHJcblxyXG4gICAgICAgIC8vIGdldCBpbml0aWFsIGluaXRpYWxUcmFuc2Zvcm1hdGlvblxyXG4gICAgICAgIGF0ID0gcy5pbml0aWFsVHJhbnNmb3JtYXRpb25cclxuICAgICAgICBmb3IoaSA9IDAsIGxlbiA9IHMudHJhbnNmb3Jtcy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XHJcblxyXG4gICAgICAgICAgLy8gZ2V0IG5leHQgdHJhbnNmb3JtYXRpb24gaW4gY2hhaW5cclxuICAgICAgICAgIHZhciBhID0gcy50cmFuc2Zvcm1zW2ldXHJcblxyXG4gICAgICAgICAgLy8gbXVsdGlwbHkgbWF0cml4IGRpcmVjdGx5XHJcbiAgICAgICAgICBpZihhIGluc3RhbmNlb2YgU1ZHLk1hdHJpeCl7XHJcblxyXG4gICAgICAgICAgICBpZihhLnJlbGF0aXZlKXtcclxuICAgICAgICAgICAgICBhdCA9IGF0Lm11bHRpcGx5KG5ldyBTVkcuTWF0cml4KCkubW9ycGgoYSkuYXQocy5lYXNlKHRoaXMucG9zKSkpXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgIGF0ID0gYXQubW9ycGgoYSkuYXQocy5lYXNlKHRoaXMucG9zKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIHdoZW4gdHJhbnNmb3JtYXRpb24gaXMgYWJzb2x1dGUgd2UgaGF2ZSB0byByZXNldCB0aGUgbmVlZGVkIHRyYW5zZm9ybWF0aW9uIGZpcnN0XHJcbiAgICAgICAgICBpZighYS5yZWxhdGl2ZSlcclxuICAgICAgICAgICAgYS51bmRvKGF0LmV4dHJhY3QoKSlcclxuXHJcbiAgICAgICAgICAvLyBhbmQgcmVhcHBseSBpdCBhZnRlclxyXG4gICAgICAgICAgYXQgPSBhdC5tdWx0aXBseShhLmF0KHMuZWFzZSh0aGlzLnBvcykpKVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNldCBuZXcgbWF0cml4IG9uIGVsZW1lbnRcclxuICAgICAgICB0YXJnZXQubWF0cml4KGF0KVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gYWRkcyBhbiBvbmNlLWNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhdCBhIHNwZWNpZmljIHBvc2l0aW9uIGFuZCBuZXZlciBhZ2FpblxyXG4gICwgb25jZTogZnVuY3Rpb24ocG9zLCBmbiwgaXNFYXNlZCl7XHJcbiAgICAgIHZhciBjID0gdGhpcy5sYXN0KClcclxuICAgICAgaWYoIWlzRWFzZWQpIHBvcyA9IGMuZWFzZShwb3MpXHJcblxyXG4gICAgICBjLm9uY2VbcG9zXSA9IGZuXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAsIF9jYWxsU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhpcy5zdGFydCgpfS5iaW5kKHRoaXMpLCAwKVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4sIHBhcmVudDogU1ZHLkVsZW1lbnRcclxuXHJcbiAgLy8gQWRkIG1ldGhvZCB0byBwYXJlbnQgZWxlbWVudHNcclxuLCBjb25zdHJ1Y3Q6IHtcclxuICAgIC8vIEdldCBmeCBtb2R1bGUgb3IgY3JlYXRlIGEgbmV3IG9uZSwgdGhlbiBhbmltYXRlIHdpdGggZ2l2ZW4gZHVyYXRpb24gYW5kIGVhc2VcclxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uKG8sIGVhc2UsIGRlbGF5KSB7XHJcbiAgICAgIHJldHVybiAodGhpcy5meCB8fCAodGhpcy5meCA9IG5ldyBTVkcuRlgodGhpcykpKS5hbmltYXRlKG8sIGVhc2UsIGRlbGF5KVxyXG4gICAgfVxyXG4gICwgZGVsYXk6IGZ1bmN0aW9uKGRlbGF5KXtcclxuICAgICAgcmV0dXJuICh0aGlzLmZ4IHx8ICh0aGlzLmZ4ID0gbmV3IFNWRy5GWCh0aGlzKSkpLmRlbGF5KGRlbGF5KVxyXG4gICAgfVxyXG4gICwgc3RvcDogZnVuY3Rpb24oanVtcFRvRW5kLCBjbGVhclF1ZXVlKSB7XHJcbiAgICAgIGlmICh0aGlzLmZ4KVxyXG4gICAgICAgIHRoaXMuZnguc3RvcChqdW1wVG9FbmQsIGNsZWFyUXVldWUpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICwgZmluaXNoOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMuZngpXHJcbiAgICAgICAgdGhpcy5meC5maW5pc2goKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIFBhdXNlIGN1cnJlbnQgYW5pbWF0aW9uXHJcbiAgLCBwYXVzZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLmZ4KVxyXG4gICAgICAgIHRoaXMuZngucGF1c2UoKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIFBsYXkgcGF1c2VkIGN1cnJlbnQgYW5pbWF0aW9uXHJcbiAgLCBwbGF5OiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMuZngpXHJcbiAgICAgICAgdGhpcy5meC5wbGF5KClcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBTZXQvR2V0IHRoZSBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uc1xyXG4gICwgc3BlZWQ6IGZ1bmN0aW9uKHNwZWVkKSB7XHJcbiAgICAgIGlmICh0aGlzLmZ4KVxyXG4gICAgICAgIGlmIChzcGVlZCA9PSBudWxsKVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZnguc3BlZWQoKVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMuZnguc3BlZWQoc3BlZWQpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pXHJcblxyXG4vLyBNb3JwaE9iaiBpcyB1c2VkIHdoZW5ldmVyIG5vIG1vcnBoYWJsZSBvYmplY3QgaXMgZ2l2ZW5cclxuU1ZHLk1vcnBoT2JqID0gU1ZHLmludmVudCh7XHJcblxyXG4gIGNyZWF0ZTogZnVuY3Rpb24oZnJvbSwgdG8pe1xyXG4gICAgLy8gcHJlcGFyZSBjb2xvciBmb3IgbW9ycGhpbmdcclxuICAgIGlmKFNWRy5Db2xvci5pc0NvbG9yKHRvKSkgcmV0dXJuIG5ldyBTVkcuQ29sb3IoZnJvbSkubW9ycGgodG8pXHJcbiAgICAvLyBwcmVwYXJlIG51bWJlciBmb3IgbW9ycGhpbmdcclxuICAgIGlmKFNWRy5yZWdleC5udW1iZXJBbmRVbml0LnRlc3QodG8pKSByZXR1cm4gbmV3IFNWRy5OdW1iZXIoZnJvbSkubW9ycGgodG8pXHJcblxyXG4gICAgLy8gcHJlcGFyZSBmb3IgcGxhaW4gbW9ycGhpbmdcclxuICAgIHRoaXMudmFsdWUgPSBmcm9tXHJcbiAgICB0aGlzLmRlc3RpbmF0aW9uID0gdG9cclxuICB9XHJcblxyXG4sIGV4dGVuZDoge1xyXG4gICAgYXQ6IGZ1bmN0aW9uKHBvcywgcmVhbCl7XHJcbiAgICAgIHJldHVybiByZWFsIDwgMSA/IHRoaXMudmFsdWUgOiB0aGlzLmRlc3RpbmF0aW9uXHJcbiAgICB9LFxyXG5cclxuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSlcclxuXHJcblNWRy5leHRlbmQoU1ZHLkZYLCB7XHJcbiAgLy8gQWRkIGFuaW1hdGFibGUgYXR0cmlidXRlc1xyXG4gIGF0dHI6IGZ1bmN0aW9uKGEsIHYsIHJlbGF0aXZlKSB7XHJcbiAgICAvLyBhcHBseSBhdHRyaWJ1dGVzIGluZGl2aWR1YWxseVxyXG4gICAgaWYgKHR5cGVvZiBhID09ICdvYmplY3QnKSB7XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBhKVxyXG4gICAgICAgIHRoaXMuYXR0cihrZXksIGFba2V5XSlcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmFkZChhLCB2LCAnYXR0cnMnKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIEFkZCBhbmltYXRhYmxlIHN0eWxlc1xyXG4sIHN0eWxlOiBmdW5jdGlvbihzLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIHMgPT0gJ29iamVjdCcpXHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBzKVxyXG4gICAgICAgIHRoaXMuc3R5bGUoa2V5LCBzW2tleV0pXHJcblxyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLmFkZChzLCB2LCAnc3R5bGVzJylcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICAvLyBBbmltYXRhYmxlIHgtYXhpc1xyXG4sIHg6IGZ1bmN0aW9uKHgsIHJlbGF0aXZlKSB7XHJcbiAgICBpZih0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLkcpe1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybSh7eDp4fSwgcmVsYXRpdmUpXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG51bSA9IG5ldyBTVkcuTnVtYmVyKHgpXHJcbiAgICBudW0ucmVsYXRpdmUgPSByZWxhdGl2ZVxyXG4gICAgcmV0dXJuIHRoaXMuYWRkKCd4JywgbnVtKVxyXG4gIH1cclxuICAvLyBBbmltYXRhYmxlIHktYXhpc1xyXG4sIHk6IGZ1bmN0aW9uKHksIHJlbGF0aXZlKSB7XHJcbiAgICBpZih0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLkcpe1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybSh7eTp5fSwgcmVsYXRpdmUpXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG51bSA9IG5ldyBTVkcuTnVtYmVyKHkpXHJcbiAgICBudW0ucmVsYXRpdmUgPSByZWxhdGl2ZVxyXG4gICAgcmV0dXJuIHRoaXMuYWRkKCd5JywgbnVtKVxyXG4gIH1cclxuICAvLyBBbmltYXRhYmxlIGNlbnRlciB4LWF4aXNcclxuLCBjeDogZnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkKCdjeCcsIG5ldyBTVkcuTnVtYmVyKHgpKVxyXG4gIH1cclxuICAvLyBBbmltYXRhYmxlIGNlbnRlciB5LWF4aXNcclxuLCBjeTogZnVuY3Rpb24oeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkKCdjeScsIG5ldyBTVkcuTnVtYmVyKHkpKVxyXG4gIH1cclxuICAvLyBBZGQgYW5pbWF0YWJsZSBtb3ZlXHJcbiwgbW92ZTogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMueCh4KS55KHkpXHJcbiAgfVxyXG4gIC8vIEFkZCBhbmltYXRhYmxlIGNlbnRlclxyXG4sIGNlbnRlcjogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSlcclxuICB9XHJcbiAgLy8gQWRkIGFuaW1hdGFibGUgc2l6ZVxyXG4sIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIGlmICh0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLlRleHQpIHtcclxuICAgICAgLy8gYW5pbWF0ZSBmb250IHNpemUgZm9yIFRleHQgZWxlbWVudHNcclxuICAgICAgdGhpcy5hdHRyKCdmb250LXNpemUnLCB3aWR0aClcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBhbmltYXRlIGJib3ggYmFzZWQgc2l6ZSBmb3IgYWxsIG90aGVyIGVsZW1lbnRzXHJcbiAgICAgIHZhciBib3hcclxuXHJcbiAgICAgIGlmKCF3aWR0aCB8fCAhaGVpZ2h0KXtcclxuICAgICAgICBib3ggPSB0aGlzLnRhcmdldCgpLmJib3goKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZighd2lkdGgpe1xyXG4gICAgICAgIHdpZHRoID0gYm94LndpZHRoIC8gYm94LmhlaWdodCAgKiBoZWlnaHRcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoIWhlaWdodCl7XHJcbiAgICAgICAgaGVpZ2h0ID0gYm94LmhlaWdodCAvIGJveC53aWR0aCAgKiB3aWR0aFxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmFkZCgnd2lkdGgnICwgbmV3IFNWRy5OdW1iZXIod2lkdGgpKVxyXG4gICAgICAgICAgLmFkZCgnaGVpZ2h0JywgbmV3IFNWRy5OdW1iZXIoaGVpZ2h0KSlcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgLy8gQWRkIGFuaW1hdGFibGUgd2lkdGhcclxuLCB3aWR0aDogZnVuY3Rpb24od2lkdGgpIHtcclxuICAgIHJldHVybiB0aGlzLmFkZCgnd2lkdGgnLCBuZXcgU1ZHLk51bWJlcih3aWR0aCkpXHJcbiAgfVxyXG4gIC8vIEFkZCBhbmltYXRhYmxlIGhlaWdodFxyXG4sIGhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hZGQoJ2hlaWdodCcsIG5ldyBTVkcuTnVtYmVyKGhlaWdodCkpXHJcbiAgfVxyXG4gIC8vIEFkZCBhbmltYXRhYmxlIHBsb3RcclxuLCBwbG90OiBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XHJcbiAgICAvLyBMaW5lcyBjYW4gYmUgcGxvdHRlZCB3aXRoIDQgYXJndW1lbnRzXHJcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID09IDQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGxvdChbYSwgYiwgYywgZF0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYWRkKCdwbG90JywgbmV3ICh0aGlzLnRhcmdldCgpLm1vcnBoQXJyYXkpKGEpKVxyXG4gIH1cclxuICAvLyBBZGQgbGVhZGluZyBtZXRob2RcclxuLCBsZWFkaW5nOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0KCkubGVhZGluZyA/XHJcbiAgICAgIHRoaXMuYWRkKCdsZWFkaW5nJywgbmV3IFNWRy5OdW1iZXIodmFsdWUpKSA6XHJcbiAgICAgIHRoaXNcclxuICB9XHJcbiAgLy8gQWRkIGFuaW1hdGFibGUgdmlld2JveFxyXG4sIHZpZXdib3g6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIGlmICh0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLkNvbnRhaW5lcikge1xyXG4gICAgICB0aGlzLmFkZCgndmlld2JveCcsIG5ldyBTVkcuVmlld0JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuLCB1cGRhdGU6IGZ1bmN0aW9uKG8pIHtcclxuICAgIGlmICh0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLlN0b3ApIHtcclxuICAgICAgaWYgKHR5cGVvZiBvID09ICdudW1iZXInIHx8IG8gaW5zdGFuY2VvZiBTVkcuTnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKHtcclxuICAgICAgICAgIG9mZnNldDogIGFyZ3VtZW50c1swXVxyXG4gICAgICAgICwgY29sb3I6ICAgYXJndW1lbnRzWzFdXHJcbiAgICAgICAgLCBvcGFjaXR5OiBhcmd1bWVudHNbMl1cclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoby5vcGFjaXR5ICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1vcGFjaXR5Jywgby5vcGFjaXR5KVxyXG4gICAgICBpZiAoby5jb2xvciAgICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1jb2xvcicsIG8uY29sb3IpXHJcbiAgICAgIGlmIChvLm9mZnNldCAgIT0gbnVsbCkgdGhpcy5hdHRyKCdvZmZzZXQnLCBvLm9mZnNldClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufSlcclxuXG5TVkcuQm94ID0gU1ZHLmludmVudCh7XHJcbiAgY3JlYXRlOiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBpZiAodHlwZW9mIHggPT0gJ29iamVjdCcgJiYgISh4IGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQpKSB7XHJcbiAgICAgIC8vIGNocm9tZXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGhhcyBubyB4IGFuZCB5IHByb3BlcnR5XHJcbiAgICAgIHJldHVybiBTVkcuQm94LmNhbGwodGhpcywgeC5sZWZ0ICE9IG51bGwgPyB4LmxlZnQgOiB4LnggLCB4LnRvcCAhPSBudWxsID8geC50b3AgOiB4LnksIHgud2lkdGgsIHguaGVpZ2h0KVxyXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDQpIHtcclxuICAgICAgdGhpcy54ID0geFxyXG4gICAgICB0aGlzLnkgPSB5XHJcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aFxyXG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCBjZW50ZXIsIHJpZ2h0LCBib3R0b20uLi5cclxuICAgIGZ1bGxCb3godGhpcylcclxuICB9XHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBNZXJnZSByZWN0IGJveCB3aXRoIGFub3RoZXIsIHJldHVybiBhIG5ldyBpbnN0YW5jZVxyXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKGJveCkge1xyXG4gICAgICB2YXIgYiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKClcclxuXHJcbiAgICAgIC8vIG1lcmdlIGJveGVzXHJcbiAgICAgIGIueCAgICAgID0gTWF0aC5taW4odGhpcy54LCBib3gueClcclxuICAgICAgYi55ICAgICAgPSBNYXRoLm1pbih0aGlzLnksIGJveC55KVxyXG4gICAgICBiLndpZHRoICA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsICBib3gueCArIGJveC53aWR0aCkgIC0gYi54XHJcbiAgICAgIGIuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIGJveC55ICsgYm94LmhlaWdodCkgLSBiLnlcclxuXHJcbiAgICAgIHJldHVybiBmdWxsQm94KGIpXHJcbiAgICB9XHJcblxyXG4gICwgdHJhbnNmb3JtOiBmdW5jdGlvbihtKSB7XHJcbiAgICAgIHZhciB4TWluID0gSW5maW5pdHksIHhNYXggPSAtSW5maW5pdHksIHlNaW4gPSBJbmZpbml0eSwgeU1heCA9IC1JbmZpbml0eSwgcCwgYmJveFxyXG5cclxuICAgICAgdmFyIHB0cyA9IFtcclxuICAgICAgICBuZXcgU1ZHLlBvaW50KHRoaXMueCwgdGhpcy55KSxcclxuICAgICAgICBuZXcgU1ZHLlBvaW50KHRoaXMueDIsIHRoaXMueSksXHJcbiAgICAgICAgbmV3IFNWRy5Qb2ludCh0aGlzLngsIHRoaXMueTIpLFxyXG4gICAgICAgIG5ldyBTVkcuUG9pbnQodGhpcy54MiwgdGhpcy55MilcclxuICAgICAgXVxyXG5cclxuICAgICAgcHRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xyXG4gICAgICAgIHAgPSBwLnRyYW5zZm9ybShtKVxyXG4gICAgICAgIHhNaW4gPSBNYXRoLm1pbih4TWluLHAueClcclxuICAgICAgICB4TWF4ID0gTWF0aC5tYXgoeE1heCxwLngpXHJcbiAgICAgICAgeU1pbiA9IE1hdGgubWluKHlNaW4scC55KVxyXG4gICAgICAgIHlNYXggPSBNYXRoLm1heCh5TWF4LHAueSlcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGJib3ggPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpXHJcbiAgICAgIGJib3gueCA9IHhNaW5cclxuICAgICAgYmJveC53aWR0aCA9IHhNYXgteE1pblxyXG4gICAgICBiYm94LnkgPSB5TWluXHJcbiAgICAgIGJib3guaGVpZ2h0ID0geU1heC15TWluXHJcblxyXG4gICAgICBmdWxsQm94KGJib3gpXHJcblxyXG4gICAgICByZXR1cm4gYmJveFxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXHJcblNWRy5CQm94ID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZVxyXG4gIGNyZWF0ZTogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgU1ZHLkJveC5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXHJcblxyXG4gICAgLy8gZ2V0IHZhbHVlcyBpZiBlbGVtZW50IGlzIGdpdmVuXHJcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KSB7XHJcbiAgICAgIHZhciBib3hcclxuXHJcbiAgICAgIC8vIHllcyB0aGlzIGlzIHVnbHksIGJ1dCBGaXJlZm94IGNhbiBiZSBhIGJpdGNoIHdoZW4gaXQgY29tZXMgdG8gZWxlbWVudHMgdGhhdCBhcmUgbm90IHlldCByZW5kZXJlZFxyXG4gICAgICB0cnkge1xyXG5cclxuICAgICAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyl7XHJcbiAgICAgICAgICAvLyBUaGlzIGlzIElFIC0gaXQgZG9lcyBub3Qgc3VwcG9ydCBjb250YWlucygpIGZvciB0b3AtbGV2ZWwgU1ZHc1xyXG4gICAgICAgICAgdmFyIHRvcFBhcmVudCA9IGVsZW1lbnQubm9kZVxyXG4gICAgICAgICAgd2hpbGUgKHRvcFBhcmVudC5wYXJlbnROb2RlKXtcclxuICAgICAgICAgICAgdG9wUGFyZW50ID0gdG9wUGFyZW50LnBhcmVudE5vZGVcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0b3BQYXJlbnQgIT0gZG9jdW1lbnQpIHRocm93IG5ldyBFeGNlcHRpb24oJ0VsZW1lbnQgbm90IGluIHRoZSBkb20nKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyB0aGUgZWxlbWVudCBpcyBOT1QgaW4gdGhlIGRvbSwgdGhyb3cgZXJyb3JcclxuICAgICAgICAgIGlmKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWxlbWVudC5ub2RlKSkgdGhyb3cgbmV3IEV4Y2VwdGlvbignRWxlbWVudCBub3QgaW4gdGhlIGRvbScpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmaW5kIG5hdGl2ZSBiYm94XHJcbiAgICAgICAgYm94ID0gZWxlbWVudC5ub2RlLmdldEJCb3goKVxyXG4gICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICBpZihlbGVtZW50IGluc3RhbmNlb2YgU1ZHLlNoYXBlKXtcclxuICAgICAgICAgIHZhciBjbG9uZSA9IGVsZW1lbnQuY2xvbmUoU1ZHLnBhcnNlci5kcmF3Lmluc3RhbmNlKS5zaG93KClcclxuICAgICAgICAgIGJveCA9IGNsb25lLm5vZGUuZ2V0QkJveCgpXHJcbiAgICAgICAgICBjbG9uZS5yZW1vdmUoKVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgYm94ID0ge1xyXG4gICAgICAgICAgICB4OiAgICAgIGVsZW1lbnQubm9kZS5jbGllbnRMZWZ0XHJcbiAgICAgICAgICAsIHk6ICAgICAgZWxlbWVudC5ub2RlLmNsaWVudFRvcFxyXG4gICAgICAgICAgLCB3aWR0aDogIGVsZW1lbnQubm9kZS5jbGllbnRXaWR0aFxyXG4gICAgICAgICAgLCBoZWlnaHQ6IGVsZW1lbnQubm9kZS5jbGllbnRIZWlnaHRcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFNWRy5Cb3guY2FsbCh0aGlzLCBib3gpXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgLy8gRGVmaW5lIGFuY2VzdG9yXHJcbiwgaW5oZXJpdDogU1ZHLkJveFxyXG5cclxuICAvLyBEZWZpbmUgUGFyZW50XHJcbiwgcGFyZW50OiBTVkcuRWxlbWVudFxyXG5cclxuICAvLyBDb25zdHJ1Y3RvclxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gR2V0IGJvdW5kaW5nIGJveFxyXG4gICAgYmJveDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLkJCb3godGhpcylcclxuICAgIH1cclxuICB9XHJcblxyXG59KVxyXG5cclxuU1ZHLkJCb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU1ZHLkJCb3hcclxuXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcbiAgdGJveDogZnVuY3Rpb24oKXtcclxuICAgIGNvbnNvbGUud2FybignVXNlIG9mIFRCb3ggaXMgZGVwcmVjYXRlZCBhbmQgbWFwcGVkIHRvIFJCb3guIFVzZSAucmJveCgpIGluc3RlYWQuJylcclxuICAgIHJldHVybiB0aGlzLnJib3godGhpcy5kb2MoKSlcclxuICB9XHJcbn0pXHJcblxyXG5TVkcuUkJveCA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIFNWRy5Cb3guYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKVxyXG5cclxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQpIHtcclxuICAgICAgU1ZHLkJveC5jYWxsKHRoaXMsIGVsZW1lbnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSlcclxuICAgIH1cclxuICB9XHJcblxyXG4sIGluaGVyaXQ6IFNWRy5Cb3hcclxuXHJcbiAgLy8gZGVmaW5lIFBhcmVudFxyXG4sIHBhcmVudDogU1ZHLkVsZW1lbnRcclxuXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICBhZGRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAvLyBvZmZzZXQgYnkgd2luZG93IHNjcm9sbCBwb3NpdGlvbiwgYmVjYXVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgY2hhbmdlcyB3aGVuIHdpbmRvdyBpcyBzY3JvbGxlZFxyXG4gICAgICB0aGlzLnggKz0gd2luZG93LnBhZ2VYT2Zmc2V0XHJcbiAgICAgIHRoaXMueSArPSB3aW5kb3cucGFnZVlPZmZzZXRcclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENvbnN0cnVjdG9yXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBHZXQgcmVjdCBib3hcclxuICAgIHJib3g6IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgIGlmIChlbCkgcmV0dXJuIG5ldyBTVkcuUkJveCh0aGlzKS50cmFuc2Zvcm0oZWwuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpKVxyXG4gICAgICByZXR1cm4gbmV3IFNWRy5SQm94KHRoaXMpLmFkZE9mZnNldCgpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSlcclxuXHJcblNWRy5SQm94LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWRy5SQm94XHJcblxuU1ZHLk1hdHJpeCA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG4gICAgdmFyIGksIGJhc2UgPSBhcnJheVRvTWF0cml4KFsxLCAwLCAwLCAxLCAwLCAwXSlcclxuXHJcbiAgICAvLyBlbnN1cmUgc291cmNlIGFzIG9iamVjdFxyXG4gICAgc291cmNlID0gc291cmNlIGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQgP1xyXG4gICAgICBzb3VyY2UubWF0cml4aWZ5KCkgOlxyXG4gICAgdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgP1xyXG4gICAgICBhcnJheVRvTWF0cml4KHNvdXJjZS5zcGxpdChTVkcucmVnZXguZGVsaW1pdGVyKS5tYXAocGFyc2VGbG9hdCkpIDpcclxuICAgIGFyZ3VtZW50cy5sZW5ndGggPT0gNiA/XHJcbiAgICAgIGFycmF5VG9NYXRyaXgoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6XHJcbiAgICBBcnJheS5pc0FycmF5KHNvdXJjZSkgP1xyXG4gICAgICBhcnJheVRvTWF0cml4KHNvdXJjZSkgOlxyXG4gICAgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcgP1xyXG4gICAgICBzb3VyY2UgOiBiYXNlXHJcblxyXG4gICAgLy8gbWVyZ2Ugc291cmNlXHJcbiAgICBmb3IgKGkgPSBhYmNkZWYubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXHJcbiAgICAgIHRoaXNbYWJjZGVmW2ldXSA9IHNvdXJjZVthYmNkZWZbaV1dICE9IG51bGwgP1xyXG4gICAgICAgIHNvdXJjZVthYmNkZWZbaV1dIDogYmFzZVthYmNkZWZbaV1dXHJcbiAgfVxyXG5cclxuICAvLyBBZGQgbWV0aG9kc1xyXG4sIGV4dGVuZDoge1xyXG4gICAgLy8gRXh0cmFjdCBpbmRpdmlkdWFsIHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgZXh0cmFjdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8vIGZpbmQgZGVsdGEgdHJhbnNmb3JtIHBvaW50c1xyXG4gICAgICB2YXIgcHggICAgPSBkZWx0YVRyYW5zZm9ybVBvaW50KHRoaXMsIDAsIDEpXHJcbiAgICAgICAgLCBweSAgICA9IGRlbHRhVHJhbnNmb3JtUG9pbnQodGhpcywgMSwgMClcclxuICAgICAgICAsIHNrZXdYID0gMTgwIC8gTWF0aC5QSSAqIE1hdGguYXRhbjIocHgueSwgcHgueCkgLSA5MFxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAvLyB0cmFuc2xhdGlvblxyXG4gICAgICAgIHg6ICAgICAgICB0aGlzLmVcclxuICAgICAgLCB5OiAgICAgICAgdGhpcy5mXHJcbiAgICAgICwgdHJhbnNmb3JtZWRYOih0aGlzLmUgKiBNYXRoLmNvcyhza2V3WCAqIE1hdGguUEkgLyAxODApICsgdGhpcy5mICogTWF0aC5zaW4oc2tld1ggKiBNYXRoLlBJIC8gMTgwKSkgLyBNYXRoLnNxcnQodGhpcy5hICogdGhpcy5hICsgdGhpcy5iICogdGhpcy5iKVxyXG4gICAgICAsIHRyYW5zZm9ybWVkWToodGhpcy5mICogTWF0aC5jb3Moc2tld1ggKiBNYXRoLlBJIC8gMTgwKSArIHRoaXMuZSAqIE1hdGguc2luKC1za2V3WCAqIE1hdGguUEkgLyAxODApKSAvIE1hdGguc3FydCh0aGlzLmMgKiB0aGlzLmMgKyB0aGlzLmQgKiB0aGlzLmQpXHJcbiAgICAgICAgLy8gc2tld1xyXG4gICAgICAsIHNrZXdYOiAgICAtc2tld1hcclxuICAgICAgLCBza2V3WTogICAgMTgwIC8gTWF0aC5QSSAqIE1hdGguYXRhbjIocHkueSwgcHkueClcclxuICAgICAgICAvLyBzY2FsZVxyXG4gICAgICAsIHNjYWxlWDogICBNYXRoLnNxcnQodGhpcy5hICogdGhpcy5hICsgdGhpcy5iICogdGhpcy5iKVxyXG4gICAgICAsIHNjYWxlWTogICBNYXRoLnNxcnQodGhpcy5jICogdGhpcy5jICsgdGhpcy5kICogdGhpcy5kKVxyXG4gICAgICAgIC8vIHJvdGF0aW9uXHJcbiAgICAgICwgcm90YXRpb246IHNrZXdYXHJcbiAgICAgICwgYTogdGhpcy5hXHJcbiAgICAgICwgYjogdGhpcy5iXHJcbiAgICAgICwgYzogdGhpcy5jXHJcbiAgICAgICwgZDogdGhpcy5kXHJcbiAgICAgICwgZTogdGhpcy5lXHJcbiAgICAgICwgZjogdGhpcy5mXHJcbiAgICAgICwgbWF0cml4OiBuZXcgU1ZHLk1hdHJpeCh0aGlzKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDbG9uZSBtYXRyaXhcclxuICAsIGNsb25lOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIG5ldyBTVkcuTWF0cml4KHRoaXMpXHJcbiAgICB9XHJcbiAgICAvLyBNb3JwaCBvbmUgbWF0cml4IGludG8gYW5vdGhlclxyXG4gICwgbW9ycGg6IGZ1bmN0aW9uKG1hdHJpeCkge1xyXG4gICAgICAvLyBzdG9yZSBuZXcgZGVzdGluYXRpb25cclxuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuTWF0cml4KG1hdHJpeClcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBHZXQgbW9ycGhlZCBtYXRyaXggYXQgYSBnaXZlbiBwb3NpdGlvblxyXG4gICwgYXQ6IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXHJcbiAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXNcclxuXHJcbiAgICAgIC8vIGNhbGN1bGF0ZSBtb3JwaGVkIG1hdHJpeCBhdCBhIGdpdmVuIHBvc2l0aW9uXHJcbiAgICAgIHZhciBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCh7XHJcbiAgICAgICAgYTogdGhpcy5hICsgKHRoaXMuZGVzdGluYXRpb24uYSAtIHRoaXMuYSkgKiBwb3NcclxuICAgICAgLCBiOiB0aGlzLmIgKyAodGhpcy5kZXN0aW5hdGlvbi5iIC0gdGhpcy5iKSAqIHBvc1xyXG4gICAgICAsIGM6IHRoaXMuYyArICh0aGlzLmRlc3RpbmF0aW9uLmMgLSB0aGlzLmMpICogcG9zXHJcbiAgICAgICwgZDogdGhpcy5kICsgKHRoaXMuZGVzdGluYXRpb24uZCAtIHRoaXMuZCkgKiBwb3NcclxuICAgICAgLCBlOiB0aGlzLmUgKyAodGhpcy5kZXN0aW5hdGlvbi5lIC0gdGhpcy5lKSAqIHBvc1xyXG4gICAgICAsIGY6IHRoaXMuZiArICh0aGlzLmRlc3RpbmF0aW9uLmYgLSB0aGlzLmYpICogcG9zXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICByZXR1cm4gbWF0cml4XHJcbiAgICB9XHJcbiAgICAvLyBNdWx0aXBsaWVzIGJ5IGdpdmVuIG1hdHJpeFxyXG4gICwgbXVsdGlwbHk6IGZ1bmN0aW9uKG1hdHJpeCkge1xyXG4gICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5uYXRpdmUoKS5tdWx0aXBseShwYXJzZU1hdHJpeChtYXRyaXgpLm5hdGl2ZSgpKSlcclxuICAgIH1cclxuICAgIC8vIEludmVyc2VzIG1hdHJpeFxyXG4gICwgaW52ZXJzZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5hdGl2ZSgpLmludmVyc2UoKSlcclxuICAgIH1cclxuICAgIC8vIFRyYW5zbGF0ZSBtYXRyaXhcclxuICAsIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5uYXRpdmUoKS50cmFuc2xhdGUoeCB8fCAwLCB5IHx8IDApKVxyXG4gICAgfVxyXG4gICAgLy8gU2NhbGUgbWF0cml4XHJcbiAgLCBzY2FsZTogZnVuY3Rpb24oeCwgeSwgY3gsIGN5KSB7XHJcbiAgICAgIC8vIHN1cHBvcnQgdW5pZm9ybWFsIHNjYWxlXHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICB5ID0geFxyXG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMykge1xyXG4gICAgICAgIGN5ID0gY3hcclxuICAgICAgICBjeCA9IHlcclxuICAgICAgICB5ID0geFxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5hcm91bmQoY3gsIGN5LCBuZXcgU1ZHLk1hdHJpeCh4LCAwLCAwLCB5LCAwLCAwKSlcclxuICAgIH1cclxuICAgIC8vIFJvdGF0ZSBtYXRyaXhcclxuICAsIHJvdGF0ZTogZnVuY3Rpb24ociwgY3gsIGN5KSB7XHJcbiAgICAgIC8vIGNvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXHJcbiAgICAgIHIgPSBTVkcudXRpbHMucmFkaWFucyhyKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuYXJvdW5kKGN4LCBjeSwgbmV3IFNWRy5NYXRyaXgoTWF0aC5jb3MociksIE1hdGguc2luKHIpLCAtTWF0aC5zaW4ociksIE1hdGguY29zKHIpLCAwLCAwKSlcclxuICAgIH1cclxuICAgIC8vIEZsaXAgbWF0cml4IG9uIHggb3IgeSwgYXQgYSBnaXZlbiBvZmZzZXRcclxuICAsIGZsaXA6IGZ1bmN0aW9uKGEsIG8pIHtcclxuICAgICAgcmV0dXJuIGEgPT0gJ3gnID9cclxuICAgICAgICAgIHRoaXMuc2NhbGUoLTEsIDEsIG8sIDApIDpcclxuICAgICAgICBhID09ICd5JyA/XHJcbiAgICAgICAgICB0aGlzLnNjYWxlKDEsIC0xLCAwLCBvKSA6XHJcbiAgICAgICAgICB0aGlzLnNjYWxlKC0xLCAtMSwgYSwgbyAhPSBudWxsID8gbyA6IGEpXHJcbiAgICB9XHJcbiAgICAvLyBTa2V3XHJcbiAgLCBza2V3OiBmdW5jdGlvbih4LCB5LCBjeCwgY3kpIHtcclxuICAgICAgLy8gc3VwcG9ydCB1bmlmb3JtYWwgc2tld1xyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgeSA9IHhcclxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDMpIHtcclxuICAgICAgICBjeSA9IGN4XHJcbiAgICAgICAgY3ggPSB5XHJcbiAgICAgICAgeSA9IHhcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY29udmVydCBkZWdyZWVzIHRvIHJhZGlhbnNcclxuICAgICAgeCA9IFNWRy51dGlscy5yYWRpYW5zKHgpXHJcbiAgICAgIHkgPSBTVkcudXRpbHMucmFkaWFucyh5KVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuYXJvdW5kKGN4LCBjeSwgbmV3IFNWRy5NYXRyaXgoMSwgTWF0aC50YW4oeSksIE1hdGgudGFuKHgpLCAxLCAwLCAwKSlcclxuICAgIH1cclxuICAgIC8vIFNrZXdYXHJcbiAgLCBza2V3WDogZnVuY3Rpb24oeCwgY3gsIGN5KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNrZXcoeCwgMCwgY3gsIGN5KVxyXG4gICAgfVxyXG4gICAgLy8gU2tld1lcclxuICAsIHNrZXdZOiBmdW5jdGlvbih5LCBjeCwgY3kpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2tldygwLCB5LCBjeCwgY3kpXHJcbiAgICB9XHJcbiAgICAvLyBUcmFuc2Zvcm0gYXJvdW5kIGEgY2VudGVyIHBvaW50XHJcbiAgLCBhcm91bmQ6IGZ1bmN0aW9uKGN4LCBjeSwgbWF0cml4KSB7XHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgLm11bHRpcGx5KG5ldyBTVkcuTWF0cml4KDEsIDAsIDAsIDEsIGN4IHx8IDAsIGN5IHx8IDApKVxyXG4gICAgICAgIC5tdWx0aXBseShtYXRyaXgpXHJcbiAgICAgICAgLm11bHRpcGx5KG5ldyBTVkcuTWF0cml4KDEsIDAsIDAsIDEsIC1jeCB8fCAwLCAtY3kgfHwgMCkpXHJcbiAgICB9XHJcbiAgICAvLyBDb252ZXJ0IHRvIG5hdGl2ZSBTVkdNYXRyaXhcclxuICAsIG5hdGl2ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8vIGNyZWF0ZSBuZXcgbWF0cml4XHJcbiAgICAgIHZhciBtYXRyaXggPSBTVkcucGFyc2VyLm5hdGl2ZS5jcmVhdGVTVkdNYXRyaXgoKVxyXG5cclxuICAgICAgLy8gdXBkYXRlIHdpdGggY3VycmVudCB2YWx1ZXNcclxuICAgICAgZm9yICh2YXIgaSA9IGFiY2RlZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICBtYXRyaXhbYWJjZGVmW2ldXSA9IHRoaXNbYWJjZGVmW2ldXVxyXG5cclxuICAgICAgcmV0dXJuIG1hdHJpeFxyXG4gICAgfVxyXG4gICAgLy8gQ29udmVydCBtYXRyaXggdG8gc3RyaW5nXHJcbiAgLCB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiAnbWF0cml4KCcgKyB0aGlzLmEgKyAnLCcgKyB0aGlzLmIgKyAnLCcgKyB0aGlzLmMgKyAnLCcgKyB0aGlzLmQgKyAnLCcgKyB0aGlzLmUgKyAnLCcgKyB0aGlzLmYgKyAnKSdcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIERlZmluZSBwYXJlbnRcclxuLCBwYXJlbnQ6IFNWRy5FbGVtZW50XHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBHZXQgY3VycmVudCBtYXRyaXhcclxuICAgIGN0bTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5vZGUuZ2V0Q1RNKCkpXHJcbiAgICB9LFxyXG4gICAgLy8gR2V0IGN1cnJlbnQgc2NyZWVuIG1hdHJpeFxyXG4gICAgc2NyZWVuQ1RNOiBmdW5jdGlvbigpIHtcclxuICAgICAgLyogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM0NDUzN1xyXG4gICAgICAgICBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIEZGIGRvZXMgbm90IHJldHVybiB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcbiAgICAgICAgIGZvciB0aGUgaW5uZXIgY29vcmRpbmF0ZSBzeXN0ZW0gd2hlbiBnZXRTY3JlZW5DVE0oKSBpcyBjYWxsZWQgb24gbmVzdGVkIHN2Z3MuXHJcbiAgICAgICAgIEhvd2V2ZXIgYWxsIG90aGVyIEJyb3dzZXJzIGRvIHRoYXQgKi9cclxuICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIFNWRy5OZXN0ZWQpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMucmVjdCgxLDEpXHJcbiAgICAgICAgdmFyIG0gPSByZWN0Lm5vZGUuZ2V0U2NyZWVuQ1RNKClcclxuICAgICAgICByZWN0LnJlbW92ZSgpXHJcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuTWF0cml4KG0pXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ldyBTVkcuTWF0cml4KHRoaXMubm9kZS5nZXRTY3JlZW5DVE0oKSlcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxufSlcclxuXG5TVkcuUG9pbnQgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplXHJcbiAgY3JlYXRlOiBmdW5jdGlvbih4LHkpIHtcclxuICAgIHZhciBpLCBzb3VyY2UsIGJhc2UgPSB7eDowLCB5OjB9XHJcblxyXG4gICAgLy8gZW5zdXJlIHNvdXJjZSBhcyBvYmplY3RcclxuICAgIHNvdXJjZSA9IEFycmF5LmlzQXJyYXkoeCkgP1xyXG4gICAgICB7eDp4WzBdLCB5OnhbMV19IDpcclxuICAgIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/XHJcbiAgICAgIHt4OngueCwgeTp4Lnl9IDpcclxuICAgIHggIT0gbnVsbCA/XHJcbiAgICAgIHt4OngsIHk6KHkgIT0gbnVsbCA/IHkgOiB4KX0gOiBiYXNlIC8vIElmIHkgaGFzIG5vIHZhbHVlLCB0aGVuIHggaXMgdXNlZCBoYXMgaXRzIHZhbHVlXHJcblxyXG4gICAgLy8gbWVyZ2Ugc291cmNlXHJcbiAgICB0aGlzLnggPSBzb3VyY2UueFxyXG4gICAgdGhpcy55ID0gc291cmNlLnlcclxuICB9XHJcblxyXG4gIC8vIEFkZCBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBDbG9uZSBwb2ludFxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gbmV3IFNWRy5Qb2ludCh0aGlzKVxyXG4gICAgfVxyXG4gICAgLy8gTW9ycGggb25lIHBvaW50IGludG8gYW5vdGhlclxyXG4gICwgbW9ycGg6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgLy8gc3RvcmUgbmV3IGRlc3RpbmF0aW9uXHJcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU1ZHLlBvaW50KHgsIHkpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICAgLy8gR2V0IG1vcnBoZWQgcG9pbnQgYXQgYSBnaXZlbiBwb3NpdGlvblxyXG4gICwgYXQ6IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXHJcbiAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXNcclxuXHJcbiAgICAgIC8vIGNhbGN1bGF0ZSBtb3JwaGVkIG1hdHJpeCBhdCBhIGdpdmVuIHBvc2l0aW9uXHJcbiAgICAgIHZhciBwb2ludCA9IG5ldyBTVkcuUG9pbnQoe1xyXG4gICAgICAgIHg6IHRoaXMueCArICh0aGlzLmRlc3RpbmF0aW9uLnggLSB0aGlzLngpICogcG9zXHJcbiAgICAgICwgeTogdGhpcy55ICsgKHRoaXMuZGVzdGluYXRpb24ueSAtIHRoaXMueSkgKiBwb3NcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiBwb2ludFxyXG4gICAgfVxyXG4gICAgLy8gQ29udmVydCB0byBuYXRpdmUgU1ZHUG9pbnRcclxuICAsIG5hdGl2ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8vIGNyZWF0ZSBuZXcgcG9pbnRcclxuICAgICAgdmFyIHBvaW50ID0gU1ZHLnBhcnNlci5uYXRpdmUuY3JlYXRlU1ZHUG9pbnQoKVxyXG5cclxuICAgICAgLy8gdXBkYXRlIHdpdGggY3VycmVudCB2YWx1ZXNcclxuICAgICAgcG9pbnQueCA9IHRoaXMueFxyXG4gICAgICBwb2ludC55ID0gdGhpcy55XHJcblxyXG4gICAgICByZXR1cm4gcG9pbnRcclxuICAgIH1cclxuICAgIC8vIHRyYW5zZm9ybSBwb2ludCB3aXRoIG1hdHJpeFxyXG4gICwgdHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcclxuICAgICAgcmV0dXJuIG5ldyBTVkcuUG9pbnQodGhpcy5uYXRpdmUoKS5tYXRyaXhUcmFuc2Zvcm0obWF0cml4Lm5hdGl2ZSgpKSlcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxufSlcclxuXHJcblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuXHJcbiAgLy8gR2V0IHBvaW50XHJcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHJldHVybiBuZXcgU1ZHLlBvaW50KHgseSkudHJhbnNmb3JtKHRoaXMuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcclxuICB9XHJcblxyXG59KVxyXG5cblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAvLyBTZXQgc3ZnIGVsZW1lbnQgYXR0cmlidXRlXHJcbiAgYXR0cjogZnVuY3Rpb24oYSwgdiwgbikge1xyXG4gICAgLy8gYWN0IGFzIGZ1bGwgZ2V0dGVyXHJcbiAgICBpZiAoYSA9PSBudWxsKSB7XHJcbiAgICAgIC8vIGdldCBhbiBvYmplY3Qgb2YgYXR0cmlidXRlc1xyXG4gICAgICBhID0ge31cclxuICAgICAgdiA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzXHJcbiAgICAgIGZvciAobiA9IHYubGVuZ3RoIC0gMTsgbiA+PSAwOyBuLS0pXHJcbiAgICAgICAgYVt2W25dLm5vZGVOYW1lXSA9IFNWRy5yZWdleC5pc051bWJlci50ZXN0KHZbbl0ubm9kZVZhbHVlKSA/IHBhcnNlRmxvYXQodltuXS5ub2RlVmFsdWUpIDogdltuXS5ub2RlVmFsdWVcclxuXHJcbiAgICAgIHJldHVybiBhXHJcblxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAvLyBhcHBseSBldmVyeSBhdHRyaWJ1dGUgaW5kaXZpZHVhbGx5IGlmIGFuIG9iamVjdCBpcyBwYXNzZWRcclxuICAgICAgZm9yICh2IGluIGEpIHRoaXMuYXR0cih2LCBhW3ZdKVxyXG5cclxuICAgIH0gZWxzZSBpZiAodiA9PT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHJlbW92ZSB2YWx1ZVxyXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoYSlcclxuXHJcbiAgICB9IGVsc2UgaWYgKHYgPT0gbnVsbCkge1xyXG4gICAgICAvLyBhY3QgYXMgYSBnZXR0ZXIgaWYgdGhlIGZpcnN0IGFuZCBvbmx5IGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3RcclxuICAgICAgdiA9IHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoYSlcclxuICAgICAgcmV0dXJuIHYgPT0gbnVsbCA/XHJcbiAgICAgICAgU1ZHLmRlZmF1bHRzLmF0dHJzW2FdIDpcclxuICAgICAgU1ZHLnJlZ2V4LmlzTnVtYmVyLnRlc3QodikgP1xyXG4gICAgICAgIHBhcnNlRmxvYXQodikgOiB2XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQlVHIEZJWDogc29tZSBicm93c2VycyB3aWxsIHJlbmRlciBhIHN0cm9rZSBpZiBhIGNvbG9yIGlzIGdpdmVuIGV2ZW4gdGhvdWdoIHN0cm9rZSB3aWR0aCBpcyAwXHJcbiAgICAgIGlmIChhID09ICdzdHJva2Utd2lkdGgnKVxyXG4gICAgICAgIHRoaXMuYXR0cignc3Ryb2tlJywgcGFyc2VGbG9hdCh2KSA+IDAgPyB0aGlzLl9zdHJva2UgOiBudWxsKVxyXG4gICAgICBlbHNlIGlmIChhID09ICdzdHJva2UnKVxyXG4gICAgICAgIHRoaXMuX3N0cm9rZSA9IHZcclxuXHJcbiAgICAgIC8vIGNvbnZlcnQgaW1hZ2UgZmlsbCBhbmQgc3Ryb2tlIHRvIHBhdHRlcm5zXHJcbiAgICAgIGlmIChhID09ICdmaWxsJyB8fCBhID09ICdzdHJva2UnKSB7XHJcbiAgICAgICAgaWYgKFNWRy5yZWdleC5pc0ltYWdlLnRlc3QodikpXHJcbiAgICAgICAgICB2ID0gdGhpcy5kb2MoKS5kZWZzKCkuaW1hZ2UodiwgMCwgMClcclxuXHJcbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBTVkcuSW1hZ2UpXHJcbiAgICAgICAgICB2ID0gdGhpcy5kb2MoKS5kZWZzKCkucGF0dGVybigwLCAwLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGQodilcclxuICAgICAgICAgIH0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGVuc3VyZSBjb3JyZWN0IG51bWVyaWMgdmFsdWVzIChhbHNvIGFjY2VwdHMgTmFOIGFuZCBJbmZpbml0eSlcclxuICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJylcclxuICAgICAgICB2ID0gbmV3IFNWRy5OdW1iZXIodilcclxuXHJcbiAgICAgIC8vIGVuc3VyZSBmdWxsIGhleCBjb2xvclxyXG4gICAgICBlbHNlIGlmIChTVkcuQ29sb3IuaXNDb2xvcih2KSlcclxuICAgICAgICB2ID0gbmV3IFNWRy5Db2xvcih2KVxyXG5cclxuICAgICAgLy8gcGFyc2UgYXJyYXkgdmFsdWVzXHJcbiAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpXHJcbiAgICAgICAgdiA9IG5ldyBTVkcuQXJyYXkodilcclxuXHJcbiAgICAgIC8vIGlmIHRoZSBwYXNzZWQgYXR0cmlidXRlIGlzIGxlYWRpbmcuLi5cclxuICAgICAgaWYgKGEgPT0gJ2xlYWRpbmcnKSB7XHJcbiAgICAgICAgLy8gLi4uIGNhbGwgdGhlIGxlYWRpbmcgbWV0aG9kIGluc3RlYWRcclxuICAgICAgICBpZiAodGhpcy5sZWFkaW5nKVxyXG4gICAgICAgICAgdGhpcy5sZWFkaW5nKHYpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gc2V0IGdpdmVuIGF0dHJpYnV0ZSBvbiBub2RlXHJcbiAgICAgICAgdHlwZW9mIG4gPT09ICdzdHJpbmcnID9cclxuICAgICAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGVOUyhuLCBhLCB2LnRvU3RyaW5nKCkpIDpcclxuICAgICAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoYSwgdi50b1N0cmluZygpKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZWJ1aWxkIGlmIHJlcXVpcmVkXHJcbiAgICAgIGlmICh0aGlzLnJlYnVpbGQgJiYgKGEgPT0gJ2ZvbnQtc2l6ZScgfHwgYSA9PSAneCcpKVxyXG4gICAgICAgIHRoaXMucmVidWlsZChhLCB2KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG59KVxuU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xyXG4gIC8vIEFkZCB0cmFuc2Zvcm1hdGlvbnNcclxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uKG8sIHJlbGF0aXZlKSB7XHJcbiAgICAvLyBnZXQgdGFyZ2V0IGluIGNhc2Ugb2YgdGhlIGZ4IG1vZHVsZSwgb3RoZXJ3aXNlIHJlZmVyZW5jZSB0aGlzXHJcbiAgICB2YXIgdGFyZ2V0ID0gdGhpc1xyXG4gICAgICAsIG1hdHJpeCwgYmJveFxyXG5cclxuICAgIC8vIGFjdCBhcyBhIGdldHRlclxyXG4gICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAvLyBnZXQgY3VycmVudCBtYXRyaXhcclxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5NYXRyaXgodGFyZ2V0KS5leHRyYWN0KClcclxuXHJcbiAgICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ3N0cmluZycgPyBtYXRyaXhbb10gOiBtYXRyaXhcclxuICAgIH1cclxuXHJcbiAgICAvLyBnZXQgY3VycmVudCBtYXRyaXhcclxuICAgIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KHRhcmdldClcclxuXHJcbiAgICAvLyBlbnN1cmUgcmVsYXRpdmUgZmxhZ1xyXG4gICAgcmVsYXRpdmUgPSAhIXJlbGF0aXZlIHx8ICEhby5yZWxhdGl2ZVxyXG5cclxuICAgIC8vIGFjdCBvbiBtYXRyaXhcclxuICAgIGlmIChvLmEgIT0gbnVsbCkge1xyXG4gICAgICBtYXRyaXggPSByZWxhdGl2ZSA/XHJcbiAgICAgICAgLy8gcmVsYXRpdmVcclxuICAgICAgICBtYXRyaXgubXVsdGlwbHkobmV3IFNWRy5NYXRyaXgobykpIDpcclxuICAgICAgICAvLyBhYnNvbHV0ZVxyXG4gICAgICAgIG5ldyBTVkcuTWF0cml4KG8pXHJcblxyXG4gICAgLy8gYWN0IG9uIHJvdGF0aW9uXHJcbiAgICB9IGVsc2UgaWYgKG8ucm90YXRpb24gIT0gbnVsbCkge1xyXG4gICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XHJcbiAgICAgIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpXHJcblxyXG4gICAgICAvLyBhcHBseSB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICBtYXRyaXggPSByZWxhdGl2ZSA/XHJcbiAgICAgICAgLy8gcmVsYXRpdmVcclxuICAgICAgICBtYXRyaXgucm90YXRlKG8ucm90YXRpb24sIG8uY3gsIG8uY3kpIDpcclxuICAgICAgICAvLyBhYnNvbHV0ZVxyXG4gICAgICAgIG1hdHJpeC5yb3RhdGUoby5yb3RhdGlvbiAtIG1hdHJpeC5leHRyYWN0KCkucm90YXRpb24sIG8uY3gsIG8uY3kpXHJcblxyXG4gICAgLy8gYWN0IG9uIHNjYWxlXHJcbiAgICB9IGVsc2UgaWYgKG8uc2NhbGUgIT0gbnVsbCB8fCBvLnNjYWxlWCAhPSBudWxsIHx8IG8uc2NhbGVZICE9IG51bGwpIHtcclxuICAgICAgLy8gZW5zdXJlIGNlbnRyZSBwb2ludFxyXG4gICAgICBlbnN1cmVDZW50cmUobywgdGFyZ2V0KVxyXG5cclxuICAgICAgLy8gZW5zdXJlIHNjYWxlIHZhbHVlcyBvbiBib3RoIGF4ZXNcclxuICAgICAgby5zY2FsZVggPSBvLnNjYWxlICE9IG51bGwgPyBvLnNjYWxlIDogby5zY2FsZVggIT0gbnVsbCA/IG8uc2NhbGVYIDogMVxyXG4gICAgICBvLnNjYWxlWSA9IG8uc2NhbGUgIT0gbnVsbCA/IG8uc2NhbGUgOiBvLnNjYWxlWSAhPSBudWxsID8gby5zY2FsZVkgOiAxXHJcblxyXG4gICAgICBpZiAoIXJlbGF0aXZlKSB7XHJcbiAgICAgICAgLy8gYWJzb2x1dGU7IG11bHRpcGx5IGludmVyc2VkIHZhbHVlc1xyXG4gICAgICAgIHZhciBlID0gbWF0cml4LmV4dHJhY3QoKVxyXG4gICAgICAgIG8uc2NhbGVYID0gby5zY2FsZVggKiAxIC8gZS5zY2FsZVhcclxuICAgICAgICBvLnNjYWxlWSA9IG8uc2NhbGVZICogMSAvIGUuc2NhbGVZXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1hdHJpeCA9IG1hdHJpeC5zY2FsZShvLnNjYWxlWCwgby5zY2FsZVksIG8uY3gsIG8uY3kpXHJcblxyXG4gICAgLy8gYWN0IG9uIHNrZXdcclxuICAgIH0gZWxzZSBpZiAoby5za2V3ICE9IG51bGwgfHwgby5za2V3WCAhPSBudWxsIHx8IG8uc2tld1kgIT0gbnVsbCkge1xyXG4gICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XHJcbiAgICAgIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpXHJcblxyXG4gICAgICAvLyBlbnN1cmUgc2tldyB2YWx1ZXMgb24gYm90aCBheGVzXHJcbiAgICAgIG8uc2tld1ggPSBvLnNrZXcgIT0gbnVsbCA/IG8uc2tldyA6IG8uc2tld1ggIT0gbnVsbCA/IG8uc2tld1ggOiAwXHJcbiAgICAgIG8uc2tld1kgPSBvLnNrZXcgIT0gbnVsbCA/IG8uc2tldyA6IG8uc2tld1kgIT0gbnVsbCA/IG8uc2tld1kgOiAwXHJcblxyXG4gICAgICBpZiAoIXJlbGF0aXZlKSB7XHJcbiAgICAgICAgLy8gYWJzb2x1dGU7IHJlc2V0IHNrZXcgdmFsdWVzXHJcbiAgICAgICAgdmFyIGUgPSBtYXRyaXguZXh0cmFjdCgpXHJcbiAgICAgICAgbWF0cml4ID0gbWF0cml4Lm11bHRpcGx5KG5ldyBTVkcuTWF0cml4KCkuc2tldyhlLnNrZXdYLCBlLnNrZXdZLCBvLmN4LCBvLmN5KS5pbnZlcnNlKCkpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1hdHJpeCA9IG1hdHJpeC5za2V3KG8uc2tld1gsIG8uc2tld1ksIG8uY3gsIG8uY3kpXHJcblxyXG4gICAgLy8gYWN0IG9uIGZsaXBcclxuICAgIH0gZWxzZSBpZiAoby5mbGlwKSB7XHJcbiAgICAgIGlmKG8uZmxpcCA9PSAneCcgfHwgby5mbGlwID09ICd5Jykge1xyXG4gICAgICAgIG8ub2Zmc2V0ID0gby5vZmZzZXQgPT0gbnVsbCA/IHRhcmdldC5iYm94KClbJ2MnICsgby5mbGlwXSA6IG8ub2Zmc2V0XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYoby5vZmZzZXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgYmJveCA9IHRhcmdldC5iYm94KClcclxuICAgICAgICAgIG8uZmxpcCA9IGJib3guY3hcclxuICAgICAgICAgIG8ub2Zmc2V0ID0gYmJveC5jeVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvLmZsaXAgPSBvLm9mZnNldFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5NYXRyaXgoKS5mbGlwKG8uZmxpcCwgby5vZmZzZXQpXHJcblxyXG4gICAgLy8gYWN0IG9uIHRyYW5zbGF0ZVxyXG4gICAgfSBlbHNlIGlmIChvLnggIT0gbnVsbCB8fCBvLnkgIT0gbnVsbCkge1xyXG4gICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAvLyByZWxhdGl2ZVxyXG4gICAgICAgIG1hdHJpeCA9IG1hdHJpeC50cmFuc2xhdGUoby54LCBvLnkpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gYWJzb2x1dGVcclxuICAgICAgICBpZiAoby54ICE9IG51bGwpIG1hdHJpeC5lID0gby54XHJcbiAgICAgICAgaWYgKG8ueSAhPSBudWxsKSBtYXRyaXguZiA9IG8ueVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgbWF0cml4KVxyXG4gIH1cclxufSlcclxuXHJcblNWRy5leHRlbmQoU1ZHLkZYLCB7XHJcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbihvLCByZWxhdGl2ZSkge1xyXG4gICAgLy8gZ2V0IHRhcmdldCBpbiBjYXNlIG9mIHRoZSBmeCBtb2R1bGUsIG90aGVyd2lzZSByZWZlcmVuY2UgdGhpc1xyXG4gICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0KClcclxuICAgICAgLCBtYXRyaXgsIGJib3hcclxuXHJcbiAgICAvLyBhY3QgYXMgYSBnZXR0ZXJcclxuICAgIGlmICh0eXBlb2YgbyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgLy8gZ2V0IGN1cnJlbnQgbWF0cml4XHJcbiAgICAgIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KHRhcmdldCkuZXh0cmFjdCgpXHJcblxyXG4gICAgICByZXR1cm4gdHlwZW9mIG8gPT09ICdzdHJpbmcnID8gbWF0cml4W29dIDogbWF0cml4XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZW5zdXJlIHJlbGF0aXZlIGZsYWdcclxuICAgIHJlbGF0aXZlID0gISFyZWxhdGl2ZSB8fCAhIW8ucmVsYXRpdmVcclxuXHJcbiAgICAvLyBhY3Qgb24gbWF0cml4XHJcbiAgICBpZiAoby5hICE9IG51bGwpIHtcclxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5NYXRyaXgobylcclxuXHJcbiAgICAvLyBhY3Qgb24gcm90YXRpb25cclxuICAgIH0gZWxzZSBpZiAoby5yb3RhdGlvbiAhPSBudWxsKSB7XHJcbiAgICAgIC8vIGVuc3VyZSBjZW50cmUgcG9pbnRcclxuICAgICAgZW5zdXJlQ2VudHJlKG8sIHRhcmdldClcclxuXHJcbiAgICAgIC8vIGFwcGx5IHRyYW5zZm9ybWF0aW9uXHJcbiAgICAgIG1hdHJpeCA9IG5ldyBTVkcuUm90YXRlKG8ucm90YXRpb24sIG8uY3gsIG8uY3kpXHJcblxyXG4gICAgLy8gYWN0IG9uIHNjYWxlXHJcbiAgICB9IGVsc2UgaWYgKG8uc2NhbGUgIT0gbnVsbCB8fCBvLnNjYWxlWCAhPSBudWxsIHx8IG8uc2NhbGVZICE9IG51bGwpIHtcclxuICAgICAgLy8gZW5zdXJlIGNlbnRyZSBwb2ludFxyXG4gICAgICBlbnN1cmVDZW50cmUobywgdGFyZ2V0KVxyXG5cclxuICAgICAgLy8gZW5zdXJlIHNjYWxlIHZhbHVlcyBvbiBib3RoIGF4ZXNcclxuICAgICAgby5zY2FsZVggPSBvLnNjYWxlICE9IG51bGwgPyBvLnNjYWxlIDogby5zY2FsZVggIT0gbnVsbCA/IG8uc2NhbGVYIDogMVxyXG4gICAgICBvLnNjYWxlWSA9IG8uc2NhbGUgIT0gbnVsbCA/IG8uc2NhbGUgOiBvLnNjYWxlWSAhPSBudWxsID8gby5zY2FsZVkgOiAxXHJcblxyXG4gICAgICBtYXRyaXggPSBuZXcgU1ZHLlNjYWxlKG8uc2NhbGVYLCBvLnNjYWxlWSwgby5jeCwgby5jeSlcclxuXHJcbiAgICAvLyBhY3Qgb24gc2tld1xyXG4gICAgfSBlbHNlIGlmIChvLnNrZXdYICE9IG51bGwgfHwgby5za2V3WSAhPSBudWxsKSB7XHJcbiAgICAgIC8vIGVuc3VyZSBjZW50cmUgcG9pbnRcclxuICAgICAgZW5zdXJlQ2VudHJlKG8sIHRhcmdldClcclxuXHJcbiAgICAgIC8vIGVuc3VyZSBza2V3IHZhbHVlcyBvbiBib3RoIGF4ZXNcclxuICAgICAgby5za2V3WCA9IG8uc2tld1ggIT0gbnVsbCA/IG8uc2tld1ggOiAwXHJcbiAgICAgIG8uc2tld1kgPSBvLnNrZXdZICE9IG51bGwgPyBvLnNrZXdZIDogMFxyXG5cclxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5Ta2V3KG8uc2tld1gsIG8uc2tld1ksIG8uY3gsIG8uY3kpXHJcblxyXG4gICAgLy8gYWN0IG9uIGZsaXBcclxuICAgIH0gZWxzZSBpZiAoby5mbGlwKSB7XHJcbiAgICAgIGlmKG8uZmxpcCA9PSAneCcgfHwgby5mbGlwID09ICd5Jykge1xyXG4gICAgICAgIG8ub2Zmc2V0ID0gby5vZmZzZXQgPT0gbnVsbCA/IHRhcmdldC5iYm94KClbJ2MnICsgby5mbGlwXSA6IG8ub2Zmc2V0XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYoby5vZmZzZXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgYmJveCA9IHRhcmdldC5iYm94KClcclxuICAgICAgICAgIG8uZmxpcCA9IGJib3guY3hcclxuICAgICAgICAgIG8ub2Zmc2V0ID0gYmJveC5jeVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvLmZsaXAgPSBvLm9mZnNldFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5NYXRyaXgoKS5mbGlwKG8uZmxpcCwgby5vZmZzZXQpXHJcblxyXG4gICAgLy8gYWN0IG9uIHRyYW5zbGF0ZVxyXG4gICAgfSBlbHNlIGlmIChvLnggIT0gbnVsbCB8fCBvLnkgIT0gbnVsbCkge1xyXG4gICAgICBtYXRyaXggPSBuZXcgU1ZHLlRyYW5zbGF0ZShvLngsIG8ueSlcclxuICAgIH1cclxuXHJcbiAgICBpZighbWF0cml4KSByZXR1cm4gdGhpc1xyXG5cclxuICAgIG1hdHJpeC5yZWxhdGl2ZSA9IHJlbGF0aXZlXHJcblxyXG4gICAgdGhpcy5sYXN0KCkudHJhbnNmb3Jtcy5wdXNoKG1hdHJpeClcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fY2FsbFN0YXJ0KClcclxuICB9XHJcbn0pXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcbiAgLy8gUmVzZXQgYWxsIHRyYW5zZm9ybWF0aW9uc1xyXG4gIHVudHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIG51bGwpXHJcbiAgfSxcclxuICAvLyBtZXJnZSB0aGUgd2hvbGUgdHJhbnNmb3JtYXRpb24gY2hhaW4gaW50byBvbmUgbWF0cml4IGFuZCByZXR1cm5zIGl0XHJcbiAgbWF0cml4aWZ5OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbWF0cml4ID0gKHRoaXMuYXR0cigndHJhbnNmb3JtJykgfHwgJycpXHJcbiAgICAgIC8vIHNwbGl0IHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgICAuc3BsaXQoU1ZHLnJlZ2V4LnRyYW5zZm9ybXMpLnNsaWNlKDAsLTEpLm1hcChmdW5jdGlvbihzdHIpe1xyXG4gICAgICAgIC8vIGdlbmVyYXRlIGtleSA9PiB2YWx1ZSBwYWlyc1xyXG4gICAgICAgIHZhciBrdiA9IHN0ci50cmltKCkuc3BsaXQoJygnKVxyXG4gICAgICAgIHJldHVybiBba3ZbMF0sIGt2WzFdLnNwbGl0KFNWRy5yZWdleC5kZWxpbWl0ZXIpLm1hcChmdW5jdGlvbihzdHIpeyByZXR1cm4gcGFyc2VGbG9hdChzdHIpIH0pXVxyXG4gICAgICB9KVxyXG4gICAgICAvLyBtZXJnZSBldmVyeSB0cmFuc2Zvcm1hdGlvbiBpbnRvIG9uZSBtYXRyaXhcclxuICAgICAgLnJlZHVjZShmdW5jdGlvbihtYXRyaXgsIHRyYW5zZm9ybSl7XHJcblxyXG4gICAgICAgIGlmKHRyYW5zZm9ybVswXSA9PSAnbWF0cml4JykgcmV0dXJuIG1hdHJpeC5tdWx0aXBseShhcnJheVRvTWF0cml4KHRyYW5zZm9ybVsxXSkpXHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeFt0cmFuc2Zvcm1bMF1dLmFwcGx5KG1hdHJpeCwgdHJhbnNmb3JtWzFdKVxyXG5cclxuICAgICAgfSwgbmV3IFNWRy5NYXRyaXgoKSlcclxuXHJcbiAgICByZXR1cm4gbWF0cml4XHJcbiAgfSxcclxuICAvLyBhZGQgYW4gZWxlbWVudCB0byBhbm90aGVyIHBhcmVudCB3aXRob3V0IGNoYW5naW5nIHRoZSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb24gdGhlIHNjcmVlblxyXG4gIHRvUGFyZW50OiBmdW5jdGlvbihwYXJlbnQpIHtcclxuICAgIGlmKHRoaXMgPT0gcGFyZW50KSByZXR1cm4gdGhpc1xyXG4gICAgdmFyIGN0bSA9IHRoaXMuc2NyZWVuQ1RNKClcclxuICAgIHZhciBwQ3RtID0gcGFyZW50LnNjcmVlbkNUTSgpLmludmVyc2UoKVxyXG5cclxuICAgIHRoaXMuYWRkVG8ocGFyZW50KS51bnRyYW5zZm9ybSgpLnRyYW5zZm9ybShwQ3RtLm11bHRpcGx5KGN0bSkpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9LFxyXG4gIC8vIHNhbWUgYXMgYWJvdmUgd2l0aCBwYXJlbnQgZXF1YWxzIHJvb3Qtc3ZnXHJcbiAgdG9Eb2M6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudG9QYXJlbnQodGhpcy5kb2MoKSlcclxuICB9XHJcblxyXG59KVxyXG5cclxuU1ZHLlRyYW5zZm9ybWF0aW9uID0gU1ZHLmludmVudCh7XHJcblxyXG4gIGNyZWF0ZTogZnVuY3Rpb24oc291cmNlLCBpbnZlcnNlZCl7XHJcblxyXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGludmVyc2VkICE9ICdib29sZWFuJyl7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKVxyXG4gICAgfVxyXG5cclxuICAgIGlmKEFycmF5LmlzQXJyYXkoc291cmNlKSl7XHJcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKXtcclxuICAgICAgICB0aGlzW3RoaXMuYXJndW1lbnRzW2ldXSA9IHNvdXJjZVtpXVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYodHlwZW9mIHNvdXJjZSA9PSAnb2JqZWN0Jyl7XHJcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKXtcclxuICAgICAgICB0aGlzW3RoaXMuYXJndW1lbnRzW2ldXSA9IHNvdXJjZVt0aGlzLmFyZ3VtZW50c1tpXV1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaW52ZXJzZWQgPSBmYWxzZVxyXG5cclxuICAgIGlmKGludmVyc2VkID09PSB0cnVlKXtcclxuICAgICAgdGhpcy5pbnZlcnNlZCA9IHRydWVcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuLCBleHRlbmQ6IHtcclxuXHJcbiAgICBhcmd1bWVudHM6IFtdXHJcbiAgLCBtZXRob2Q6ICcnXHJcblxyXG4gICwgYXQ6IGZ1bmN0aW9uKHBvcyl7XHJcblxyXG4gICAgICB2YXIgcGFyYW1zID0gW11cclxuXHJcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKXtcclxuICAgICAgICBwYXJhbXMucHVzaCh0aGlzW3RoaXMuYXJndW1lbnRzW2ldXSlcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG0gPSB0aGlzLl91bmRvIHx8IG5ldyBTVkcuTWF0cml4KClcclxuXHJcbiAgICAgIG0gPSBuZXcgU1ZHLk1hdHJpeCgpLm1vcnBoKFNWRy5NYXRyaXgucHJvdG90eXBlW3RoaXMubWV0aG9kXS5hcHBseShtLCBwYXJhbXMpKS5hdChwb3MpXHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5pbnZlcnNlZCA/IG0uaW52ZXJzZSgpIDogbVxyXG5cclxuICAgIH1cclxuXHJcbiAgLCB1bmRvOiBmdW5jdGlvbihvKXtcclxuICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpe1xyXG4gICAgICAgIG9bdGhpcy5hcmd1bWVudHNbaV1dID0gdHlwZW9mIHRoaXNbdGhpcy5hcmd1bWVudHNbaV1dID09ICd1bmRlZmluZWQnID8gMCA6IG9bdGhpcy5hcmd1bWVudHNbaV1dXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZSBtZXRob2QgU1ZHLk1hdHJpeC5leHRyYWN0IHdoaWNoIHdhcyB1c2VkIGJlZm9yZSBjYWxsaW5nIHRoaXNcclxuICAgICAgLy8gbWV0aG9kIHRvIG9idGFpbiBhIHZhbHVlIGZvciB0aGUgcGFyYW1ldGVyIG8gZG9lc24ndCByZXR1cm4gYSBjeCBhbmRcclxuICAgICAgLy8gYSBjeSBzbyB3ZSB1c2UgdGhlIG9uZXMgdGhhdCB3ZXJlIHByb3ZpZGVkIHRvIHRoaXMgb2JqZWN0IGF0IGl0cyBjcmVhdGlvblxyXG4gICAgICBvLmN4ID0gdGhpcy5jeFxyXG4gICAgICBvLmN5ID0gdGhpcy5jeVxyXG5cclxuICAgICAgdGhpcy5fdW5kbyA9IG5ldyBTVkdbY2FwaXRhbGl6ZSh0aGlzLm1ldGhvZCldKG8sIHRydWUpLmF0KDEpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG59KVxyXG5cclxuU1ZHLlRyYW5zbGF0ZSA9IFNWRy5pbnZlbnQoe1xyXG5cclxuICBwYXJlbnQ6IFNWRy5NYXRyaXhcclxuLCBpbmhlcml0OiBTVkcuVHJhbnNmb3JtYXRpb25cclxuXHJcbiwgY3JlYXRlOiBmdW5jdGlvbihzb3VyY2UsIGludmVyc2VkKXtcclxuICAgIHRoaXMuY29uc3RydWN0b3IuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKVxyXG4gIH1cclxuXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICBhcmd1bWVudHM6IFsndHJhbnNmb3JtZWRYJywgJ3RyYW5zZm9ybWVkWSddXHJcbiAgLCBtZXRob2Q6ICd0cmFuc2xhdGUnXHJcbiAgfVxyXG5cclxufSlcclxuXHJcblNWRy5Sb3RhdGUgPSBTVkcuaW52ZW50KHtcclxuXHJcbiAgcGFyZW50OiBTVkcuTWF0cml4XHJcbiwgaW5oZXJpdDogU1ZHLlRyYW5zZm9ybWF0aW9uXHJcblxyXG4sIGNyZWF0ZTogZnVuY3Rpb24oc291cmNlLCBpbnZlcnNlZCl7XHJcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcclxuICB9XHJcblxyXG4sIGV4dGVuZDoge1xyXG4gICAgYXJndW1lbnRzOiBbJ3JvdGF0aW9uJywgJ2N4JywgJ2N5J11cclxuICAsIG1ldGhvZDogJ3JvdGF0ZSdcclxuICAsIGF0OiBmdW5jdGlvbihwb3Mpe1xyXG4gICAgICB2YXIgbSA9IG5ldyBTVkcuTWF0cml4KCkucm90YXRlKG5ldyBTVkcuTnVtYmVyKCkubW9ycGgodGhpcy5yb3RhdGlvbiAtICh0aGlzLl91bmRvID8gdGhpcy5fdW5kby5yb3RhdGlvbiA6IDApKS5hdChwb3MpLCB0aGlzLmN4LCB0aGlzLmN5KVxyXG4gICAgICByZXR1cm4gdGhpcy5pbnZlcnNlZCA/IG0uaW52ZXJzZSgpIDogbVxyXG4gICAgfVxyXG4gICwgdW5kbzogZnVuY3Rpb24obyl7XHJcbiAgICAgIHRoaXMuX3VuZG8gPSBvXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSlcclxuXHJcblNWRy5TY2FsZSA9IFNWRy5pbnZlbnQoe1xyXG5cclxuICBwYXJlbnQ6IFNWRy5NYXRyaXhcclxuLCBpbmhlcml0OiBTVkcuVHJhbnNmb3JtYXRpb25cclxuXHJcbiwgY3JlYXRlOiBmdW5jdGlvbihzb3VyY2UsIGludmVyc2VkKXtcclxuICAgIHRoaXMuY29uc3RydWN0b3IuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKVxyXG4gIH1cclxuXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICBhcmd1bWVudHM6IFsnc2NhbGVYJywgJ3NjYWxlWScsICdjeCcsICdjeSddXHJcbiAgLCBtZXRob2Q6ICdzY2FsZSdcclxuICB9XHJcblxyXG59KVxyXG5cclxuU1ZHLlNrZXcgPSBTVkcuaW52ZW50KHtcclxuXHJcbiAgcGFyZW50OiBTVkcuTWF0cml4XHJcbiwgaW5oZXJpdDogU1ZHLlRyYW5zZm9ybWF0aW9uXHJcblxyXG4sIGNyZWF0ZTogZnVuY3Rpb24oc291cmNlLCBpbnZlcnNlZCl7XHJcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcclxuICB9XHJcblxyXG4sIGV4dGVuZDoge1xyXG4gICAgYXJndW1lbnRzOiBbJ3NrZXdYJywgJ3NrZXdZJywgJ2N4JywgJ2N5J11cclxuICAsIG1ldGhvZDogJ3NrZXcnXHJcbiAgfVxyXG5cclxufSlcclxuXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcbiAgLy8gRHluYW1pYyBzdHlsZSBnZW5lcmF0b3JcclxuICBzdHlsZTogZnVuY3Rpb24ocywgdikge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAvLyBnZXQgZnVsbCBzdHlsZVxyXG4gICAgICByZXR1cm4gdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQgfHwgJydcclxuXHJcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgIC8vIGFwcGx5IGV2ZXJ5IHN0eWxlIGluZGl2aWR1YWxseSBpZiBhbiBvYmplY3QgaXMgcGFzc2VkXHJcbiAgICAgIGlmICh0eXBlb2YgcyA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGZvciAodiBpbiBzKSB0aGlzLnN0eWxlKHYsIHNbdl0pXHJcblxyXG4gICAgICB9IGVsc2UgaWYgKFNWRy5yZWdleC5pc0Nzcy50ZXN0KHMpKSB7XHJcbiAgICAgICAgLy8gcGFyc2UgY3NzIHN0cmluZ1xyXG4gICAgICAgIHMgPSBzLnNwbGl0KC9cXHMqO1xccyovKVxyXG4gICAgICAgICAgLy8gZmlsdGVyIG91dCBzdWZmaXggOyBhbmQgc3R1ZmYgbGlrZSA7O1xyXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihlKSB7IHJldHVybiAhIWUgfSlcclxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZSl7IHJldHVybiBlLnNwbGl0KC9cXHMqOlxccyovKSB9KVxyXG5cclxuICAgICAgICAvLyBhcHBseSBldmVyeSBkZWZpbml0aW9uIGluZGl2aWR1YWxseVxyXG4gICAgICAgIHdoaWxlICh2ID0gcy5wb3AoKSkge1xyXG4gICAgICAgICAgdGhpcy5zdHlsZSh2WzBdLCB2WzFdKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBhY3QgYXMgYSBnZXR0ZXIgaWYgdGhlIGZpcnN0IGFuZCBvbmx5IGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3RcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnN0eWxlW2NhbWVsQ2FzZShzKV1cclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubm9kZS5zdHlsZVtjYW1lbENhc2UocyldID0gdiA9PT0gbnVsbCB8fCBTVkcucmVnZXguaXNCbGFuay50ZXN0KHYpID8gJycgOiB2XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbn0pXG5TVkcuUGFyZW50ID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgZWxlbWVudClcclxuICB9XHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5FbGVtZW50XHJcblxyXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBSZXR1cm5zIGFsbCBjaGlsZCBlbGVtZW50c1xyXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gU1ZHLnV0aWxzLm1hcChTVkcudXRpbHMuZmlsdGVyU1ZHRWxlbWVudHModGhpcy5ub2RlLmNoaWxkTm9kZXMpLCBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIFNWRy5hZG9wdChub2RlKVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gICAgLy8gQWRkIGdpdmVuIGVsZW1lbnQgYXQgYSBwb3NpdGlvblxyXG4gICwgYWRkOiBmdW5jdGlvbihlbGVtZW50LCBpKSB7XHJcbiAgICAgIGlmIChpID09IG51bGwpXHJcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGVsZW1lbnQubm9kZSlcclxuICAgICAgZWxzZSBpZiAoZWxlbWVudC5ub2RlICE9IHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldKVxyXG4gICAgICAgIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudC5ub2RlLCB0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSlcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBCYXNpY2FsbHkgZG9lcyB0aGUgc2FtZSBhcyBgYWRkKClgIGJ1dCByZXR1cm5zIHRoZSBhZGRlZCBlbGVtZW50IGluc3RlYWRcclxuICAsIHB1dDogZnVuY3Rpb24oZWxlbWVudCwgaSkge1xyXG4gICAgICB0aGlzLmFkZChlbGVtZW50LCBpKVxyXG4gICAgICByZXR1cm4gZWxlbWVudFxyXG4gICAgfVxyXG4gICAgLy8gQ2hlY2tzIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGEgY2hpbGRcclxuICAsIGhhczogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbmRleChlbGVtZW50KSA+PSAwXHJcbiAgICB9XHJcbiAgICAvLyBHZXRzIGluZGV4IG9mIGdpdmVuIGVsZW1lbnRcclxuICAsIGluZGV4OiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKHRoaXMubm9kZS5jaGlsZE5vZGVzKS5pbmRleE9mKGVsZW1lbnQubm9kZSlcclxuICAgIH1cclxuICAgIC8vIEdldCBhIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgLCBnZXQ6IGZ1bmN0aW9uKGkpIHtcclxuICAgICAgcmV0dXJuIFNWRy5hZG9wdCh0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSlcclxuICAgIH1cclxuICAgIC8vIEdldCBmaXJzdCBjaGlsZFxyXG4gICwgZmlyc3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXQoMClcclxuICAgIH1cclxuICAgIC8vIEdldCB0aGUgbGFzdCBjaGlsZFxyXG4gICwgbGFzdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxKVxyXG4gICAgfVxyXG4gICAgLy8gSXRlcmF0ZXMgb3ZlciBhbGwgY2hpbGRyZW4gYW5kIGludm9rZXMgYSBnaXZlbiBibG9ja1xyXG4gICwgZWFjaDogZnVuY3Rpb24oYmxvY2ssIGRlZXApIHtcclxuICAgICAgdmFyIGksIGlsXHJcbiAgICAgICAgLCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKVxyXG5cclxuICAgICAgZm9yIChpID0gMCwgaWwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldIGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQpXHJcbiAgICAgICAgICBibG9jay5hcHBseShjaGlsZHJlbltpXSwgW2ksIGNoaWxkcmVuXSlcclxuXHJcbiAgICAgICAgaWYgKGRlZXAgJiYgKGNoaWxkcmVuW2ldIGluc3RhbmNlb2YgU1ZHLkNvbnRhaW5lcikpXHJcbiAgICAgICAgICBjaGlsZHJlbltpXS5lYWNoKGJsb2NrLCBkZWVwKVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICAgLy8gUmVtb3ZlIGEgZ2l2ZW4gY2hpbGRcclxuICAsIHJlbW92ZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQubm9kZSlcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBSZW1vdmUgYWxsIGVsZW1lbnRzIGluIHRoaXMgY29udGFpbmVyXHJcbiAgLCBjbGVhcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8vIHJlbW92ZSBjaGlsZHJlblxyXG4gICAgICB3aGlsZSh0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpKVxyXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKVxyXG5cclxuICAgICAgLy8gcmVtb3ZlIGRlZnMgcmVmZXJlbmNlXHJcbiAgICAgIGRlbGV0ZSB0aGlzLl9kZWZzXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICwgLy8gR2V0IGRlZnNcclxuICAgIGRlZnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kb2MoKS5kZWZzKClcclxuICAgIH1cclxuICB9XHJcblxyXG59KVxyXG5cblNWRy5leHRlbmQoU1ZHLlBhcmVudCwge1xyXG5cclxuICB1bmdyb3VwOiBmdW5jdGlvbihwYXJlbnQsIGRlcHRoKSB7XHJcbiAgICBpZihkZXB0aCA9PT0gMCB8fCB0aGlzIGluc3RhbmNlb2YgU1ZHLkRlZnMgfHwgdGhpcy5ub2RlID09IFNWRy5wYXJzZXIuZHJhdykgcmV0dXJuIHRoaXNcclxuXHJcbiAgICBwYXJlbnQgPSBwYXJlbnQgfHwgKHRoaXMgaW5zdGFuY2VvZiBTVkcuRG9jID8gdGhpcyA6IHRoaXMucGFyZW50KFNWRy5QYXJlbnQpKVxyXG4gICAgZGVwdGggPSBkZXB0aCB8fCBJbmZpbml0eVxyXG5cclxuICAgIHRoaXMuZWFjaChmdW5jdGlvbigpe1xyXG4gICAgICBpZih0aGlzIGluc3RhbmNlb2YgU1ZHLkRlZnMpIHJldHVybiB0aGlzXHJcbiAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBTVkcuUGFyZW50KSByZXR1cm4gdGhpcy51bmdyb3VwKHBhcmVudCwgZGVwdGgtMSlcclxuICAgICAgcmV0dXJuIHRoaXMudG9QYXJlbnQocGFyZW50KVxyXG4gICAgfSlcclxuXHJcbiAgICB0aGlzLm5vZGUuZmlyc3RDaGlsZCB8fCB0aGlzLnJlbW92ZSgpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9LFxyXG5cclxuICBmbGF0dGVuOiBmdW5jdGlvbihwYXJlbnQsIGRlcHRoKSB7XHJcbiAgICByZXR1cm4gdGhpcy51bmdyb3VwKHBhcmVudCwgZGVwdGgpXHJcbiAgfVxyXG5cclxufSlcblNWRy5Db250YWluZXIgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbGVtZW50KVxyXG4gIH1cclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLlBhcmVudFxyXG5cclxufSlcblxyXG5TVkcuVmlld0JveCA9IFNWRy5pbnZlbnQoe1xyXG5cclxuICBjcmVhdGU6IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG4gICAgdmFyIGksIGJhc2UgPSBbMCwgMCwgMCwgMF1cclxuXHJcbiAgICB2YXIgeCwgeSwgd2lkdGgsIGhlaWdodCwgYm94LCB2aWV3LCB3ZSwgaGVcclxuICAgICAgLCB3bSAgID0gMSAvLyB3aWR0aCBtdWx0aXBsaWVyXHJcbiAgICAgICwgaG0gICA9IDEgLy8gaGVpZ2h0IG11bHRpcGxpZXJcclxuICAgICAgLCByZWcgID0gL1srLV0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPy9naVxyXG5cclxuICAgIGlmKHNvdXJjZSBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KXtcclxuXHJcbiAgICAgIHdlID0gc291cmNlXHJcbiAgICAgIGhlID0gc291cmNlXHJcbiAgICAgIHZpZXcgPSAoc291cmNlLmF0dHIoJ3ZpZXdCb3gnKSB8fCAnJykubWF0Y2gocmVnKVxyXG4gICAgICBib3ggPSBzb3VyY2UuYmJveFxyXG5cclxuICAgICAgLy8gZ2V0IGRpbWVuc2lvbnMgb2YgY3VycmVudCBub2RlXHJcbiAgICAgIHdpZHRoICA9IG5ldyBTVkcuTnVtYmVyKHNvdXJjZS53aWR0aCgpKVxyXG4gICAgICBoZWlnaHQgPSBuZXcgU1ZHLk51bWJlcihzb3VyY2UuaGVpZ2h0KCkpXHJcblxyXG4gICAgICAvLyBmaW5kIG5lYXJlc3Qgbm9uLXBlcmNlbnR1YWwgZGltZW5zaW9uc1xyXG4gICAgICB3aGlsZSAod2lkdGgudW5pdCA9PSAnJScpIHtcclxuICAgICAgICB3bSAqPSB3aWR0aC52YWx1ZVxyXG4gICAgICAgIHdpZHRoID0gbmV3IFNWRy5OdW1iZXIod2UgaW5zdGFuY2VvZiBTVkcuRG9jID8gd2UucGFyZW50KCkub2Zmc2V0V2lkdGggOiB3ZS5wYXJlbnQoKS53aWR0aCgpKVxyXG4gICAgICAgIHdlID0gd2UucGFyZW50KClcclxuICAgICAgfVxyXG4gICAgICB3aGlsZSAoaGVpZ2h0LnVuaXQgPT0gJyUnKSB7XHJcbiAgICAgICAgaG0gKj0gaGVpZ2h0LnZhbHVlXHJcbiAgICAgICAgaGVpZ2h0ID0gbmV3IFNWRy5OdW1iZXIoaGUgaW5zdGFuY2VvZiBTVkcuRG9jID8gaGUucGFyZW50KCkub2Zmc2V0SGVpZ2h0IDogaGUucGFyZW50KCkuaGVpZ2h0KCkpXHJcbiAgICAgICAgaGUgPSBoZS5wYXJlbnQoKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBlbnN1cmUgZGVmYXVsdHNcclxuICAgICAgdGhpcy54ICAgICAgPSAwXHJcbiAgICAgIHRoaXMueSAgICAgID0gMFxyXG4gICAgICB0aGlzLndpZHRoICA9IHdpZHRoICAqIHdtXHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogaG1cclxuICAgICAgdGhpcy56b29tICAgPSAxXHJcblxyXG4gICAgICBpZiAodmlldykge1xyXG4gICAgICAgIC8vIGdldCB3aWR0aCBhbmQgaGVpZ2h0IGZyb20gdmlld2JveFxyXG4gICAgICAgIHggICAgICA9IHBhcnNlRmxvYXQodmlld1swXSlcclxuICAgICAgICB5ICAgICAgPSBwYXJzZUZsb2F0KHZpZXdbMV0pXHJcbiAgICAgICAgd2lkdGggID0gcGFyc2VGbG9hdCh2aWV3WzJdKVxyXG4gICAgICAgIGhlaWdodCA9IHBhcnNlRmxvYXQodmlld1szXSlcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHpvb20gYWNjb3JpbmcgdG8gdmlld2JveFxyXG4gICAgICAgIHRoaXMuem9vbSA9ICgodGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0KSA+ICh3aWR0aCAvIGhlaWdodCkpID9cclxuICAgICAgICAgIHRoaXMuaGVpZ2h0IC8gaGVpZ2h0IDpcclxuICAgICAgICAgIHRoaXMud2lkdGggIC8gd2lkdGhcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlYWwgcGl4ZWwgZGltZW5zaW9ucyBvbiBwYXJlbnQgU1ZHLkRvYyBlbGVtZW50XHJcbiAgICAgICAgdGhpcy54ICAgICAgPSB4XHJcbiAgICAgICAgdGhpcy55ICAgICAgPSB5XHJcbiAgICAgICAgdGhpcy53aWR0aCAgPSB3aWR0aFxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfWVsc2V7XHJcblxyXG4gICAgICAvLyBlbnN1cmUgc291cmNlIGFzIG9iamVjdFxyXG4gICAgICBzb3VyY2UgPSB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/XHJcbiAgICAgICAgc291cmNlLm1hdGNoKHJlZykubWFwKGZ1bmN0aW9uKGVsKXsgcmV0dXJuIHBhcnNlRmxvYXQoZWwpIH0pIDpcclxuICAgICAgQXJyYXkuaXNBcnJheShzb3VyY2UpID9cclxuICAgICAgICBzb3VyY2UgOlxyXG4gICAgICB0eXBlb2Ygc291cmNlID09ICdvYmplY3QnID9cclxuICAgICAgICBbc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHRdIDpcclxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PSA0ID9cclxuICAgICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykgOlxyXG4gICAgICAgIGJhc2VcclxuXHJcbiAgICAgIHRoaXMueCA9IHNvdXJjZVswXVxyXG4gICAgICB0aGlzLnkgPSBzb3VyY2VbMV1cclxuICAgICAgdGhpcy53aWR0aCA9IHNvdXJjZVsyXVxyXG4gICAgICB0aGlzLmhlaWdodCA9IHNvdXJjZVszXVxyXG4gICAgfVxyXG5cclxuXHJcbiAgfVxyXG5cclxuLCBleHRlbmQ6IHtcclxuXHJcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnggKyAnICcgKyB0aGlzLnkgKyAnICcgKyB0aGlzLndpZHRoICsgJyAnICsgdGhpcy5oZWlnaHRcclxuICAgIH1cclxuICAsIG1vcnBoOiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KXtcclxuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuVmlld0JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAsIGF0OiBmdW5jdGlvbihwb3MpIHtcclxuXHJcbiAgICAgIGlmKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpc1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBTVkcuVmlld0JveChbXHJcbiAgICAgICAgICB0aGlzLnggKyAodGhpcy5kZXN0aW5hdGlvbi54IC0gdGhpcy54KSAqIHBvc1xyXG4gICAgICAgICwgdGhpcy55ICsgKHRoaXMuZGVzdGluYXRpb24ueSAtIHRoaXMueSkgKiBwb3NcclxuICAgICAgICAsIHRoaXMud2lkdGggKyAodGhpcy5kZXN0aW5hdGlvbi53aWR0aCAtIHRoaXMud2lkdGgpICogcG9zXHJcbiAgICAgICAgLCB0aGlzLmhlaWdodCArICh0aGlzLmRlc3RpbmF0aW9uLmhlaWdodCAtIHRoaXMuaGVpZ2h0KSAqIHBvc1xyXG4gICAgICBdKVxyXG5cclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvLyBEZWZpbmUgcGFyZW50XHJcbiwgcGFyZW50OiBTVkcuQ29udGFpbmVyXHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcblxyXG4gICAgLy8gZ2V0L3NldCB2aWV3Ym94XHJcbiAgICB2aWV3Ym94OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApXHJcbiAgICAgICAgLy8gYWN0IGFzIGEgZ2V0dGVyIGlmIHRoZXJlIGFyZSBubyBhcmd1bWVudHNcclxuICAgICAgICByZXR1cm4gbmV3IFNWRy5WaWV3Qm94KHRoaXMpXHJcblxyXG4gICAgICAvLyBvdGhlcndpc2UgYWN0IGFzIGEgc2V0dGVyXHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3ZpZXdCb3gnLCBuZXcgU1ZHLlZpZXdCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbn0pXG4vLyBBZGQgZXZlbnRzIHRvIGVsZW1lbnRzXHJcbjtbICAnY2xpY2snXHJcbiAgLCAnZGJsY2xpY2snXHJcbiAgLCAnbW91c2Vkb3duJ1xyXG4gICwgJ21vdXNldXAnXHJcbiAgLCAnbW91c2VvdmVyJ1xyXG4gICwgJ21vdXNlb3V0J1xyXG4gICwgJ21vdXNlbW92ZSdcclxuICAvLyAsICdtb3VzZWVudGVyJyAtPiBub3Qgc3VwcG9ydGVkIGJ5IElFXHJcbiAgLy8gLCAnbW91c2VsZWF2ZScgLT4gbm90IHN1cHBvcnRlZCBieSBJRVxyXG4gICwgJ3RvdWNoc3RhcnQnXHJcbiAgLCAndG91Y2htb3ZlJ1xyXG4gICwgJ3RvdWNobGVhdmUnXHJcbiAgLCAndG91Y2hlbmQnXHJcbiAgLCAndG91Y2hjYW5jZWwnIF0uZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xyXG5cclxuICAvLyBhZGQgZXZlbnQgdG8gU1ZHLkVsZW1lbnRcclxuICBTVkcuRWxlbWVudC5wcm90b3R5cGVbZXZlbnRdID0gZnVuY3Rpb24oZikge1xyXG4gICAgLy8gYmluZCBldmVudCB0byBlbGVtZW50IHJhdGhlciB0aGFuIGVsZW1lbnQgbm9kZVxyXG4gICAgU1ZHLm9uKHRoaXMubm9kZSwgZXZlbnQsIGYpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufSlcclxuXHJcbi8vIEluaXRpYWxpemUgbGlzdGVuZXJzIHN0YWNrXHJcblNWRy5saXN0ZW5lcnMgPSBbXVxyXG5TVkcuaGFuZGxlck1hcCA9IFtdXHJcblNWRy5saXN0ZW5lcklkID0gMFxyXG5cclxuLy8gQWRkIGV2ZW50IGJpbmRlciBpbiB0aGUgU1ZHIG5hbWVzcGFjZVxyXG5TVkcub24gPSBmdW5jdGlvbihub2RlLCBldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpIHtcclxuICAvLyBjcmVhdGUgbGlzdGVuZXIsIGdldCBvYmplY3QtaW5kZXhcclxuICB2YXIgbCAgICAgPSBsaXN0ZW5lci5iaW5kKGJpbmRpbmcgfHwgbm9kZS5pbnN0YW5jZSB8fCBub2RlKVxyXG4gICAgLCBpbmRleCA9IChTVkcuaGFuZGxlck1hcC5pbmRleE9mKG5vZGUpICsgMSB8fCBTVkcuaGFuZGxlck1hcC5wdXNoKG5vZGUpKSAtIDFcclxuICAgICwgZXYgICAgPSBldmVudC5zcGxpdCgnLicpWzBdXHJcbiAgICAsIG5zICAgID0gZXZlbnQuc3BsaXQoJy4nKVsxXSB8fCAnKidcclxuXHJcblxyXG4gIC8vIGVuc3VyZSB2YWxpZCBvYmplY3RcclxuICBTVkcubGlzdGVuZXJzW2luZGV4XSAgICAgICAgID0gU1ZHLmxpc3RlbmVyc1tpbmRleF0gICAgICAgICB8fCB7fVxyXG4gIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSAgICAgPSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl0gICAgIHx8IHt9XHJcbiAgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXSA9IFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtuc10gfHwge31cclxuXHJcbiAgaWYoIWxpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWQpXHJcbiAgICBsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkID0gKytTVkcubGlzdGVuZXJJZFxyXG5cclxuICAvLyByZWZlcmVuY2UgbGlzdGVuZXJcclxuICBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdW2xpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWRdID0gbFxyXG5cclxuICAvLyBhZGQgbGlzdGVuZXJcclxuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXYsIGwsIG9wdGlvbnMgfHwgZmFsc2UpXHJcbn1cclxuXHJcbi8vIEFkZCBldmVudCB1bmJpbmRlciBpbiB0aGUgU1ZHIG5hbWVzcGFjZVxyXG5TVkcub2ZmID0gZnVuY3Rpb24obm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgdmFyIGluZGV4ID0gU1ZHLmhhbmRsZXJNYXAuaW5kZXhPZihub2RlKVxyXG4gICAgLCBldiAgICA9IGV2ZW50ICYmIGV2ZW50LnNwbGl0KCcuJylbMF1cclxuICAgICwgbnMgICAgPSBldmVudCAmJiBldmVudC5zcGxpdCgnLicpWzFdXHJcbiAgICAsIG5hbWVzcGFjZSA9ICcnXHJcblxyXG4gIGlmKGluZGV4ID09IC0xKSByZXR1cm5cclxuXHJcbiAgaWYgKGxpc3RlbmVyKSB7XHJcbiAgICBpZih0eXBlb2YgbGlzdGVuZXIgPT0gJ2Z1bmN0aW9uJykgbGlzdGVuZXIgPSBsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkXHJcbiAgICBpZighbGlzdGVuZXIpIHJldHVyblxyXG5cclxuICAgIC8vIHJlbW92ZSBsaXN0ZW5lciByZWZlcmVuY2VcclxuICAgIGlmIChTVkcubGlzdGVuZXJzW2luZGV4XVtldl0gJiYgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zIHx8ICcqJ10pIHtcclxuICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyXHJcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zIHx8ICcqJ11bbGlzdGVuZXJdLCBmYWxzZSlcclxuXHJcbiAgICAgIGRlbGV0ZSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnMgfHwgJyonXVtsaXN0ZW5lcl1cclxuICAgIH1cclxuXHJcbiAgfSBlbHNlIGlmIChucyAmJiBldikge1xyXG4gICAgLy8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIGEgbmFtZXNwYWNlZCBldmVudFxyXG4gICAgaWYgKFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSAmJiBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdKSB7XHJcbiAgICAgIGZvciAobGlzdGVuZXIgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXSlcclxuICAgICAgICBTVkcub2ZmKG5vZGUsIFtldiwgbnNdLmpvaW4oJy4nKSwgbGlzdGVuZXIpXHJcblxyXG4gICAgICBkZWxldGUgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXVxyXG4gICAgfVxyXG5cclxuICB9IGVsc2UgaWYgKG5zKXtcclxuICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIG5hbWVzcGFjZVxyXG4gICAgZm9yKGV2ZW50IGluIFNWRy5saXN0ZW5lcnNbaW5kZXhdKXtcclxuICAgICAgICBmb3IobmFtZXNwYWNlIGluIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2ZW50XSl7XHJcbiAgICAgICAgICAgIGlmKG5zID09PSBuYW1lc3BhY2Upe1xyXG4gICAgICAgICAgICAgICAgU1ZHLm9mZihub2RlLCBbZXZlbnQsIG5zXS5qb2luKCcuJykpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gIH0gZWxzZSBpZiAoZXYpIHtcclxuICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnRcclxuICAgIGlmIChTVkcubGlzdGVuZXJzW2luZGV4XVtldl0pIHtcclxuICAgICAgZm9yIChuYW1lc3BhY2UgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdKVxyXG4gICAgICAgIFNWRy5vZmYobm9kZSwgW2V2LCBuYW1lc3BhY2VdLmpvaW4oJy4nKSlcclxuXHJcbiAgICAgIGRlbGV0ZSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1cclxuICAgIH1cclxuXHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIGEgZ2l2ZW4gbm9kZVxyXG4gICAgZm9yIChldmVudCBpbiBTVkcubGlzdGVuZXJzW2luZGV4XSlcclxuICAgICAgU1ZHLm9mZihub2RlLCBldmVudClcclxuXHJcbiAgICBkZWxldGUgU1ZHLmxpc3RlbmVyc1tpbmRleF1cclxuICAgIGRlbGV0ZSBTVkcuaGFuZGxlck1hcFtpbmRleF1cclxuXHJcbiAgfVxyXG59XHJcblxyXG4vL1xyXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcbiAgLy8gQmluZCBnaXZlbiBldmVudCB0byBsaXN0ZW5lclxyXG4gIG9uOiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpIHtcclxuICAgIFNWRy5vbih0aGlzLm5vZGUsIGV2ZW50LCBsaXN0ZW5lciwgYmluZGluZywgb3B0aW9ucylcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICAvLyBVbmJpbmQgZXZlbnQgZnJvbSBsaXN0ZW5lclxyXG4sIG9mZjogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICBTVkcub2ZmKHRoaXMubm9kZSwgZXZlbnQsIGxpc3RlbmVyKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIEZpcmUgZ2l2ZW4gZXZlbnRcclxuLCBmaXJlOiBmdW5jdGlvbihldmVudCwgZGF0YSkge1xyXG5cclxuICAgIC8vIERpc3BhdGNoIGV2ZW50XHJcbiAgICBpZihldmVudCBpbnN0YW5jZW9mIHdpbmRvdy5FdmVudCl7XHJcbiAgICAgICAgdGhpcy5ub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpXHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLm5vZGUuZGlzcGF0Y2hFdmVudChldmVudCA9IG5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoZXZlbnQsIHtkZXRhaWw6ZGF0YSwgY2FuY2VsYWJsZTogdHJ1ZX0pKVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2V2ZW50ID0gZXZlbnRcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4sIGV2ZW50OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9ldmVudFxyXG4gIH1cclxufSlcclxuXG5cclxuU1ZHLkRlZnMgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICdkZWZzJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXHJcblxyXG59KVxuU1ZHLkcgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICdnJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXHJcblxyXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXHJcbiAgICB4OiBmdW5jdGlvbih4KSB7XHJcbiAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLnRyYW5zZm9ybSgneCcpIDogdGhpcy50cmFuc2Zvcm0oeyB4OiB4IC0gdGhpcy54KCkgfSwgdHJ1ZSlcclxuICAgIH1cclxuICAgIC8vIE1vdmUgb3ZlciB5LWF4aXNcclxuICAsIHk6IGZ1bmN0aW9uKHkpIHtcclxuICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMudHJhbnNmb3JtKCd5JykgOiB0aGlzLnRyYW5zZm9ybSh7IHk6IHkgLSB0aGlzLnkoKSB9LCB0cnVlKVxyXG4gICAgfVxyXG4gICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcclxuICAsIGN4OiBmdW5jdGlvbih4KSB7XHJcbiAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmdib3goKS5jeCA6IHRoaXMueCh4IC0gdGhpcy5nYm94KCkud2lkdGggLyAyKVxyXG4gICAgfVxyXG4gICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB5LWF4aXNcclxuICAsIGN5OiBmdW5jdGlvbih5KSB7XHJcbiAgICAgIHJldHVybiB5ID09IG51bGwgPyB0aGlzLmdib3goKS5jeSA6IHRoaXMueSh5IC0gdGhpcy5nYm94KCkuaGVpZ2h0IC8gMilcclxuICAgIH1cclxuICAsIGdib3g6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdmFyIGJib3ggID0gdGhpcy5iYm94KClcclxuICAgICAgICAsIHRyYW5zID0gdGhpcy50cmFuc2Zvcm0oKVxyXG5cclxuICAgICAgYmJveC54ICArPSB0cmFucy54XHJcbiAgICAgIGJib3gueDIgKz0gdHJhbnMueFxyXG4gICAgICBiYm94LmN4ICs9IHRyYW5zLnhcclxuXHJcbiAgICAgIGJib3gueSAgKz0gdHJhbnMueVxyXG4gICAgICBiYm94LnkyICs9IHRyYW5zLnlcclxuICAgICAgYmJveC5jeSArPSB0cmFucy55XHJcblxyXG4gICAgICByZXR1cm4gYmJveFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcclxuLCBjb25zdHJ1Y3Q6IHtcclxuICAgIC8vIENyZWF0ZSBhIGdyb3VwIGVsZW1lbnRcclxuICAgIGdyb3VwOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuRylcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxuLy8gIyMjIFRoaXMgbW9kdWxlIGFkZHMgYmFja3dhcmQgLyBmb3J3YXJkIGZ1bmN0aW9uYWxpdHkgdG8gZWxlbWVudHMuXHJcblxyXG4vL1xyXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcbiAgLy8gR2V0IGFsbCBzaWJsaW5ncywgaW5jbHVkaW5nIG15c2VsZlxyXG4gIHNpYmxpbmdzOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKClcclxuICB9XHJcbiAgLy8gR2V0IHRoZSBjdXJlbnQgcG9zaXRpb24gc2libGluZ3NcclxuLCBwb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5pbmRleCh0aGlzKVxyXG4gIH1cclxuICAvLyBHZXQgdGhlIG5leHQgZWxlbWVudCAod2lsbCByZXR1cm4gbnVsbCBpZiB0aGVyZSBpcyBub25lKVxyXG4sIG5leHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgKyAxXVxyXG4gIH1cclxuICAvLyBHZXQgdGhlIG5leHQgZWxlbWVudCAod2lsbCByZXR1cm4gbnVsbCBpZiB0aGVyZSBpcyBub25lKVxyXG4sIHByZXZpb3VzOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnNpYmxpbmdzKClbdGhpcy5wb3NpdGlvbigpIC0gMV1cclxuICB9XHJcbiAgLy8gU2VuZCBnaXZlbiBlbGVtZW50IG9uZSBzdGVwIGZvcndhcmRcclxuLCBmb3J3YXJkOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpICsgMVxyXG4gICAgICAsIHAgPSB0aGlzLnBhcmVudCgpXHJcblxyXG4gICAgLy8gbW92ZSBub2RlIG9uZSBzdGVwIGZvcndhcmRcclxuICAgIHAucmVtb3ZlRWxlbWVudCh0aGlzKS5hZGQodGhpcywgaSlcclxuXHJcbiAgICAvLyBtYWtlIHN1cmUgZGVmcyBub2RlIGlzIGFsd2F5cyBhdCB0aGUgdG9wXHJcbiAgICBpZiAocCBpbnN0YW5jZW9mIFNWRy5Eb2MpXHJcbiAgICAgIHAubm9kZS5hcHBlbmRDaGlsZChwLmRlZnMoKS5ub2RlKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBvbmUgc3RlcCBiYWNrd2FyZFxyXG4sIGJhY2t3YXJkOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpXHJcblxyXG4gICAgaWYgKGkgPiAwKVxyXG4gICAgICB0aGlzLnBhcmVudCgpLnJlbW92ZUVsZW1lbnQodGhpcykuYWRkKHRoaXMsIGkgLSAxKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBhbGwgdGhlIHdheSB0byB0aGUgZnJvbnRcclxuLCBmcm9udDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcCA9IHRoaXMucGFyZW50KClcclxuXHJcbiAgICAvLyBNb3ZlIG5vZGUgZm9yd2FyZFxyXG4gICAgcC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZSlcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgZGVmcyBub2RlIGlzIGFsd2F5cyBhdCB0aGUgdG9wXHJcbiAgICBpZiAocCBpbnN0YW5jZW9mIFNWRy5Eb2MpXHJcbiAgICAgIHAubm9kZS5hcHBlbmRDaGlsZChwLmRlZnMoKS5ub2RlKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBhbGwgdGhlIHdheSB0byB0aGUgYmFja1xyXG4sIGJhY2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMucG9zaXRpb24oKSA+IDApXHJcbiAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKS5hZGQodGhpcywgMClcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICAvLyBJbnNlcnRzIGEgZ2l2ZW4gZWxlbWVudCBiZWZvcmUgdGhlIHRhcmdldGVkIGVsZW1lbnRcclxuLCBiZWZvcmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQucmVtb3ZlKClcclxuXHJcbiAgICB2YXIgaSA9IHRoaXMucG9zaXRpb24oKVxyXG5cclxuICAgIHRoaXMucGFyZW50KCkuYWRkKGVsZW1lbnQsIGkpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgLy8gSW5zdGVycyBhIGdpdmVuIGVsZW1lbnQgYWZ0ZXIgdGhlIHRhcmdldGVkIGVsZW1lbnRcclxuLCBhZnRlcjogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5yZW1vdmUoKVxyXG5cclxuICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpXHJcblxyXG4gICAgdGhpcy5wYXJlbnQoKS5hZGQoZWxlbWVudCwgaSArIDEpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG59KVxuU1ZHLk1hc2sgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUoJ21hc2snKSlcclxuXHJcbiAgICAvLyBrZWVwIHJlZmVyZW5jZXMgdG8gbWFza2VkIGVsZW1lbnRzXHJcbiAgICB0aGlzLnRhcmdldHMgPSBbXVxyXG4gIH1cclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLkNvbnRhaW5lclxyXG5cclxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xyXG4sIGV4dGVuZDoge1xyXG4gICAgLy8gVW5tYXNrIGFsbCBtYXNrZWQgZWxlbWVudHMgYW5kIHJlbW92ZSBpdHNlbGZcclxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8vIHVubWFzayBhbGwgdGFyZ2V0c1xyXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50YXJnZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgIGlmICh0aGlzLnRhcmdldHNbaV0pXHJcbiAgICAgICAgICB0aGlzLnRhcmdldHNbaV0udW5tYXNrKClcclxuICAgICAgdGhpcy50YXJnZXRzID0gW11cclxuXHJcbiAgICAgIC8vIHJlbW92ZSBtYXNrIGZyb20gcGFyZW50XHJcbiAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgbWFza2luZyBlbGVtZW50XHJcbiAgICBtYXNrOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLnB1dChuZXcgU1ZHLk1hc2spXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cclxuXHJcblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAvLyBEaXN0cmlidXRlIG1hc2sgdG8gc3ZnIGVsZW1lbnRcclxuICBtYXNrV2l0aDogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgLy8gdXNlIGdpdmVuIG1hc2sgb3IgY3JlYXRlIGEgbmV3IG9uZVxyXG4gICAgdGhpcy5tYXNrZXIgPSBlbGVtZW50IGluc3RhbmNlb2YgU1ZHLk1hc2sgPyBlbGVtZW50IDogdGhpcy5wYXJlbnQoKS5tYXNrKCkuYWRkKGVsZW1lbnQpXHJcblxyXG4gICAgLy8gc3RvcmUgcmV2ZXJlbmNlIG9uIHNlbGYgaW4gbWFza1xyXG4gICAgdGhpcy5tYXNrZXIudGFyZ2V0cy5wdXNoKHRoaXMpXHJcblxyXG4gICAgLy8gYXBwbHkgbWFza1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cignbWFzaycsICd1cmwoXCIjJyArIHRoaXMubWFza2VyLmF0dHIoJ2lkJykgKyAnXCIpJylcclxuICB9XHJcbiAgLy8gVW5tYXNrIGVsZW1lbnRcclxuLCB1bm1hc2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgZGVsZXRlIHRoaXMubWFza2VyXHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXNrJywgbnVsbClcclxuICB9XHJcblxyXG59KVxyXG5cblNWRy5DbGlwUGF0aCA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnY2xpcFBhdGgnKSlcclxuXHJcbiAgICAvLyBrZWVwIHJlZmVyZW5jZXMgdG8gY2xpcHBlZCBlbGVtZW50c1xyXG4gICAgdGhpcy50YXJnZXRzID0gW11cclxuICB9XHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5Db250YWluZXJcclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIFVuY2xpcCBhbGwgY2xpcHBlZCBlbGVtZW50cyBhbmQgcmVtb3ZlIGl0c2VsZlxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gdW5jbGlwIGFsbCB0YXJnZXRzXHJcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRhcmdldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0c1tpXSlcclxuICAgICAgICAgIHRoaXMudGFyZ2V0c1tpXS51bmNsaXAoKVxyXG4gICAgICB0aGlzLnRhcmdldHMgPSBbXVxyXG5cclxuICAgICAgLy8gcmVtb3ZlIGNsaXBQYXRoIGZyb20gcGFyZW50XHJcbiAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgY2xpcHBpbmcgZWxlbWVudFxyXG4gICAgY2xpcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wdXQobmV3IFNWRy5DbGlwUGF0aClcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG4vL1xyXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcbiAgLy8gRGlzdHJpYnV0ZSBjbGlwUGF0aCB0byBzdmcgZWxlbWVudFxyXG4gIGNsaXBXaXRoOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAvLyB1c2UgZ2l2ZW4gY2xpcCBvciBjcmVhdGUgYSBuZXcgb25lXHJcbiAgICB0aGlzLmNsaXBwZXIgPSBlbGVtZW50IGluc3RhbmNlb2YgU1ZHLkNsaXBQYXRoID8gZWxlbWVudCA6IHRoaXMucGFyZW50KCkuY2xpcCgpLmFkZChlbGVtZW50KVxyXG5cclxuICAgIC8vIHN0b3JlIHJldmVyZW5jZSBvbiBzZWxmIGluIG1hc2tcclxuICAgIHRoaXMuY2xpcHBlci50YXJnZXRzLnB1c2godGhpcylcclxuXHJcbiAgICAvLyBhcHBseSBtYXNrXHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKFwiIycgKyB0aGlzLmNsaXBwZXIuYXR0cignaWQnKSArICdcIiknKVxyXG4gIH1cclxuICAvLyBVbmNsaXAgZWxlbWVudFxyXG4sIHVuY2xpcDogZnVuY3Rpb24oKSB7XHJcbiAgICBkZWxldGUgdGhpcy5jbGlwcGVyXHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCBudWxsKVxyXG4gIH1cclxuXHJcbn0pXG5TVkcuR3JhZGllbnQgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKHR5cGUgKyAnR3JhZGllbnQnKSlcclxuXHJcbiAgICAvLyBzdG9yZSB0eXBlXHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlXHJcbiAgfVxyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXHJcblxyXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBBZGQgYSBjb2xvciBzdG9wXHJcbiAgICBhdDogZnVuY3Rpb24ob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5TdG9wKS51cGRhdGUob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSlcclxuICAgIH1cclxuICAgIC8vIFVwZGF0ZSBncmFkaWVudFxyXG4gICwgdXBkYXRlOiBmdW5jdGlvbihibG9jaykge1xyXG4gICAgICAvLyByZW1vdmUgYWxsIHN0b3BzXHJcbiAgICAgIHRoaXMuY2xlYXIoKVxyXG5cclxuICAgICAgLy8gaW52b2tlIHBhc3NlZCBibG9ja1xyXG4gICAgICBpZiAodHlwZW9mIGJsb2NrID09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIFJldHVybiB0aGUgZmlsbCBpZFxyXG4gICwgZmlsbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknXHJcbiAgICB9XHJcbiAgICAvLyBBbGlhcyBzdHJpbmcgY29udmVydGlvbiB0byBmaWxsXHJcbiAgLCB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpbGwoKVxyXG4gICAgfVxyXG4gICAgLy8gY3VzdG9tIGF0dHIgdG8gaGFuZGxlIHRyYW5zZm9ybVxyXG4gICwgYXR0cjogZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICBpZihhID09ICd0cmFuc2Zvcm0nKSBhID0gJ2dyYWRpZW50VHJhbnNmb3JtJ1xyXG4gICAgICByZXR1cm4gU1ZHLkNvbnRhaW5lci5wcm90b3R5cGUuYXR0ci5jYWxsKHRoaXMsIGEsIGIsIGMpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gQ3JlYXRlIGdyYWRpZW50IGVsZW1lbnQgaW4gZGVmc1xyXG4gICAgZ3JhZGllbnQ6IGZ1bmN0aW9uKHR5cGUsIGJsb2NrKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5ncmFkaWVudCh0eXBlLCBibG9jaylcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG4vLyBBZGQgYW5pbWF0YWJsZSBtZXRob2RzIHRvIGJvdGggZ3JhZGllbnQgYW5kIGZ4IG1vZHVsZVxyXG5TVkcuZXh0ZW5kKFNWRy5HcmFkaWVudCwgU1ZHLkZYLCB7XHJcbiAgLy8gRnJvbSBwb3NpdGlvblxyXG4gIGZyb206IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHJldHVybiAodGhpcy5fdGFyZ2V0IHx8IHRoaXMpLnR5cGUgPT0gJ3JhZGlhbCcgP1xyXG4gICAgICB0aGlzLmF0dHIoeyBmeDogbmV3IFNWRy5OdW1iZXIoeCksIGZ5OiBuZXcgU1ZHLk51bWJlcih5KSB9KSA6XHJcbiAgICAgIHRoaXMuYXR0cih7IHgxOiBuZXcgU1ZHLk51bWJlcih4KSwgeTE6IG5ldyBTVkcuTnVtYmVyKHkpIH0pXHJcbiAgfVxyXG4gIC8vIFRvIHBvc2l0aW9uXHJcbiwgdG86IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHJldHVybiAodGhpcy5fdGFyZ2V0IHx8IHRoaXMpLnR5cGUgPT0gJ3JhZGlhbCcgP1xyXG4gICAgICB0aGlzLmF0dHIoeyBjeDogbmV3IFNWRy5OdW1iZXIoeCksIGN5OiBuZXcgU1ZHLk51bWJlcih5KSB9KSA6XHJcbiAgICAgIHRoaXMuYXR0cih7IHgyOiBuZXcgU1ZHLk51bWJlcih4KSwgeTI6IG5ldyBTVkcuTnVtYmVyKHkpIH0pXHJcbiAgfVxyXG59KVxyXG5cclxuLy8gQmFzZSBncmFkaWVudCBnZW5lcmF0aW9uXHJcblNWRy5leHRlbmQoU1ZHLkRlZnMsIHtcclxuICAvLyBkZWZpbmUgZ3JhZGllbnRcclxuICBncmFkaWVudDogZnVuY3Rpb24odHlwZSwgYmxvY2spIHtcclxuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkdyYWRpZW50KHR5cGUpKS51cGRhdGUoYmxvY2spXHJcbiAgfVxyXG5cclxufSlcclxuXHJcblNWRy5TdG9wID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiAnc3RvcCdcclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLkVsZW1lbnRcclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIGFkZCBjb2xvciBzdG9wc1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbihvKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgbyA9PSAnbnVtYmVyJyB8fCBvIGluc3RhbmNlb2YgU1ZHLk51bWJlcikge1xyXG4gICAgICAgIG8gPSB7XHJcbiAgICAgICAgICBvZmZzZXQ6ICBhcmd1bWVudHNbMF1cclxuICAgICAgICAsIGNvbG9yOiAgIGFyZ3VtZW50c1sxXVxyXG4gICAgICAgICwgb3BhY2l0eTogYXJndW1lbnRzWzJdXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzZXQgYXR0cmlidXRlc1xyXG4gICAgICBpZiAoby5vcGFjaXR5ICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1vcGFjaXR5Jywgby5vcGFjaXR5KVxyXG4gICAgICBpZiAoby5jb2xvciAgICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1jb2xvcicsIG8uY29sb3IpXHJcbiAgICAgIGlmIChvLm9mZnNldCAgIT0gbnVsbCkgdGhpcy5hdHRyKCdvZmZzZXQnLCBuZXcgU1ZHLk51bWJlcihvLm9mZnNldCkpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pXHJcblxuU1ZHLlBhdHRlcm4gPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICdwYXR0ZXJuJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXHJcblxyXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcclxuICAgIGZpbGw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJ1xyXG4gICAgfVxyXG4gICAgLy8gVXBkYXRlIHBhdHRlcm4gYnkgcmVidWlsZGluZ1xyXG4gICwgdXBkYXRlOiBmdW5jdGlvbihibG9jaykge1xyXG4gICAgICAvLyByZW1vdmUgY29udGVudFxyXG4gICAgICB0aGlzLmNsZWFyKClcclxuXHJcbiAgICAgIC8vIGludm9rZSBwYXNzZWQgYmxvY2tcclxuICAgICAgaWYgKHR5cGVvZiBibG9jayA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIGJsb2NrLmNhbGwodGhpcywgdGhpcylcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBBbGlhcyBzdHJpbmcgY29udmVydGlvbiB0byBmaWxsXHJcbiAgLCB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpbGwoKVxyXG4gICAgfVxyXG4gICAgLy8gY3VzdG9tIGF0dHIgdG8gaGFuZGxlIHRyYW5zZm9ybVxyXG4gICwgYXR0cjogZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICBpZihhID09ICd0cmFuc2Zvcm0nKSBhID0gJ3BhdHRlcm5UcmFuc2Zvcm0nXHJcbiAgICAgIHJldHVybiBTVkcuQ29udGFpbmVyLnByb3RvdHlwZS5hdHRyLmNhbGwodGhpcywgYSwgYiwgYylcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gQ3JlYXRlIHBhdHRlcm4gZWxlbWVudCBpbiBkZWZzXHJcbiAgICBwYXR0ZXJuOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xyXG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkucGF0dGVybih3aWR0aCwgaGVpZ2h0LCBibG9jaylcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5EZWZzLCB7XHJcbiAgLy8gRGVmaW5lIGdyYWRpZW50XHJcbiAgcGF0dGVybjogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgYmxvY2spIHtcclxuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBhdHRlcm4pLnVwZGF0ZShibG9jaykuYXR0cih7XHJcbiAgICAgIHg6ICAgICAgICAgICAgMFxyXG4gICAgLCB5OiAgICAgICAgICAgIDBcclxuICAgICwgd2lkdGg6ICAgICAgICB3aWR0aFxyXG4gICAgLCBoZWlnaHQ6ICAgICAgIGhlaWdodFxyXG4gICAgLCBwYXR0ZXJuVW5pdHM6ICd1c2VyU3BhY2VPblVzZSdcclxuICAgIH0pXHJcbiAgfVxyXG5cclxufSlcblNWRy5Eb2MgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgIC8vIGVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYSBkb20gZWxlbWVudFxyXG4gICAgICBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycgP1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpIDpcclxuICAgICAgICBlbGVtZW50XHJcblxyXG4gICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGFuIHN2ZyBlbGVtZW50LCB1c2UgdGhhdCBlbGVtZW50IGFzIHRoZSBtYWluIHdyYXBwZXIuXHJcbiAgICAgIC8vIFRoaXMgYWxsb3dzIHN2Zy5qcyB0byB3b3JrIHdpdGggc3ZnIGRvY3VtZW50cyBhcyB3ZWxsLlxyXG4gICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PSAnc3ZnJykge1xyXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbGVtZW50KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdzdmcnKSlcclxuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMubm9kZSlcclxuICAgICAgICB0aGlzLnNpemUoJzEwMCUnLCAnMTAwJScpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHNldCBzdmcgZWxlbWVudCBhdHRyaWJ1dGVzIGFuZCBlbnN1cmUgZGVmcyBub2RlXHJcbiAgICAgIHRoaXMubmFtZXNwYWNlKCkuZGVmcygpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXHJcblxyXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBBZGQgbmFtZXNwYWNlc1xyXG4gICAgbmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAuYXR0cih7IHhtbG5zOiBTVkcubnMsIHZlcnNpb246ICcxLjEnIH0pXHJcbiAgICAgICAgLmF0dHIoJ3htbG5zOnhsaW5rJywgU1ZHLnhsaW5rLCBTVkcueG1sbnMpXHJcbiAgICAgICAgLmF0dHIoJ3htbG5zOnN2Z2pzJywgU1ZHLnN2Z2pzLCBTVkcueG1sbnMpXHJcbiAgICB9XHJcbiAgICAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGRlZnMgZWxlbWVudFxyXG4gICwgZGVmczogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICghdGhpcy5fZGVmcykge1xyXG4gICAgICAgIHZhciBkZWZzXHJcblxyXG4gICAgICAgIC8vIEZpbmQgb3IgY3JlYXRlIGEgZGVmcyBlbGVtZW50IGluIHRoaXMgaW5zdGFuY2VcclxuICAgICAgICBpZiAoZGVmcyA9IHRoaXMubm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZGVmcycpWzBdKVxyXG4gICAgICAgICAgdGhpcy5fZGVmcyA9IFNWRy5hZG9wdChkZWZzKVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMuX2RlZnMgPSBuZXcgU1ZHLkRlZnNcclxuXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBkZWZzIG5vZGUgaXMgYXQgdGhlIGVuZCBvZiB0aGUgc3RhY2tcclxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5fZGVmcy5ub2RlKVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5fZGVmc1xyXG4gICAgfVxyXG4gICAgLy8gY3VzdG9tIHBhcmVudCBtZXRob2RcclxuICAsIHBhcmVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZSA9PSAnI2RvY3VtZW50JyA/IG51bGwgOiB0aGlzLm5vZGUucGFyZW50Tm9kZVxyXG4gICAgfVxyXG4gICAgLy8gRml4IGZvciBwb3NzaWJsZSBzdWItcGl4ZWwgb2Zmc2V0LiBTZWU6XHJcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02MDg4MTJcclxuICAsIHNwb2Y6IGZ1bmN0aW9uKHNwb2YpIHtcclxuICAgICAgdmFyIHBvcyA9IHRoaXMubm9kZS5nZXRTY3JlZW5DVE0oKVxyXG5cclxuICAgICAgaWYgKHBvcylcclxuICAgICAgICB0aGlzXHJcbiAgICAgICAgICAuc3R5bGUoJ2xlZnQnLCAoLXBvcy5lICUgMSkgKyAncHgnKVxyXG4gICAgICAgICAgLnN0eWxlKCd0b3AnLCAgKC1wb3MuZiAlIDEpICsgJ3B4JylcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmVzIHRoZSBkb2MgZnJvbSB0aGUgRE9NXHJcbiAgLCByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZih0aGlzLnBhcmVudCgpKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQoKS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgLCBjbGVhcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8vIHJlbW92ZSBjaGlsZHJlblxyXG4gICAgICB3aGlsZSh0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpKVxyXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKVxyXG5cclxuICAgICAgLy8gcmVtb3ZlIGRlZnMgcmVmZXJlbmNlXHJcbiAgICAgIGRlbGV0ZSB0aGlzLl9kZWZzXHJcblxyXG4gICAgICAvLyBhZGQgYmFjayBwYXJzZXJcclxuICAgICAgaWYoIVNWRy5wYXJzZXIuZHJhdy5wYXJlbnROb2RlKVxyXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChTVkcucGFyc2VyLmRyYXcpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pXHJcblxuU1ZHLlNoYXBlID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgZWxlbWVudClcclxuICB9XHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5FbGVtZW50XHJcblxyXG59KVxuXHJcblNWRy5CYXJlID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZVxyXG4gIGNyZWF0ZTogZnVuY3Rpb24oZWxlbWVudCwgaW5oZXJpdCkge1xyXG4gICAgLy8gY29uc3RydWN0IGVsZW1lbnRcclxuICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKGVsZW1lbnQpKVxyXG5cclxuICAgIC8vIGluaGVyaXQgY3VzdG9tIG1ldGhvZHNcclxuICAgIGlmIChpbmhlcml0KVxyXG4gICAgICBmb3IgKHZhciBtZXRob2QgaW4gaW5oZXJpdC5wcm90b3R5cGUpXHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbmhlcml0LnByb3RvdHlwZVttZXRob2RdID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgdGhpc1ttZXRob2RdID0gaW5oZXJpdC5wcm90b3R5cGVbbWV0aG9kXVxyXG4gIH1cclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLkVsZW1lbnRcclxuXHJcbiAgLy8gQWRkIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIEluc2VydCBzb21lIHBsYWluIHRleHRcclxuICAgIHdvcmRzOiBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgIC8vIHJlbW92ZSBjb250ZW50c1xyXG4gICAgICB3aGlsZSAodGhpcy5ub2RlLmhhc0NoaWxkTm9kZXMoKSlcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlLmxhc3RDaGlsZClcclxuXHJcbiAgICAgIC8vIGNyZWF0ZSB0ZXh0IG5vZGVcclxuICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG5cclxuU1ZHLmV4dGVuZChTVkcuUGFyZW50LCB7XHJcbiAgLy8gQ3JlYXRlIGFuIGVsZW1lbnQgdGhhdCBpcyBub3QgZGVzY3JpYmVkIGJ5IFNWRy5qc1xyXG4gIGVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGluaGVyaXQpIHtcclxuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkJhcmUoZWxlbWVudCwgaW5oZXJpdCkpXHJcbiAgfVxyXG59KVxyXG5cblNWRy5TeW1ib2wgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICdzeW1ib2wnXHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5Db250YWluZXJcclxuXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBjcmVhdGUgc3ltYm9sXHJcbiAgICBzeW1ib2w6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5TeW1ib2wpXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cblNWRy5Vc2UgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICd1c2UnXHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5TaGFwZVxyXG5cclxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xyXG4sIGV4dGVuZDoge1xyXG4gICAgLy8gVXNlIGVsZW1lbnQgYXMgYSByZWZlcmVuY2VcclxuICAgIGVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGZpbGUpIHtcclxuICAgICAgLy8gU2V0IGxpbmVkIGVsZW1lbnRcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsIChmaWxlIHx8ICcnKSArICcjJyArIGVsZW1lbnQsIFNWRy54bGluaylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgYSB1c2UgZWxlbWVudFxyXG4gICAgdXNlOiBmdW5jdGlvbihlbGVtZW50LCBmaWxlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlVzZSkuZWxlbWVudChlbGVtZW50LCBmaWxlKVxyXG4gICAgfVxyXG4gIH1cclxufSlcblNWRy5SZWN0ID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiAncmVjdCdcclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLlNoYXBlXHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgYSByZWN0IGVsZW1lbnRcclxuICAgIHJlY3Q6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuUmVjdCgpKS5zaXplKHdpZHRoLCBoZWlnaHQpXHJcbiAgICB9XHJcbiAgfVxyXG59KVxuU1ZHLkNpcmNsZSA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogJ2NpcmNsZSdcclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLlNoYXBlXHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgY2lyY2xlIGVsZW1lbnQsIGJhc2VkIG9uIGVsbGlwc2VcclxuICAgIGNpcmNsZTogZnVuY3Rpb24oc2l6ZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5DaXJjbGUpLnJ4KG5ldyBTVkcuTnVtYmVyKHNpemUpLmRpdmlkZSgyKSkubW92ZSgwLCAwKVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXHJcblNWRy5leHRlbmQoU1ZHLkNpcmNsZSwgU1ZHLkZYLCB7XHJcbiAgLy8gUmFkaXVzIHggdmFsdWVcclxuICByeDogZnVuY3Rpb24ocngpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3InLCByeClcclxuICB9XHJcbiAgLy8gQWxpYXMgcmFkaXVzIHggdmFsdWVcclxuLCByeTogZnVuY3Rpb24ocnkpIHtcclxuICAgIHJldHVybiB0aGlzLnJ4KHJ5KVxyXG4gIH1cclxufSlcclxuXHJcblNWRy5FbGxpcHNlID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiAnZWxsaXBzZSdcclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLlNoYXBlXHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgYW4gZWxsaXBzZVxyXG4gICAgZWxsaXBzZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5FbGxpcHNlKS5zaXplKHdpZHRoLCBoZWlnaHQpLm1vdmUoMCwgMClcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5FbGxpcHNlLCBTVkcuUmVjdCwgU1ZHLkZYLCB7XHJcbiAgLy8gUmFkaXVzIHggdmFsdWVcclxuICByeDogZnVuY3Rpb24ocngpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3J4JywgcngpXHJcbiAgfVxyXG4gIC8vIFJhZGl1cyB5IHZhbHVlXHJcbiwgcnk6IGZ1bmN0aW9uKHJ5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdyeScsIHJ5KVxyXG4gIH1cclxufSlcclxuXHJcbi8vIEFkZCBjb21tb24gbWV0aG9kXHJcblNWRy5leHRlbmQoU1ZHLkNpcmNsZSwgU1ZHLkVsbGlwc2UsIHtcclxuICAgIC8vIE1vdmUgb3ZlciB4LWF4aXNcclxuICAgIHg6IGZ1bmN0aW9uKHgpIHtcclxuICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuY3goKSAtIHRoaXMucngoKSA6IHRoaXMuY3goeCArIHRoaXMucngoKSlcclxuICAgIH1cclxuICAgIC8vIE1vdmUgb3ZlciB5LWF4aXNcclxuICAsIHk6IGZ1bmN0aW9uKHkpIHtcclxuICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuY3koKSAtIHRoaXMucnkoKSA6IHRoaXMuY3koeSArIHRoaXMucnkoKSlcclxuICAgIH1cclxuICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeC1heGlzXHJcbiAgLCBjeDogZnVuY3Rpb24oeCkge1xyXG4gICAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5hdHRyKCdjeCcpIDogdGhpcy5hdHRyKCdjeCcsIHgpXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xyXG4gICwgY3k6IGZ1bmN0aW9uKHkpIHtcclxuICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYXR0cignY3knKSA6IHRoaXMuYXR0cignY3knLCB5KVxyXG4gICAgfVxyXG4gICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcclxuICAsIHdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xyXG4gICAgICByZXR1cm4gd2lkdGggPT0gbnVsbCA/IHRoaXMucngoKSAqIDIgOiB0aGlzLnJ4KG5ldyBTVkcuTnVtYmVyKHdpZHRoKS5kaXZpZGUoMikpXHJcbiAgICB9XHJcbiAgICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcclxuICAsIGhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiBoZWlnaHQgPT0gbnVsbCA/IHRoaXMucnkoKSAqIDIgOiB0aGlzLnJ5KG5ldyBTVkcuTnVtYmVyKGhlaWdodCkuZGl2aWRlKDIpKVxyXG4gICAgfVxyXG4gICAgLy8gQ3VzdG9tIHNpemUgZnVuY3Rpb25cclxuICAsIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgdmFyIHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIC5yeChuZXcgU1ZHLk51bWJlcihwLndpZHRoKS5kaXZpZGUoMikpXHJcbiAgICAgICAgLnJ5KG5ldyBTVkcuTnVtYmVyKHAuaGVpZ2h0KS5kaXZpZGUoMikpXHJcbiAgICB9XHJcbn0pXG5TVkcuTGluZSA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogJ2xpbmUnXHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5TaGFwZVxyXG5cclxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xyXG4sIGV4dGVuZDoge1xyXG4gICAgLy8gR2V0IGFycmF5XHJcbiAgICBhcnJheTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLlBvaW50QXJyYXkoW1xyXG4gICAgICAgIFsgdGhpcy5hdHRyKCd4MScpLCB0aGlzLmF0dHIoJ3kxJykgXVxyXG4gICAgICAsIFsgdGhpcy5hdHRyKCd4MicpLCB0aGlzLmF0dHIoJ3kyJykgXVxyXG4gICAgICBdKVxyXG4gICAgfVxyXG4gICAgLy8gT3ZlcndyaXRlIG5hdGl2ZSBwbG90KCkgbWV0aG9kXHJcbiAgLCBwbG90OiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgICBpZiAoeDEgPT0gbnVsbClcclxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheSgpXHJcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB5MSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgeDEgPSB7IHgxOiB4MSwgeTE6IHkxLCB4MjogeDIsIHkyOiB5MiB9XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB4MSA9IG5ldyBTVkcuUG9pbnRBcnJheSh4MSkudG9MaW5lKClcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoeDEpXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxyXG4gICwgbW92ZTogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKHRoaXMuYXJyYXkoKS5tb3ZlKHgsIHkpLnRvTGluZSgpKVxyXG4gICAgfVxyXG4gICAgLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XHJcbiAgLCBzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgIHZhciBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkudG9MaW5lKCkpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gQ3JlYXRlIGEgbGluZSBlbGVtZW50XHJcbiAgICBsaW5lOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcclxuICAgICAgLy8geDEgaXMgbm90IG5lY2Vzc2FyaWx5IGEgbnVtYmVyLCBpdCBjYW4gYWxzbyBiZSBhbiBhcnJheSwgYSBzdHJpbmcgYW5kIGEgU1ZHLlBvaW50QXJyYXlcclxuICAgICAgcmV0dXJuIFNWRy5MaW5lLnByb3RvdHlwZS5wbG90LmFwcGx5KFxyXG4gICAgICAgIHRoaXMucHV0KG5ldyBTVkcuTGluZSlcclxuICAgICAgLCB4MSAhPSBudWxsID8gW3gxLCB5MSwgeDIsIHkyXSA6IFswLCAwLCAwLCAwXVxyXG4gICAgICApXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cblNWRy5Qb2x5bGluZSA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogJ3BvbHlsaW5lJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuU2hhcGVcclxuXHJcbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcclxuLCBjb25zdHJ1Y3Q6IHtcclxuICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcG9seWxpbmUgZWxlbWVudFxyXG4gICAgcG9seWxpbmU6IGZ1bmN0aW9uKHApIHtcclxuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBvbHlsaW5lKS5wbG90KHAgfHwgbmV3IFNWRy5Qb2ludEFycmF5KVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXHJcblNWRy5Qb2x5Z29uID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiAncG9seWdvbidcclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLlNoYXBlXHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgYSB3cmFwcGVkIHBvbHlnb24gZWxlbWVudFxyXG4gICAgcG9seWdvbjogZnVuY3Rpb24ocCkge1xyXG4gICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuUG9seWdvbikucGxvdChwIHx8IG5ldyBTVkcuUG9pbnRBcnJheSlcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG4vLyBBZGQgcG9seWdvbi1zcGVjaWZpYyBmdW5jdGlvbnNcclxuU1ZHLmV4dGVuZChTVkcuUG9seWxpbmUsIFNWRy5Qb2x5Z29uLCB7XHJcbiAgLy8gR2V0IGFycmF5XHJcbiAgYXJyYXk6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FycmF5IHx8ICh0aGlzLl9hcnJheSA9IG5ldyBTVkcuUG9pbnRBcnJheSh0aGlzLmF0dHIoJ3BvaW50cycpKSlcclxuICB9XHJcbiAgLy8gUGxvdCBuZXcgcGF0aFxyXG4sIHBsb3Q6IGZ1bmN0aW9uKHApIHtcclxuICAgIHJldHVybiAocCA9PSBudWxsKSA/XHJcbiAgICAgIHRoaXMuYXJyYXkoKSA6XHJcbiAgICAgIHRoaXMuY2xlYXIoKS5hdHRyKCdwb2ludHMnLCB0eXBlb2YgcCA9PSAnc3RyaW5nJyA/IHAgOiAodGhpcy5fYXJyYXkgPSBuZXcgU1ZHLlBvaW50QXJyYXkocCkpKVxyXG4gIH1cclxuICAvLyBDbGVhciBhcnJheSBjYWNoZVxyXG4sIGNsZWFyOiBmdW5jdGlvbigpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9hcnJheVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXJcclxuLCBtb3ZlOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdwb2ludHMnLCB0aGlzLmFycmF5KCkubW92ZSh4LCB5KSlcclxuICB9XHJcbiAgLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XHJcbiwgc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgdmFyIHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpXHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigncG9pbnRzJywgdGhpcy5hcnJheSgpLnNpemUocC53aWR0aCwgcC5oZWlnaHQpKVxyXG4gIH1cclxuXHJcbn0pXHJcblxuLy8gdW5pZnkgYWxsIHBvaW50IHRvIHBvaW50IGVsZW1lbnRzXHJcblNWRy5leHRlbmQoU1ZHLkxpbmUsIFNWRy5Qb2x5bGluZSwgU1ZHLlBvbHlnb24sIHtcclxuICAvLyBEZWZpbmUgbW9ycGhhYmxlIGFycmF5XHJcbiAgbW9ycGhBcnJheTogIFNWRy5Qb2ludEFycmF5XHJcbiAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB4LWF4aXNcclxuLCB4OiBmdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZSh4LCB0aGlzLmJib3goKS55KVxyXG4gIH1cclxuICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHktYXhpc1xyXG4sIHk6IGZ1bmN0aW9uKHkpIHtcclxuICAgIHJldHVybiB5ID09IG51bGwgPyB0aGlzLmJib3goKS55IDogdGhpcy5tb3ZlKHRoaXMuYmJveCgpLngsIHkpXHJcbiAgfVxyXG4gIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XHJcbiwgd2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XHJcbiAgICB2YXIgYiA9IHRoaXMuYmJveCgpXHJcblxyXG4gICAgcmV0dXJuIHdpZHRoID09IG51bGwgPyBiLndpZHRoIDogdGhpcy5zaXplKHdpZHRoLCBiLmhlaWdodClcclxuICB9XHJcbiAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XHJcbiwgaGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcclxuICAgIHZhciBiID0gdGhpcy5iYm94KClcclxuXHJcbiAgICByZXR1cm4gaGVpZ2h0ID09IG51bGwgPyBiLmhlaWdodCA6IHRoaXMuc2l6ZShiLndpZHRoLCBoZWlnaHQpXHJcbiAgfVxyXG59KVxuU1ZHLlBhdGggPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICdwYXRoJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuU2hhcGVcclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIERlZmluZSBtb3JwaGFibGUgYXJyYXlcclxuICAgIG1vcnBoQXJyYXk6ICBTVkcuUGF0aEFycmF5XHJcbiAgICAvLyBHZXQgYXJyYXlcclxuICAsIGFycmF5OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2FycmF5IHx8ICh0aGlzLl9hcnJheSA9IG5ldyBTVkcuUGF0aEFycmF5KHRoaXMuYXR0cignZCcpKSlcclxuICAgIH1cclxuICAgIC8vIFBsb3QgbmV3IHBhdGhcclxuICAsIHBsb3Q6IGZ1bmN0aW9uKGQpIHtcclxuICAgICAgcmV0dXJuIChkID09IG51bGwpID9cclxuICAgICAgICB0aGlzLmFycmF5KCkgOlxyXG4gICAgICAgIHRoaXMuY2xlYXIoKS5hdHRyKCdkJywgdHlwZW9mIGQgPT0gJ3N0cmluZycgPyBkIDogKHRoaXMuX2FycmF5ID0gbmV3IFNWRy5QYXRoQXJyYXkoZCkpKVxyXG4gICAgfVxyXG4gICAgLy8gQ2xlYXIgYXJyYXkgY2FjaGVcclxuICAsIGNsZWFyOiBmdW5jdGlvbigpIHtcclxuICAgICAgZGVsZXRlIHRoaXMuX2FycmF5XHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxyXG4gICwgbW92ZTogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdkJywgdGhpcy5hcnJheSgpLm1vdmUoeCwgeSkpXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHgtYXhpc1xyXG4gICwgeDogZnVuY3Rpb24oeCkge1xyXG4gICAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZSh4LCB0aGlzLmJib3goKS55KVxyXG4gICAgfVxyXG4gICAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB5LWF4aXNcclxuICAsIHk6IGZ1bmN0aW9uKHkpIHtcclxuICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLnkgOiB0aGlzLm1vdmUodGhpcy5iYm94KCkueCwgeSlcclxuICAgIH1cclxuICAgIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxyXG4gICwgc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodClcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2QnLCB0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkpXHJcbiAgICB9XHJcbiAgICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxyXG4gICwgd2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XHJcbiAgICAgIHJldHVybiB3aWR0aCA9PSBudWxsID8gdGhpcy5iYm94KCkud2lkdGggOiB0aGlzLnNpemUod2lkdGgsIHRoaXMuYmJveCgpLmhlaWdodClcclxuICAgIH1cclxuICAgIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxyXG4gICwgaGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcclxuICAgICAgcmV0dXJuIGhlaWdodCA9PSBudWxsID8gdGhpcy5iYm94KCkuaGVpZ2h0IDogdGhpcy5zaXplKHRoaXMuYmJveCgpLndpZHRoLCBoZWlnaHQpXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcclxuLCBjb25zdHJ1Y3Q6IHtcclxuICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcGF0aCBlbGVtZW50XHJcbiAgICBwYXRoOiBmdW5jdGlvbihkKSB7XHJcbiAgICAgIC8vIG1ha2Ugc3VyZSBwbG90IGlzIGNhbGxlZCBhcyBhIHNldHRlclxyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5QYXRoKS5wbG90KGQgfHwgbmV3IFNWRy5QYXRoQXJyYXkpXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cblNWRy5JbWFnZSA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogJ2ltYWdlJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuU2hhcGVcclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIChyZSlsb2FkIGltYWdlXHJcbiAgICBsb2FkOiBmdW5jdGlvbih1cmwpIHtcclxuICAgICAgaWYgKCF1cmwpIHJldHVybiB0aGlzXHJcblxyXG4gICAgICB2YXIgc2VsZiA9IHRoaXNcclxuICAgICAgICAsIGltZyAgPSBuZXcgd2luZG93LkltYWdlKClcclxuXHJcbiAgICAgIC8vIHByZWxvYWQgaW1hZ2VcclxuICAgICAgU1ZHLm9uKGltZywgJ2xvYWQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcCA9IHNlbGYucGFyZW50KFNWRy5QYXR0ZXJuKVxyXG5cclxuICAgICAgICBpZihwID09PSBudWxsKSByZXR1cm5cclxuXHJcbiAgICAgICAgLy8gZW5zdXJlIGltYWdlIHNpemVcclxuICAgICAgICBpZiAoc2VsZi53aWR0aCgpID09IDAgJiYgc2VsZi5oZWlnaHQoKSA9PSAwKVxyXG4gICAgICAgICAgc2VsZi5zaXplKGltZy53aWR0aCwgaW1nLmhlaWdodClcclxuXHJcbiAgICAgICAgLy8gZW5zdXJlIHBhdHRlcm4gc2l6ZSBpZiBub3Qgc2V0XHJcbiAgICAgICAgaWYgKHAgJiYgcC53aWR0aCgpID09IDAgJiYgcC5oZWlnaHQoKSA9PSAwKVxyXG4gICAgICAgICAgcC5zaXplKHNlbGYud2lkdGgoKSwgc2VsZi5oZWlnaHQoKSlcclxuXHJcbiAgICAgICAgLy8gY2FsbGJhY2tcclxuICAgICAgICBpZiAodHlwZW9mIHNlbGYuX2xvYWRlZCA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgIHNlbGYuX2xvYWRlZC5jYWxsKHNlbGYsIHtcclxuICAgICAgICAgICAgd2lkdGg6ICBpbWcud2lkdGhcclxuICAgICAgICAgICwgaGVpZ2h0OiBpbWcuaGVpZ2h0XHJcbiAgICAgICAgICAsIHJhdGlvOiAgaW1nLndpZHRoIC8gaW1nLmhlaWdodFxyXG4gICAgICAgICAgLCB1cmw6ICAgIHVybFxyXG4gICAgICAgICAgfSlcclxuICAgICAgfSlcclxuXHJcbiAgICAgIFNWRy5vbihpbWcsICdlcnJvcicsIGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZi5fZXJyb3IgPT09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgICAgICBzZWxmLl9lcnJvci5jYWxsKHNlbGYsIGUpXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsIChpbWcuc3JjID0gdGhpcy5zcmMgPSB1cmwpLCBTVkcueGxpbmspXHJcbiAgICB9XHJcbiAgICAvLyBBZGQgbG9hZGVkIGNhbGxiYWNrXHJcbiAgLCBsb2FkZWQ6IGZ1bmN0aW9uKGxvYWRlZCkge1xyXG4gICAgICB0aGlzLl9sb2FkZWQgPSBsb2FkZWRcclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgLCBlcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcclxuICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvclxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcclxuLCBjb25zdHJ1Y3Q6IHtcclxuICAgIC8vIGNyZWF0ZSBpbWFnZSBlbGVtZW50LCBsb2FkIGltYWdlIGFuZCBzZXQgaXRzIHNpemVcclxuICAgIGltYWdlOiBmdW5jdGlvbihzb3VyY2UsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuSW1hZ2UpLmxvYWQoc291cmNlKS5zaXplKHdpZHRoIHx8IDAsIGhlaWdodCB8fCB3aWR0aCB8fCAwKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pXG5TVkcuVGV4dCA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgndGV4dCcpKVxyXG5cclxuICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHLk51bWJlcigxLjMpICAgIC8vIHN0b3JlIGxlYWRpbmcgdmFsdWUgZm9yIHJlYnVpbGRpbmdcclxuICAgIHRoaXMuX3JlYnVpbGQgPSB0cnVlICAgICAgICAgICAgICAgICAgICAgIC8vIGVuYWJsZSBhdXRvbWF0aWMgdXBkYXRpbmcgb2YgZHkgdmFsdWVzXHJcbiAgICB0aGlzLl9idWlsZCAgID0gZmFsc2UgICAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIGJ1aWxkIG1vZGUgZm9yIGFkZGluZyBtdWx0aXBsZSBsaW5lc1xyXG5cclxuICAgIC8vIHNldCBkZWZhdWx0IGZvbnRcclxuICAgIHRoaXMuYXR0cignZm9udC1mYW1pbHknLCBTVkcuZGVmYXVsdHMuYXR0cnNbJ2ZvbnQtZmFtaWx5J10pXHJcbiAgfVxyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuU2hhcGVcclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIE1vdmUgb3ZlciB4LWF4aXNcclxuICAgIHg6IGZ1bmN0aW9uKHgpIHtcclxuICAgICAgLy8gYWN0IGFzIGdldHRlclxyXG4gICAgICBpZiAoeCA9PSBudWxsKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHgpXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIG92ZXIgeS1heGlzXHJcbiAgLCB5OiBmdW5jdGlvbih5KSB7XHJcbiAgICAgIHZhciBveSA9IHRoaXMuYXR0cigneScpXHJcbiAgICAgICAgLCBvICA9IHR5cGVvZiBveSA9PT0gJ251bWJlcicgPyBveSAtIHRoaXMuYmJveCgpLnkgOiAwXHJcblxyXG4gICAgICAvLyBhY3QgYXMgZ2V0dGVyXHJcbiAgICAgIGlmICh5ID09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBveSA9PT0gJ251bWJlcicgPyBveSAtIG8gOiBveVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cigneScsIHR5cGVvZiB5ID09PSAnbnVtYmVyJyA/IHkgKyBvIDogeSlcclxuICAgIH1cclxuICAgIC8vIE1vdmUgY2VudGVyIG92ZXIgeC1heGlzXHJcbiAgLCBjeDogZnVuY3Rpb24oeCkge1xyXG4gICAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5iYm94KCkuY3ggOiB0aGlzLngoeCAtIHRoaXMuYmJveCgpLndpZHRoIC8gMilcclxuICAgIH1cclxuICAgIC8vIE1vdmUgY2VudGVyIG92ZXIgeS1heGlzXHJcbiAgLCBjeTogZnVuY3Rpb24oeSkge1xyXG4gICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5iYm94KCkuY3kgOiB0aGlzLnkoeSAtIHRoaXMuYmJveCgpLmhlaWdodCAvIDIpXHJcbiAgICB9XHJcbiAgICAvLyBTZXQgdGhlIHRleHQgY29udGVudFxyXG4gICwgdGV4dDogZnVuY3Rpb24odGV4dCkge1xyXG4gICAgICAvLyBhY3QgYXMgZ2V0dGVyXHJcbiAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgIHZhciB0ZXh0ID0gJydcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm5vZGUuY2hpbGROb2Rlc1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgKytpKXtcclxuXHJcbiAgICAgICAgICAvLyBhZGQgbmV3bGluZSBpZiBpdHMgbm90IHRoZSBmaXJzdCBjaGlsZCBhbmQgbmV3TGluZWQgaXMgc2V0IHRvIHRydWVcclxuICAgICAgICAgIGlmKGkgIT0gMCAmJiBjaGlsZHJlbltpXS5ub2RlVHlwZSAhPSAzICYmIFNWRy5hZG9wdChjaGlsZHJlbltpXSkuZG9tLm5ld0xpbmVkID09IHRydWUpe1xyXG4gICAgICAgICAgICB0ZXh0ICs9ICdcXG4nXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gYWRkIGNvbnRlbnQgb2YgdGhpcyBub2RlXHJcbiAgICAgICAgICB0ZXh0ICs9IGNoaWxkcmVuW2ldLnRleHRDb250ZW50XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dFxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZW1vdmUgZXhpc3RpbmcgY29udGVudFxyXG4gICAgICB0aGlzLmNsZWFyKCkuYnVpbGQodHJ1ZSlcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIGNhbGwgYmxvY2tcclxuICAgICAgICB0ZXh0LmNhbGwodGhpcywgdGhpcylcclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gc3RvcmUgdGV4dCBhbmQgbWFrZSBzdXJlIHRleHQgaXMgbm90IGJsYW5rXHJcbiAgICAgICAgdGV4dCA9IHRleHQuc3BsaXQoJ1xcbicpXHJcblxyXG4gICAgICAgIC8vIGJ1aWxkIG5ldyBsaW5lc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRleHQubGVuZ3RoOyBpIDwgaWw7IGkrKylcclxuICAgICAgICAgIHRoaXMudHNwYW4odGV4dFtpXSkubmV3TGluZSgpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGRpc2FibGUgYnVpbGQgbW9kZSBhbmQgcmVidWlsZCBsaW5lc1xyXG4gICAgICByZXR1cm4gdGhpcy5idWlsZChmYWxzZSkucmVidWlsZCgpXHJcbiAgICB9XHJcbiAgICAvLyBTZXQgZm9udCBzaXplXHJcbiAgLCBzaXplOiBmdW5jdGlvbihzaXplKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2ZvbnQtc2l6ZScsIHNpemUpLnJlYnVpbGQoKVxyXG4gICAgfVxyXG4gICAgLy8gU2V0IC8gZ2V0IGxlYWRpbmdcclxuICAsIGxlYWRpbmc6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIC8vIGFjdCBhcyBnZXR0ZXJcclxuICAgICAgaWYgKHZhbHVlID09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tLmxlYWRpbmdcclxuXHJcbiAgICAgIC8vIGFjdCBhcyBzZXR0ZXJcclxuICAgICAgdGhpcy5kb20ubGVhZGluZyA9IG5ldyBTVkcuTnVtYmVyKHZhbHVlKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMucmVidWlsZCgpXHJcbiAgICB9XHJcbiAgICAvLyBHZXQgYWxsIHRoZSBmaXJzdCBsZXZlbCBsaW5lc1xyXG4gICwgbGluZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgbm9kZSA9ICh0aGlzLnRleHRQYXRoICYmIHRoaXMudGV4dFBhdGgoKSB8fCB0aGlzKS5ub2RlXHJcblxyXG4gICAgICAvLyBmaWx0ZXIgdHNwYW5zIGFuZCBtYXAgdGhlbSB0byBTVkcuanMgaW5zdGFuY2VzXHJcbiAgICAgIHZhciBsaW5lcyA9IFNWRy51dGlscy5tYXAoU1ZHLnV0aWxzLmZpbHRlclNWR0VsZW1lbnRzKG5vZGUuY2hpbGROb2RlcyksIGZ1bmN0aW9uKGVsKXtcclxuICAgICAgICByZXR1cm4gU1ZHLmFkb3B0KGVsKVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgLy8gcmV0dXJuIGFuIGluc3RhbmNlIG9mIFNWRy5zZXRcclxuICAgICAgcmV0dXJuIG5ldyBTVkcuU2V0KGxpbmVzKVxyXG4gICAgfVxyXG4gICAgLy8gUmVidWlsZCBhcHBlYXJhbmNlIHR5cGVcclxuICAsIHJlYnVpbGQ6IGZ1bmN0aW9uKHJlYnVpbGQpIHtcclxuICAgICAgLy8gc3RvcmUgbmV3IHJlYnVpbGQgZmxhZyBpZiBnaXZlblxyXG4gICAgICBpZiAodHlwZW9mIHJlYnVpbGQgPT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgIHRoaXMuX3JlYnVpbGQgPSByZWJ1aWxkXHJcblxyXG4gICAgICAvLyBkZWZpbmUgcG9zaXRpb24gb2YgYWxsIGxpbmVzXHJcbiAgICAgIGlmICh0aGlzLl9yZWJ1aWxkKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgICAgICAsIGJsYW5rTGluZU9mZnNldCA9IDBcclxuICAgICAgICAgICwgZHkgPSB0aGlzLmRvbS5sZWFkaW5nICogbmV3IFNWRy5OdW1iZXIodGhpcy5hdHRyKCdmb250LXNpemUnKSlcclxuXHJcbiAgICAgICAgdGhpcy5saW5lcygpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5kb20ubmV3TGluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFzZWxmLnRleHRQYXRoKCkpXHJcbiAgICAgICAgICAgICAgdGhpcy5hdHRyKCd4Jywgc2VsZi5hdHRyKCd4JykpXHJcbiAgICAgICAgICAgIGlmKHRoaXMudGV4dCgpID09ICdcXG4nKSB7XHJcbiAgICAgICAgICAgICAgYmxhbmtMaW5lT2Zmc2V0ICs9IGR5XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgIHRoaXMuYXR0cignZHknLCBkeSArIGJsYW5rTGluZU9mZnNldClcclxuICAgICAgICAgICAgICBibGFua0xpbmVPZmZzZXQgPSAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICB0aGlzLmZpcmUoJ3JlYnVpbGQnKVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICAgLy8gRW5hYmxlIC8gZGlzYWJsZSBidWlsZCBtb2RlXHJcbiAgLCBidWlsZDogZnVuY3Rpb24oYnVpbGQpIHtcclxuICAgICAgdGhpcy5fYnVpbGQgPSAhIWJ1aWxkXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBvdmVyd3JpdGUgbWV0aG9kIGZyb20gcGFyZW50IHRvIHNldCBkYXRhIHByb3Blcmx5XHJcbiAgLCBzZXREYXRhOiBmdW5jdGlvbihvKXtcclxuICAgICAgdGhpcy5kb20gPSBvXHJcbiAgICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHLk51bWJlcihvLmxlYWRpbmcgfHwgMS4zKVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcclxuLCBjb25zdHJ1Y3Q6IHtcclxuICAgIC8vIENyZWF0ZSB0ZXh0IGVsZW1lbnRcclxuICAgIHRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuVGV4dCkudGV4dCh0ZXh0KVxyXG4gICAgfVxyXG4gICAgLy8gQ3JlYXRlIHBsYWluIHRleHQgZWxlbWVudFxyXG4gICwgcGxhaW46IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuVGV4dCkucGxhaW4odGV4dClcclxuICAgIH1cclxuICB9XHJcblxyXG59KVxyXG5cclxuU1ZHLlRzcGFuID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiAndHNwYW4nXHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5TaGFwZVxyXG5cclxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xyXG4sIGV4dGVuZDoge1xyXG4gICAgLy8gU2V0IHRleHQgY29udGVudFxyXG4gICAgdGV4dDogZnVuY3Rpb24odGV4dCkge1xyXG4gICAgICBpZih0ZXh0ID09IG51bGwpIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQgKyAodGhpcy5kb20ubmV3TGluZWQgPyAnXFxuJyA6ICcnKVxyXG5cclxuICAgICAgdHlwZW9mIHRleHQgPT09ICdmdW5jdGlvbicgPyB0ZXh0LmNhbGwodGhpcywgdGhpcykgOiB0aGlzLnBsYWluKHRleHQpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICAgLy8gU2hvcnRjdXQgZHhcclxuICAsIGR4OiBmdW5jdGlvbihkeCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdkeCcsIGR4KVxyXG4gICAgfVxyXG4gICAgLy8gU2hvcnRjdXQgZHlcclxuICAsIGR5OiBmdW5jdGlvbihkeSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdkeScsIGR5KVxyXG4gICAgfVxyXG4gICAgLy8gQ3JlYXRlIG5ldyBsaW5lXHJcbiAgLCBuZXdMaW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gZmV0Y2ggdGV4dCBwYXJlbnRcclxuICAgICAgdmFyIHQgPSB0aGlzLnBhcmVudChTVkcuVGV4dClcclxuXHJcbiAgICAgIC8vIG1hcmsgbmV3IGxpbmVcclxuICAgICAgdGhpcy5kb20ubmV3TGluZWQgPSB0cnVlXHJcblxyXG4gICAgICAvLyBhcHBseSBuZXcgaHnCoW5cclxuICAgICAgcmV0dXJuIHRoaXMuZHkodC5kb20ubGVhZGluZyAqIHQuYXR0cignZm9udC1zaXplJykpLmF0dHIoJ3gnLCB0LngoKSlcclxuICAgIH1cclxuICB9XHJcblxyXG59KVxyXG5cclxuU1ZHLmV4dGVuZChTVkcuVGV4dCwgU1ZHLlRzcGFuLCB7XHJcbiAgLy8gQ3JlYXRlIHBsYWluIHRleHQgbm9kZVxyXG4gIHBsYWluOiBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAvLyBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkXHJcbiAgICBpZiAodGhpcy5fYnVpbGQgPT09IGZhbHNlKVxyXG4gICAgICB0aGlzLmNsZWFyKClcclxuXHJcbiAgICAvLyBjcmVhdGUgdGV4dCBub2RlXHJcbiAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgLy8gQ3JlYXRlIGEgdHNwYW5cclxuLCB0c3BhbjogZnVuY3Rpb24odGV4dCkge1xyXG4gICAgdmFyIG5vZGUgID0gKHRoaXMudGV4dFBhdGggJiYgdGhpcy50ZXh0UGF0aCgpIHx8IHRoaXMpLm5vZGVcclxuICAgICAgLCB0c3BhbiA9IG5ldyBTVkcuVHNwYW5cclxuXHJcbiAgICAvLyBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkXHJcbiAgICBpZiAodGhpcy5fYnVpbGQgPT09IGZhbHNlKVxyXG4gICAgICB0aGlzLmNsZWFyKClcclxuXHJcbiAgICAvLyBhZGQgbmV3IHRzcGFuXHJcbiAgICBub2RlLmFwcGVuZENoaWxkKHRzcGFuLm5vZGUpXHJcblxyXG4gICAgcmV0dXJuIHRzcGFuLnRleHQodGV4dClcclxuICB9XHJcbiAgLy8gQ2xlYXIgYWxsIGxpbmVzXHJcbiwgY2xlYXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG5vZGUgPSAodGhpcy50ZXh0UGF0aCAmJiB0aGlzLnRleHRQYXRoKCkgfHwgdGhpcykubm9kZVxyXG5cclxuICAgIC8vIHJlbW92ZSBleGlzdGluZyBjaGlsZCBub2Rlc1xyXG4gICAgd2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKVxyXG4gICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIEdldCBsZW5ndGggb2YgdGV4dCBlbGVtZW50XHJcbiwgbGVuZ3RoOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKClcclxuICB9XHJcbn0pXHJcblxuU1ZHLlRleHRQYXRoID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiAndGV4dFBhdGgnXHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5QYXJlbnRcclxuXHJcbiAgLy8gRGVmaW5lIHBhcmVudCBjbGFzc1xyXG4sIHBhcmVudDogU1ZHLlRleHRcclxuXHJcbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcclxuLCBjb25zdHJ1Y3Q6IHtcclxuICAgIG1vcnBoQXJyYXk6IFNWRy5QYXRoQXJyYXlcclxuICAgIC8vIENyZWF0ZSBwYXRoIGZvciB0ZXh0IHRvIHJ1biBvblxyXG4gICwgcGF0aDogZnVuY3Rpb24oZCkge1xyXG4gICAgICAvLyBjcmVhdGUgdGV4dFBhdGggZWxlbWVudFxyXG4gICAgICB2YXIgcGF0aCAgPSBuZXcgU1ZHLlRleHRQYXRoXHJcbiAgICAgICAgLCB0cmFjayA9IHRoaXMuZG9jKCkuZGVmcygpLnBhdGgoZClcclxuXHJcbiAgICAgIC8vIG1vdmUgbGluZXMgdG8gdGV4dHBhdGhcclxuICAgICAgd2hpbGUgKHRoaXMubm9kZS5oYXNDaGlsZE5vZGVzKCkpXHJcbiAgICAgICAgcGF0aC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZS5maXJzdENoaWxkKVxyXG5cclxuICAgICAgLy8gYWRkIHRleHRQYXRoIGVsZW1lbnQgYXMgY2hpbGQgbm9kZVxyXG4gICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQocGF0aC5ub2RlKVxyXG5cclxuICAgICAgLy8gbGluayB0ZXh0UGF0aCB0byBwYXRoIGFuZCBhZGQgY29udGVudFxyXG4gICAgICBwYXRoLmF0dHIoJ2hyZWYnLCAnIycgKyB0cmFjaywgU1ZHLnhsaW5rKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIHJldHVybiB0aGUgYXJyYXkgb2YgdGhlIHBhdGggdHJhY2sgZWxlbWVudFxyXG4gICwgYXJyYXk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrKClcclxuXHJcbiAgICAgIHJldHVybiB0cmFjayA/IHRyYWNrLmFycmF5KCkgOiBudWxsXHJcbiAgICB9XHJcbiAgICAvLyBQbG90IHBhdGggaWYgYW55XHJcbiAgLCBwbG90OiBmdW5jdGlvbihkKSB7XHJcbiAgICAgIHZhciB0cmFjayA9IHRoaXMudHJhY2soKVxyXG4gICAgICAgICwgcGF0aEFycmF5ID0gbnVsbFxyXG5cclxuICAgICAgaWYgKHRyYWNrKSB7XHJcbiAgICAgICAgcGF0aEFycmF5ID0gdHJhY2sucGxvdChkKVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKGQgPT0gbnVsbCkgPyBwYXRoQXJyYXkgOiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBHZXQgdGhlIHBhdGggdHJhY2sgZWxlbWVudFxyXG4gICwgdHJhY2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgcGF0aCA9IHRoaXMudGV4dFBhdGgoKVxyXG5cclxuICAgICAgaWYgKHBhdGgpXHJcbiAgICAgICAgcmV0dXJuIHBhdGgucmVmZXJlbmNlKCdocmVmJylcclxuICAgIH1cclxuICAgIC8vIEdldCB0aGUgdGV4dFBhdGggY2hpbGRcclxuICAsIHRleHRQYXRoOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMubm9kZS5maXJzdENoaWxkICYmIHRoaXMubm9kZS5maXJzdENoaWxkLm5vZGVOYW1lID09ICd0ZXh0UGF0aCcpXHJcbiAgICAgICAgcmV0dXJuIFNWRy5hZG9wdCh0aGlzLm5vZGUuZmlyc3RDaGlsZClcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxuU1ZHLk5lc3RlZCA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnc3ZnJykpXHJcblxyXG4gICAgdGhpcy5zdHlsZSgnb3ZlcmZsb3cnLCAndmlzaWJsZScpXHJcbiAgfVxyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgbmVzdGVkIHN2ZyBkb2N1bWVudFxyXG4gICAgbmVzdGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuTmVzdGVkKVxyXG4gICAgfVxyXG4gIH1cclxufSlcblNWRy5BID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiAnYSdcclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLkNvbnRhaW5lclxyXG5cclxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xyXG4sIGV4dGVuZDoge1xyXG4gICAgLy8gTGluayB1cmxcclxuICAgIHRvOiBmdW5jdGlvbih1cmwpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsIHVybCwgU1ZHLnhsaW5rKVxyXG4gICAgfVxyXG4gICAgLy8gTGluayBzaG93IGF0dHJpYnV0ZVxyXG4gICwgc2hvdzogZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3Nob3cnLCB0YXJnZXQsIFNWRy54bGluaylcclxuICAgIH1cclxuICAgIC8vIExpbmsgdGFyZ2V0IGF0dHJpYnV0ZVxyXG4gICwgdGFyZ2V0OiBmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cigndGFyZ2V0JywgdGFyZ2V0KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcclxuLCBjb25zdHJ1Y3Q6IHtcclxuICAgIC8vIENyZWF0ZSBhIGh5cGVybGluayBlbGVtZW50XHJcbiAgICBsaW5rOiBmdW5jdGlvbih1cmwpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQSkudG8odXJsKVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXHJcblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAvLyBDcmVhdGUgYSBoeXBlcmxpbmsgZWxlbWVudFxyXG4gIGxpbmtUbzogZnVuY3Rpb24odXJsKSB7XHJcbiAgICB2YXIgbGluayA9IG5ldyBTVkcuQVxyXG5cclxuICAgIGlmICh0eXBlb2YgdXJsID09ICdmdW5jdGlvbicpXHJcbiAgICAgIHVybC5jYWxsKGxpbmssIGxpbmspXHJcbiAgICBlbHNlXHJcbiAgICAgIGxpbmsudG8odXJsKVxyXG5cclxuICAgIHJldHVybiB0aGlzLnBhcmVudCgpLnB1dChsaW5rKS5wdXQodGhpcylcclxuICB9XHJcblxyXG59KVxuU1ZHLk1hcmtlciA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogJ21hcmtlcidcclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLkNvbnRhaW5lclxyXG5cclxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xyXG4sIGV4dGVuZDoge1xyXG4gICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcclxuICAgIHdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXJrZXJXaWR0aCcsIHdpZHRoKVxyXG4gICAgfVxyXG4gICAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XHJcbiAgLCBoZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXJrZXJIZWlnaHQnLCBoZWlnaHQpXHJcbiAgICB9XHJcbiAgICAvLyBTZXQgbWFya2VyIHJlZlggYW5kIHJlZllcclxuICAsIHJlZjogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdyZWZYJywgeCkuYXR0cigncmVmWScsIHkpXHJcbiAgICB9XHJcbiAgICAvLyBVcGRhdGUgbWFya2VyXHJcbiAgLCB1cGRhdGU6IGZ1bmN0aW9uKGJsb2NrKSB7XHJcbiAgICAgIC8vIHJlbW92ZSBhbGwgY29udGVudFxyXG4gICAgICB0aGlzLmNsZWFyKClcclxuXHJcbiAgICAgIC8vIGludm9rZSBwYXNzZWQgYmxvY2tcclxuICAgICAgaWYgKHR5cGVvZiBibG9jayA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIGJsb2NrLmNhbGwodGhpcywgdGhpcylcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcclxuICAsIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuICd1cmwoIycgKyB0aGlzLmlkKCkgKyAnKSdcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICBtYXJrZXI6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XHJcbiAgICAgIC8vIENyZWF0ZSBtYXJrZXIgZWxlbWVudCBpbiBkZWZzXHJcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5tYXJrZXIod2lkdGgsIGhlaWdodCwgYmxvY2spXHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSlcclxuXHJcblNWRy5leHRlbmQoU1ZHLkRlZnMsIHtcclxuICAvLyBDcmVhdGUgbWFya2VyXHJcbiAgbWFya2VyOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xyXG4gICAgLy8gU2V0IGRlZmF1bHQgdmlld2JveCB0byBtYXRjaCB0aGUgd2lkdGggYW5kIGhlaWdodCwgc2V0IHJlZiB0byBjeCBhbmQgY3kgYW5kIHNldCBvcmllbnQgdG8gYXV0b1xyXG4gICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuTWFya2VyKVxyXG4gICAgICAuc2l6ZSh3aWR0aCwgaGVpZ2h0KVxyXG4gICAgICAucmVmKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMilcclxuICAgICAgLnZpZXdib3goMCwgMCwgd2lkdGgsIGhlaWdodClcclxuICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcclxuICAgICAgLnVwZGF0ZShibG9jaylcclxuICB9XHJcblxyXG59KVxyXG5cclxuU1ZHLmV4dGVuZChTVkcuTGluZSwgU1ZHLlBvbHlsaW5lLCBTVkcuUG9seWdvbiwgU1ZHLlBhdGgsIHtcclxuICAvLyBDcmVhdGUgYW5kIGF0dGFjaCBtYXJrZXJzXHJcbiAgbWFya2VyOiBmdW5jdGlvbihtYXJrZXIsIHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XHJcbiAgICB2YXIgYXR0ciA9IFsnbWFya2VyJ11cclxuXHJcbiAgICAvLyBCdWlsZCBhdHRyaWJ1dGUgbmFtZVxyXG4gICAgaWYgKG1hcmtlciAhPSAnYWxsJykgYXR0ci5wdXNoKG1hcmtlcilcclxuICAgIGF0dHIgPSBhdHRyLmpvaW4oJy0nKVxyXG5cclxuICAgIC8vIFNldCBtYXJrZXIgYXR0cmlidXRlXHJcbiAgICBtYXJrZXIgPSBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBTVkcuTWFya2VyID9cclxuICAgICAgYXJndW1lbnRzWzFdIDpcclxuICAgICAgdGhpcy5kb2MoKS5tYXJrZXIod2lkdGgsIGhlaWdodCwgYmxvY2spXHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYXR0cihhdHRyLCBtYXJrZXIpXHJcbiAgfVxyXG5cclxufSlcbi8vIERlZmluZSBsaXN0IG9mIGF2YWlsYWJsZSBhdHRyaWJ1dGVzIGZvciBzdHJva2UgYW5kIGZpbGxcclxudmFyIHN1Z2FyID0ge1xyXG4gIHN0cm9rZTogWydjb2xvcicsICd3aWR0aCcsICdvcGFjaXR5JywgJ2xpbmVjYXAnLCAnbGluZWpvaW4nLCAnbWl0ZXJsaW1pdCcsICdkYXNoYXJyYXknLCAnZGFzaG9mZnNldCddXHJcbiwgZmlsbDogICBbJ2NvbG9yJywgJ29wYWNpdHknLCAncnVsZSddXHJcbiwgcHJlZml4OiBmdW5jdGlvbih0LCBhKSB7XHJcbiAgICByZXR1cm4gYSA9PSAnY29sb3InID8gdCA6IHQgKyAnLScgKyBhXHJcbiAgfVxyXG59XHJcblxyXG4vLyBBZGQgc3VnYXIgZm9yIGZpbGwgYW5kIHN0cm9rZVxyXG47WydmaWxsJywgJ3N0cm9rZSddLmZvckVhY2goZnVuY3Rpb24obSkge1xyXG4gIHZhciBpLCBleHRlbnNpb24gPSB7fVxyXG5cclxuICBleHRlbnNpb25bbV0gPSBmdW5jdGlvbihvKSB7XHJcbiAgICBpZiAodHlwZW9mIG8gPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICBpZiAodHlwZW9mIG8gPT0gJ3N0cmluZycgfHwgU1ZHLkNvbG9yLmlzUmdiKG8pIHx8IChvICYmIHR5cGVvZiBvLmZpbGwgPT09ICdmdW5jdGlvbicpKVxyXG4gICAgICB0aGlzLmF0dHIobSwgbylcclxuXHJcbiAgICBlbHNlXHJcbiAgICAgIC8vIHNldCBhbGwgYXR0cmlidXRlcyBmcm9tIHN1Z2FyLmZpbGwgYW5kIHN1Z2FyLnN0cm9rZSBsaXN0XHJcbiAgICAgIGZvciAoaSA9IHN1Z2FyW21dLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgIGlmIChvW3N1Z2FyW21dW2ldXSAhPSBudWxsKVxyXG4gICAgICAgICAgdGhpcy5hdHRyKHN1Z2FyLnByZWZpeChtLCBzdWdhclttXVtpXSksIG9bc3VnYXJbbV1baV1dKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCBTVkcuRlgsIGV4dGVuc2lvbilcclxuXHJcbn0pXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCBTVkcuRlgsIHtcclxuICAvLyBNYXAgcm90YXRpb24gdG8gdHJhbnNmb3JtXHJcbiAgcm90YXRlOiBmdW5jdGlvbihkLCBjeCwgY3kpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7IHJvdGF0aW9uOiBkLCBjeDogY3gsIGN5OiBjeSB9KVxyXG4gIH1cclxuICAvLyBNYXAgc2tldyB0byB0cmFuc2Zvcm1cclxuLCBza2V3OiBmdW5jdGlvbih4LCB5LCBjeCwgY3kpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09IDEgIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gMyA/XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtKHsgc2tldzogeCwgY3g6IHksIGN5OiBjeCB9KSA6XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtKHsgc2tld1g6IHgsIHNrZXdZOiB5LCBjeDogY3gsIGN5OiBjeSB9KVxyXG4gIH1cclxuICAvLyBNYXAgc2NhbGUgdG8gdHJhbnNmb3JtXHJcbiwgc2NhbGU6IGZ1bmN0aW9uKHgsIHksIGN4LCBjeSkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT0gMSAgfHwgYXJndW1lbnRzLmxlbmd0aCA9PSAzID9cclxuICAgICAgdGhpcy50cmFuc2Zvcm0oeyBzY2FsZTogeCwgY3g6IHksIGN5OiBjeCB9KSA6XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtKHsgc2NhbGVYOiB4LCBzY2FsZVk6IHksIGN4OiBjeCwgY3k6IGN5IH0pXHJcbiAgfVxyXG4gIC8vIE1hcCB0cmFuc2xhdGUgdG8gdHJhbnNmb3JtXHJcbiwgdHJhbnNsYXRlOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oeyB4OiB4LCB5OiB5IH0pXHJcbiAgfVxyXG4gIC8vIE1hcCBmbGlwIHRvIHRyYW5zZm9ybVxyXG4sIGZsaXA6IGZ1bmN0aW9uKGEsIG8pIHtcclxuICAgIG8gPSB0eXBlb2YgYSA9PSAnbnVtYmVyJyA/IGEgOiBvXHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oeyBmbGlwOiBhIHx8ICdib3RoJywgb2Zmc2V0OiBvIH0pXHJcbiAgfVxyXG4gIC8vIE1hcCBtYXRyaXggdG8gdHJhbnNmb3JtXHJcbiwgbWF0cml4OiBmdW5jdGlvbihtKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCBuZXcgU1ZHLk1hdHJpeChhcmd1bWVudHMubGVuZ3RoID09IDYgPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykgOiBtKSlcclxuICB9XHJcbiAgLy8gT3BhY2l0eVxyXG4sIG9wYWNpdHk6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdvcGFjaXR5JywgdmFsdWUpXHJcbiAgfVxyXG4gIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGF4aXNcclxuLCBkeDogZnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIHRoaXMueChuZXcgU1ZHLk51bWJlcih4KS5wbHVzKHRoaXMgaW5zdGFuY2VvZiBTVkcuRlggPyAwIDogdGhpcy54KCkpLCB0cnVlKVxyXG4gIH1cclxuICAvLyBSZWxhdGl2ZSBtb3ZlIG92ZXIgeSBheGlzXHJcbiwgZHk6IGZ1bmN0aW9uKHkpIHtcclxuICAgIHJldHVybiB0aGlzLnkobmV3IFNWRy5OdW1iZXIoeSkucGx1cyh0aGlzIGluc3RhbmNlb2YgU1ZHLkZYID8gMCA6IHRoaXMueSgpKSwgdHJ1ZSlcclxuICB9XHJcbiAgLy8gUmVsYXRpdmUgbW92ZSBvdmVyIHggYW5kIHkgYXhlc1xyXG4sIGRtb3ZlOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5keCh4KS5keSh5KVxyXG4gIH1cclxufSlcclxuXHJcblNWRy5leHRlbmQoU1ZHLlJlY3QsIFNWRy5FbGxpcHNlLCBTVkcuQ2lyY2xlLCBTVkcuR3JhZGllbnQsIFNWRy5GWCwge1xyXG4gIC8vIEFkZCB4IGFuZCB5IHJhZGl1c1xyXG4gIHJhZGl1czogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdmFyIHR5cGUgPSAodGhpcy5fdGFyZ2V0IHx8IHRoaXMpLnR5cGU7XHJcbiAgICByZXR1cm4gdHlwZSA9PSAncmFkaWFsJyB8fCB0eXBlID09ICdjaXJjbGUnID9cclxuICAgICAgdGhpcy5hdHRyKCdyJywgbmV3IFNWRy5OdW1iZXIoeCkpIDpcclxuICAgICAgdGhpcy5yeCh4KS5yeSh5ID09IG51bGwgPyB4IDogeSlcclxuICB9XHJcbn0pXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5QYXRoLCB7XHJcbiAgLy8gR2V0IHBhdGggbGVuZ3RoXHJcbiAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0VG90YWxMZW5ndGgoKVxyXG4gIH1cclxuICAvLyBHZXQgcG9pbnQgYXQgbGVuZ3RoXHJcbiwgcG9pbnRBdDogZnVuY3Rpb24obGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ub2RlLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoKVxyXG4gIH1cclxufSlcclxuXHJcblNWRy5leHRlbmQoU1ZHLlBhcmVudCwgU1ZHLlRleHQsIFNWRy5Uc3BhbiwgU1ZHLkZYLCB7XHJcbiAgLy8gU2V0IGZvbnRcclxuICBmb250OiBmdW5jdGlvbihhLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIGEgPT0gJ29iamVjdCcpIHtcclxuICAgICAgZm9yICh2IGluIGEpIHRoaXMuZm9udCh2LCBhW3ZdKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhID09ICdsZWFkaW5nJyA/XHJcbiAgICAgICAgdGhpcy5sZWFkaW5nKHYpIDpcclxuICAgICAgYSA9PSAnYW5jaG9yJyA/XHJcbiAgICAgICAgdGhpcy5hdHRyKCd0ZXh0LWFuY2hvcicsIHYpIDpcclxuICAgICAgYSA9PSAnc2l6ZScgfHwgYSA9PSAnZmFtaWx5JyB8fCBhID09ICd3ZWlnaHQnIHx8IGEgPT0gJ3N0cmV0Y2gnIHx8IGEgPT0gJ3ZhcmlhbnQnIHx8IGEgPT0gJ3N0eWxlJyA/XHJcbiAgICAgICAgdGhpcy5hdHRyKCdmb250LScrIGEsIHYpIDpcclxuICAgICAgICB0aGlzLmF0dHIoYSwgdilcclxuICB9XHJcbn0pXHJcblxuU1ZHLlNldCA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKG1lbWJlcnMpIHtcclxuICAgIC8vIFNldCBpbml0aWFsIHN0YXRlXHJcbiAgICBBcnJheS5pc0FycmF5KG1lbWJlcnMpID8gdGhpcy5tZW1iZXJzID0gbWVtYmVycyA6IHRoaXMuY2xlYXIoKVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIEFkZCBlbGVtZW50IHRvIHNldFxyXG4gICAgYWRkOiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGksIGlsLCBlbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxyXG5cclxuICAgICAgZm9yIChpID0gMCwgaWwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIHRoaXMubWVtYmVycy5wdXNoKGVsZW1lbnRzW2ldKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIFJlbW92ZSBlbGVtZW50IGZyb20gc2V0XHJcbiAgLCByZW1vdmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgdmFyIGkgPSB0aGlzLmluZGV4KGVsZW1lbnQpXHJcblxyXG4gICAgICAvLyByZW1vdmUgZ2l2ZW4gY2hpbGRcclxuICAgICAgaWYgKGkgPiAtMSlcclxuICAgICAgICB0aGlzLm1lbWJlcnMuc3BsaWNlKGksIDEpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBtZW1iZXJzXHJcbiAgLCBlYWNoOiBmdW5jdGlvbihibG9jaykge1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBibG9jay5hcHBseSh0aGlzLm1lbWJlcnNbaV0sIFtpLCB0aGlzLm1lbWJlcnNdKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIFJlc3RvcmUgdG8gZGVmYXVsdHNcclxuICAsIGNsZWFyOiBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gaW5pdGlhbGl6ZSBzdG9yZVxyXG4gICAgICB0aGlzLm1lbWJlcnMgPSBbXVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIGEgc2V0XHJcbiAgLCBsZW5ndGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tZW1iZXJzLmxlbmd0aFxyXG4gICAgfVxyXG4gICAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gZWxlbWVudCBpcyBwcmVzZW50IGluIHNldFxyXG4gICwgaGFzOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluZGV4KGVsZW1lbnQpID49IDBcclxuICAgIH1cclxuICAgIC8vIHJldHVucyBpbmRleCBvZiBnaXZlbiBlbGVtZW50IGluIHNldFxyXG4gICwgaW5kZXg6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubWVtYmVycy5pbmRleE9mKGVsZW1lbnQpXHJcbiAgICB9XHJcbiAgICAvLyBHZXQgbWVtYmVyIGF0IGdpdmVuIGluZGV4XHJcbiAgLCBnZXQ6IGZ1bmN0aW9uKGkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubWVtYmVyc1tpXVxyXG4gICAgfVxyXG4gICAgLy8gR2V0IGZpcnN0IG1lbWJlclxyXG4gICwgZmlyc3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXQoMClcclxuICAgIH1cclxuICAgIC8vIEdldCBsYXN0IG1lbWJlclxyXG4gICwgbGFzdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLm1lbWJlcnMubGVuZ3RoIC0gMSlcclxuICAgIH1cclxuICAgIC8vIERlZmF1bHQgdmFsdWVcclxuICAsIHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tZW1iZXJzXHJcbiAgICB9XHJcbiAgICAvLyBHZXQgdGhlIGJvdW5kaW5nIGJveCBvZiBhbGwgbWVtYmVycyBpbmNsdWRlZCBvciBlbXB0eSBib3ggaWYgc2V0IGhhcyBubyBpdGVtc1xyXG4gICwgYmJveDogZnVuY3Rpb24oKXtcclxuICAgICAgLy8gcmV0dXJuIGFuIGVtcHR5IGJveCBvZiB0aGVyZSBhcmUgbm8gbWVtYmVyc1xyXG4gICAgICBpZiAodGhpcy5tZW1iZXJzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHJldHVybiBuZXcgU1ZHLlJCb3goKVxyXG5cclxuICAgICAgLy8gZ2V0IHRoZSBmaXJzdCByYm94IGFuZCB1cGRhdGUgdGhlIHRhcmdldCBiYm94XHJcbiAgICAgIHZhciByYm94ID0gdGhpcy5tZW1iZXJzWzBdLnJib3godGhpcy5tZW1iZXJzWzBdLmRvYygpKVxyXG5cclxuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIHVzZXIgcmJveCBmb3IgY29ycmVjdCBwb3NpdGlvbiBhbmQgdmlzdWFsIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgICAgcmJveCA9IHJib3gubWVyZ2UodGhpcy5yYm94KHRoaXMuZG9jKCkpKVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgcmV0dXJuIHJib3hcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgYSBuZXcgc2V0XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKG1lbWJlcnMpIHtcclxuICAgICAgcmV0dXJuIG5ldyBTVkcuU2V0KG1lbWJlcnMpXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cclxuU1ZHLkZYLlNldCA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogZnVuY3Rpb24oc2V0KSB7XHJcbiAgICAvLyBzdG9yZSByZWZlcmVuY2UgdG8gc2V0XHJcbiAgICB0aGlzLnNldCA9IHNldFxyXG4gIH1cclxuXHJcbn0pXHJcblxyXG4vLyBBbGlhcyBtZXRob2RzXHJcblNWRy5TZXQuaW5oZXJpdCA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBtXHJcbiAgICAsIG1ldGhvZHMgPSBbXVxyXG5cclxuICAvLyBnYXRoZXIgc2hhcGUgbWV0aG9kc1xyXG4gIGZvcih2YXIgbSBpbiBTVkcuU2hhcGUucHJvdG90eXBlKVxyXG4gICAgaWYgKHR5cGVvZiBTVkcuU2hhcGUucHJvdG90eXBlW21dID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFNWRy5TZXQucHJvdG90eXBlW21dICE9ICdmdW5jdGlvbicpXHJcbiAgICAgIG1ldGhvZHMucHVzaChtKVxyXG5cclxuICAvLyBhcHBseSBzaGFwZSBhbGlhc3Nlc1xyXG4gIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcclxuICAgIFNWRy5TZXQucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgaWYgKHRoaXMubWVtYmVyc1tpXSAmJiB0eXBlb2YgdGhpcy5tZW1iZXJzW2ldW21ldGhvZF0gPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgIHRoaXMubWVtYmVyc1tpXVttZXRob2RdLmFwcGx5KHRoaXMubWVtYmVyc1tpXSwgYXJndW1lbnRzKVxyXG5cclxuICAgICAgcmV0dXJuIG1ldGhvZCA9PSAnYW5pbWF0ZScgPyAodGhpcy5meCB8fCAodGhpcy5meCA9IG5ldyBTVkcuRlguU2V0KHRoaXMpKSkgOiB0aGlzXHJcbiAgICB9XHJcbiAgfSlcclxuXHJcbiAgLy8gY2xlYXIgbWV0aG9kcyBmb3IgdGhlIG5leHQgcm91bmRcclxuICBtZXRob2RzID0gW11cclxuXHJcbiAgLy8gZ2F0aGVyIGZ4IG1ldGhvZHNcclxuICBmb3IodmFyIG0gaW4gU1ZHLkZYLnByb3RvdHlwZSlcclxuICAgIGlmICh0eXBlb2YgU1ZHLkZYLnByb3RvdHlwZVttXSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTVkcuRlguU2V0LnByb3RvdHlwZVttXSAhPSAnZnVuY3Rpb24nKVxyXG4gICAgICBtZXRob2RzLnB1c2gobSlcclxuXHJcbiAgLy8gYXBwbHkgZnggYWxpYXNzZXNcclxuICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XHJcbiAgICBTVkcuRlguU2V0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMuc2V0Lm1lbWJlcnMubGVuZ3RoOyBpIDwgaWw7IGkrKylcclxuICAgICAgICB0aGlzLnNldC5tZW1iZXJzW2ldLmZ4W21ldGhvZF0uYXBwbHkodGhpcy5zZXQubWVtYmVyc1tpXS5meCwgYXJndW1lbnRzKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICB9KVxyXG59XHJcblxyXG5cclxuXG5cclxuU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xyXG4gIC8vIFN0b3JlIGRhdGEgdmFsdWVzIG9uIHN2ZyBub2Rlc1xyXG4gIGRhdGE6IGZ1bmN0aW9uKGEsIHYsIHIpIHtcclxuICAgIGlmICh0eXBlb2YgYSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICBmb3IgKHYgaW4gYSlcclxuICAgICAgICB0aGlzLmRhdGEodiwgYVt2XSlcclxuXHJcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5hdHRyKCdkYXRhLScgKyBhKSlcclxuICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignZGF0YS0nICsgYSlcclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuYXR0cihcclxuICAgICAgICAnZGF0YS0nICsgYVxyXG4gICAgICAsIHYgPT09IG51bGwgP1xyXG4gICAgICAgICAgbnVsbCA6XHJcbiAgICAgICAgciA9PT0gdHJ1ZSB8fCB0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInID9cclxuICAgICAgICAgIHYgOlxyXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodilcclxuICAgICAgKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG59KVxuU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xyXG4gIC8vIFJlbWVtYmVyIGFyYml0cmFyeSBkYXRhXHJcbiAgcmVtZW1iZXI6IGZ1bmN0aW9uKGssIHYpIHtcclxuICAgIC8vIHJlbWVtYmVyIGV2ZXJ5IGl0ZW0gaW4gYW4gb2JqZWN0IGluZGl2aWR1YWxseVxyXG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT0gJ29iamVjdCcpXHJcbiAgICAgIGZvciAodmFyIHYgaW4gaylcclxuICAgICAgICB0aGlzLnJlbWVtYmVyKHYsIGtbdl0pXHJcblxyXG4gICAgLy8gcmV0cmlldmUgbWVtb3J5XHJcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpXHJcbiAgICAgIHJldHVybiB0aGlzLm1lbW9yeSgpW2tdXHJcblxyXG4gICAgLy8gc3RvcmUgbWVtb3J5XHJcbiAgICBlbHNlXHJcbiAgICAgIHRoaXMubWVtb3J5KClba10gPSB2XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIEVyYXNlIGEgZ2l2ZW4gbWVtb3J5XHJcbiwgZm9yZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApXHJcbiAgICAgIHRoaXMuX21lbW9yeSA9IHt9XHJcbiAgICBlbHNlXHJcbiAgICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgZGVsZXRlIHRoaXMubWVtb3J5KClbYXJndW1lbnRzW2ldXVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBJbml0aWFsaXplIG9yIHJldHVybiBsb2NhbCBtZW1vcnkgb2JqZWN0XHJcbiwgbWVtb3J5OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9tZW1vcnkgfHwgKHRoaXMuX21lbW9yeSA9IHt9KVxyXG4gIH1cclxuXHJcbn0pXG4vLyBNZXRob2QgZm9yIGdldHRpbmcgYW4gZWxlbWVudCBieSBpZFxyXG5TVkcuZ2V0ID0gZnVuY3Rpb24oaWQpIHtcclxuICB2YXIgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkRnJvbVJlZmVyZW5jZShpZCkgfHwgaWQpXHJcbiAgcmV0dXJuIFNWRy5hZG9wdChub2RlKVxyXG59XHJcblxyXG4vLyBTZWxlY3QgZWxlbWVudHMgYnkgcXVlcnkgc3RyaW5nXHJcblNWRy5zZWxlY3QgPSBmdW5jdGlvbihxdWVyeSwgcGFyZW50KSB7XHJcbiAgcmV0dXJuIG5ldyBTVkcuU2V0KFxyXG4gICAgU1ZHLnV0aWxzLm1hcCgocGFyZW50IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSwgZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpXHJcbiAgICB9KVxyXG4gIClcclxufVxyXG5cclxuU1ZHLmV4dGVuZChTVkcuUGFyZW50LCB7XHJcbiAgLy8gU2NvcGVkIHNlbGVjdCBtZXRob2RcclxuICBzZWxlY3Q6IGZ1bmN0aW9uKHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gU1ZHLnNlbGVjdChxdWVyeSwgdGhpcy5ub2RlKVxyXG4gIH1cclxuXHJcbn0pXG5mdW5jdGlvbiBwYXRoUmVnUmVwbGFjZShhLCBiLCBjLCBkKSB7XHJcbiAgcmV0dXJuIGMgKyBkLnJlcGxhY2UoU1ZHLnJlZ2V4LmRvdHMsICcgLicpXHJcbn1cclxuXHJcbi8vIGNyZWF0ZXMgZGVlcCBjbG9uZSBvZiBhcnJheVxyXG5mdW5jdGlvbiBhcnJheV9jbG9uZShhcnIpe1xyXG4gIHZhciBjbG9uZSA9IGFyci5zbGljZSgwKVxyXG4gIGZvcih2YXIgaSA9IGNsb25lLmxlbmd0aDsgaS0tOyl7XHJcbiAgICBpZihBcnJheS5pc0FycmF5KGNsb25lW2ldKSl7XHJcbiAgICAgIGNsb25lW2ldID0gYXJyYXlfY2xvbmUoY2xvbmVbaV0pXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjbG9uZVxyXG59XHJcblxyXG4vLyB0ZXN0cyBpZiBhIGdpdmVuIGVsZW1lbnQgaXMgaW5zdGFuY2Ugb2YgYW4gb2JqZWN0XHJcbmZ1bmN0aW9uIGlzKGVsLCBvYmope1xyXG4gIHJldHVybiBlbCBpbnN0YW5jZW9mIG9ialxyXG59XHJcblxyXG4vLyB0ZXN0cyBpZiBhIGdpdmVuIHNlbGVjdG9yIG1hdGNoZXMgYW4gZWxlbWVudFxyXG5mdW5jdGlvbiBtYXRjaGVzKGVsLCBzZWxlY3Rvcikge1xyXG4gIHJldHVybiAoZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3IgfHwgZWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlbC5vTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGVsLCBzZWxlY3Rvcik7XHJcbn1cclxuXHJcbi8vIENvbnZlcnQgZGFzaC1zZXBhcmF0ZWQtc3RyaW5nIHRvIGNhbWVsQ2FzZVxyXG5mdW5jdGlvbiBjYW1lbENhc2Uocykge1xyXG4gIHJldHVybiBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbihtLCBnKSB7XHJcbiAgICByZXR1cm4gZy50b1VwcGVyQ2FzZSgpXHJcbiAgfSlcclxufVxyXG5cclxuLy8gQ2FwaXRhbGl6ZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmdcclxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzKSB7XHJcbiAgcmV0dXJuIHMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpXHJcbn1cclxuXHJcbi8vIEVuc3VyZSB0byBzaXgtYmFzZWQgaGV4XHJcbmZ1bmN0aW9uIGZ1bGxIZXgoaGV4KSB7XHJcbiAgcmV0dXJuIGhleC5sZW5ndGggPT0gNCA/XHJcbiAgICBbICcjJyxcclxuICAgICAgaGV4LnN1YnN0cmluZygxLCAyKSwgaGV4LnN1YnN0cmluZygxLCAyKVxyXG4gICAgLCBoZXguc3Vic3RyaW5nKDIsIDMpLCBoZXguc3Vic3RyaW5nKDIsIDMpXHJcbiAgICAsIGhleC5zdWJzdHJpbmcoMywgNCksIGhleC5zdWJzdHJpbmcoMywgNClcclxuICAgIF0uam9pbignJykgOiBoZXhcclxufVxyXG5cclxuLy8gQ29tcG9uZW50IHRvIGhleCB2YWx1ZVxyXG5mdW5jdGlvbiBjb21wVG9IZXgoY29tcCkge1xyXG4gIHZhciBoZXggPSBjb21wLnRvU3RyaW5nKDE2KVxyXG4gIHJldHVybiBoZXgubGVuZ3RoID09IDEgPyAnMCcgKyBoZXggOiBoZXhcclxufVxyXG5cclxuLy8gQ2FsY3VsYXRlIHByb3BvcnRpb25hbCB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyB3aGVuIG5lY2Vzc2FyeVxyXG5mdW5jdGlvbiBwcm9wb3J0aW9uYWxTaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpIHtcclxuICBpZiAod2lkdGggPT0gbnVsbCB8fCBoZWlnaHQgPT0gbnVsbCkge1xyXG4gICAgdmFyIGJveCA9IGVsZW1lbnQuYmJveCgpXHJcblxyXG4gICAgaWYgKHdpZHRoID09IG51bGwpXHJcbiAgICAgIHdpZHRoID0gYm94LndpZHRoIC8gYm94LmhlaWdodCAqIGhlaWdodFxyXG4gICAgZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwpXHJcbiAgICAgIGhlaWdodCA9IGJveC5oZWlnaHQgLyBib3gud2lkdGggKiB3aWR0aFxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHdpZHRoOiAgd2lkdGhcclxuICAsIGhlaWdodDogaGVpZ2h0XHJcbiAgfVxyXG59XHJcblxyXG4vLyBEZWx0YSB0cmFuc2Zvcm0gcG9pbnRcclxuZnVuY3Rpb24gZGVsdGFUcmFuc2Zvcm1Qb2ludChtYXRyaXgsIHgsIHkpIHtcclxuICByZXR1cm4ge1xyXG4gICAgeDogeCAqIG1hdHJpeC5hICsgeSAqIG1hdHJpeC5jICsgMFxyXG4gICwgeTogeCAqIG1hdHJpeC5iICsgeSAqIG1hdHJpeC5kICsgMFxyXG4gIH1cclxufVxyXG5cclxuLy8gTWFwIG1hdHJpeCBhcnJheSB0byBvYmplY3RcclxuZnVuY3Rpb24gYXJyYXlUb01hdHJpeChhKSB7XHJcbiAgcmV0dXJuIHsgYTogYVswXSwgYjogYVsxXSwgYzogYVsyXSwgZDogYVszXSwgZTogYVs0XSwgZjogYVs1XSB9XHJcbn1cclxuXHJcbi8vIFBhcnNlIG1hdHJpeCBpZiByZXF1aXJlZFxyXG5mdW5jdGlvbiBwYXJzZU1hdHJpeChtYXRyaXgpIHtcclxuICBpZiAoIShtYXRyaXggaW5zdGFuY2VvZiBTVkcuTWF0cml4KSlcclxuICAgIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KG1hdHJpeClcclxuXHJcbiAgcmV0dXJuIG1hdHJpeFxyXG59XHJcblxyXG4vLyBBZGQgY2VudHJlIHBvaW50IHRvIHRyYW5zZm9ybSBvYmplY3RcclxuZnVuY3Rpb24gZW5zdXJlQ2VudHJlKG8sIHRhcmdldCkge1xyXG4gIG8uY3ggPSBvLmN4ID09IG51bGwgPyB0YXJnZXQuYmJveCgpLmN4IDogby5jeFxyXG4gIG8uY3kgPSBvLmN5ID09IG51bGwgPyB0YXJnZXQuYmJveCgpLmN5IDogby5jeVxyXG59XHJcblxyXG4vLyBQYXRoQXJyYXkgSGVscGVyc1xyXG5mdW5jdGlvbiBhcnJheVRvU3RyaW5nKGEpIHtcclxuICBmb3IgKHZhciBpID0gMCwgaWwgPSBhLmxlbmd0aCwgcyA9ICcnOyBpIDwgaWw7IGkrKykge1xyXG4gICAgcyArPSBhW2ldWzBdXHJcblxyXG4gICAgaWYgKGFbaV1bMV0gIT0gbnVsbCkge1xyXG4gICAgICBzICs9IGFbaV1bMV1cclxuXHJcbiAgICAgIGlmIChhW2ldWzJdICE9IG51bGwpIHtcclxuICAgICAgICBzICs9ICcgJ1xyXG4gICAgICAgIHMgKz0gYVtpXVsyXVxyXG5cclxuICAgICAgICBpZiAoYVtpXVszXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICBzICs9ICcgJ1xyXG4gICAgICAgICAgcyArPSBhW2ldWzNdXHJcbiAgICAgICAgICBzICs9ICcgJ1xyXG4gICAgICAgICAgcyArPSBhW2ldWzRdXHJcblxyXG4gICAgICAgICAgaWYgKGFbaV1bNV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzICs9ICcgJ1xyXG4gICAgICAgICAgICBzICs9IGFbaV1bNV1cclxuICAgICAgICAgICAgcyArPSAnICdcclxuICAgICAgICAgICAgcyArPSBhW2ldWzZdXHJcblxyXG4gICAgICAgICAgICBpZiAoYVtpXVs3XSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgcyArPSAnICdcclxuICAgICAgICAgICAgICBzICs9IGFbaV1bN11cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHMgKyAnICdcclxufVxyXG5cclxuLy8gRGVlcCBuZXcgaWQgYXNzaWdubWVudFxyXG5mdW5jdGlvbiBhc3NpZ25OZXdJZChub2RlKSB7XHJcbiAgLy8gZG8gdGhlIHNhbWUgZm9yIFNWRyBjaGlsZCBub2RlcyBhcyB3ZWxsXHJcbiAgZm9yICh2YXIgaSA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcclxuICAgIGlmIChub2RlLmNoaWxkTm9kZXNbaV0gaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudClcclxuICAgICAgYXNzaWduTmV3SWQobm9kZS5jaGlsZE5vZGVzW2ldKVxyXG5cclxuICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpLmlkKFNWRy5laWQobm9kZS5ub2RlTmFtZSkpXHJcbn1cclxuXHJcbi8vIEFkZCBtb3JlIGJvdW5kaW5nIGJveCBwcm9wZXJ0aWVzXHJcbmZ1bmN0aW9uIGZ1bGxCb3goYikge1xyXG4gIGlmIChiLnggPT0gbnVsbCkge1xyXG4gICAgYi54ICAgICAgPSAwXHJcbiAgICBiLnkgICAgICA9IDBcclxuICAgIGIud2lkdGggID0gMFxyXG4gICAgYi5oZWlnaHQgPSAwXHJcbiAgfVxyXG5cclxuICBiLncgID0gYi53aWR0aFxyXG4gIGIuaCAgPSBiLmhlaWdodFxyXG4gIGIueDIgPSBiLnggKyBiLndpZHRoXHJcbiAgYi55MiA9IGIueSArIGIuaGVpZ2h0XHJcbiAgYi5jeCA9IGIueCArIGIud2lkdGggLyAyXHJcbiAgYi5jeSA9IGIueSArIGIuaGVpZ2h0IC8gMlxyXG5cclxuICByZXR1cm4gYlxyXG59XHJcblxyXG4vLyBHZXQgaWQgZnJvbSByZWZlcmVuY2Ugc3RyaW5nXHJcbmZ1bmN0aW9uIGlkRnJvbVJlZmVyZW5jZSh1cmwpIHtcclxuICB2YXIgbSA9IHVybC50b1N0cmluZygpLm1hdGNoKFNWRy5yZWdleC5yZWZlcmVuY2UpXHJcblxyXG4gIGlmIChtKSByZXR1cm4gbVsxXVxyXG59XHJcblxyXG4vLyBDcmVhdGUgbWF0cml4IGFycmF5IGZvciBsb29waW5nXHJcbnZhciBhYmNkZWYgPSAnYWJjZGVmJy5zcGxpdCgnJylcbi8vIEFkZCBDdXN0b21FdmVudCB0byBJRTkgYW5kIElFMTBcclxuaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgIT09ICdmdW5jdGlvbicpIHtcclxuICAvLyBDb2RlIGZyb206IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudFxyXG4gIHZhciBDdXN0b21FdmVudCA9IGZ1bmN0aW9uKGV2ZW50LCBvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWQgfVxyXG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKVxyXG4gICAgZS5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIG9wdGlvbnMuYnViYmxlcywgb3B0aW9ucy5jYW5jZWxhYmxlLCBvcHRpb25zLmRldGFpbClcclxuICAgIHJldHVybiBlXHJcbiAgfVxyXG5cclxuICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlXHJcblxyXG4gIHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50XHJcbn1cclxuXHJcbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSAvIGNhbmNlbEFuaW1hdGlvbkZyYW1lIFBvbHlmaWxsIHdpdGggZmFsbGJhY2sgYmFzZWQgb24gUGF1bCBJcmlzaFxyXG4oZnVuY3Rpb24odykge1xyXG4gIHZhciBsYXN0VGltZSA9IDBcclxuICB2YXIgdmVuZG9ycyA9IFsnbW96JywgJ3dlYmtpdCddXHJcblxyXG4gIGZvcih2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XHJcbiAgICB3LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdbdmVuZG9yc1t4XSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXVxyXG4gICAgdy5jYW5jZWxBbmltYXRpb25GcmFtZSAgPSB3W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ11cclxuICB9XHJcblxyXG4gIHcucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXHJcbiAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpXHJcblxyXG4gICAgICB2YXIgaWQgPSB3LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKVxyXG4gICAgICB9LCB0aW1lVG9DYWxsKVxyXG5cclxuICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGxcclxuICAgICAgcmV0dXJuIGlkXHJcbiAgICB9XHJcblxyXG4gIHcuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHcuY2xlYXJUaW1lb3V0O1xyXG5cclxufSh3aW5kb3cpKVxyXG5cclxucmV0dXJuIFNWR1xyXG5cclxufSkpO1xyXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3ZnanMvZGlzdC9zdmcuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///45\n");

/***/ }),

/***/ 46:
/***/ (function(module, exports) {

eval("/*! svg.draggable.js - v2.2.1 - 2016-08-25\r\n* https://github.com/wout/svg.draggable.js\r\n* Copyright (c) 2016 Wout Fierens; Licensed MIT */\r\n;(function() {\r\n\r\n  // creates handler, saves it\r\n  function DragHandler(el){\r\n    el.remember('_draggable', this)\r\n    this.el = el\r\n  }\r\n\r\n\r\n  // Sets new parameter, starts dragging\r\n  DragHandler.prototype.init = function(constraint, val){\r\n    var _this = this\r\n    this.constraint = constraint\r\n    this.value = val\r\n    this.el.on('mousedown.drag', function(e){ _this.start(e) })\r\n    this.el.on('touchstart.drag', function(e){ _this.start(e) })\r\n  }\r\n\r\n  // transforms one point from screen to user coords\r\n  DragHandler.prototype.transformPoint = function(event, offset){\r\n      event = event || window.event\r\n      var touches = event.changedTouches && event.changedTouches[0] || event\r\n      this.p.x = touches.pageX - (offset || 0)\r\n      this.p.y = touches.pageY\r\n      return this.p.matrixTransform(this.m)\r\n  }\r\n  \r\n  // gets elements bounding box with special handling of groups, nested and use\r\n  DragHandler.prototype.getBBox = function(){\r\n\r\n    var box = this.el.bbox()\r\n\r\n    if(this.el instanceof SVG.Nested) box = this.el.rbox()\r\n    \r\n    if (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) {\r\n      box.x = this.el.x()\r\n      box.y = this.el.y()\r\n    }\r\n\r\n    return box\r\n  }\r\n\r\n  // start dragging\r\n  DragHandler.prototype.start = function(e){\r\n\r\n    // check for left button\r\n    if(e.type == 'click'|| e.type == 'mousedown' || e.type == 'mousemove'){\r\n      if((e.which || e.buttons) != 1){\r\n          return\r\n      }\r\n    }\r\n  \r\n    var _this = this\r\n\r\n    // fire beforedrag event\r\n    this.el.fire('beforedrag', { event: e, handler: this })\r\n\r\n    // search for parent on the fly to make sure we can call\r\n    // draggable() even when element is not in the dom currently\r\n    this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc)\r\n    this.p = this.parent.node.createSVGPoint()\r\n\r\n    // save current transformation matrix\r\n    this.m = this.el.node.getScreenCTM().inverse()\r\n\r\n    var box = this.getBBox()\r\n    \r\n    var anchorOffset;\r\n    \r\n    // fix text-anchor in text-element (#37)\r\n    if(this.el instanceof SVG.Text){\r\n      anchorOffset = this.el.node.getComputedTextLength();\r\n        \r\n      switch(this.el.attr('text-anchor')){\r\n        case 'middle':\r\n          anchorOffset /= 2;\r\n          break\r\n        case 'start':\r\n          anchorOffset = 0;\r\n          break;\r\n      }\r\n    }\r\n    \r\n    this.startPoints = {\r\n      // We take absolute coordinates since we are just using a delta here\r\n      point: this.transformPoint(e, anchorOffset),\r\n      box:   box,\r\n      transform: this.el.transform()\r\n    }\r\n    \r\n    // add drag and end events to window\r\n    SVG.on(window, 'mousemove.drag', function(e){ _this.drag(e) })\r\n    SVG.on(window, 'touchmove.drag', function(e){ _this.drag(e) })\r\n    SVG.on(window, 'mouseup.drag', function(e){ _this.end(e) })\r\n    SVG.on(window, 'touchend.drag', function(e){ _this.end(e) })\r\n\r\n    // fire dragstart event\r\n    this.el.fire('dragstart', {event: e, p: this.startPoints.point, m: this.m, handler: this})\r\n\r\n    // prevent browser drag behavior\r\n    e.preventDefault()\r\n\r\n    // prevent propagation to a parent that might also have dragging enabled\r\n    e.stopPropagation();\r\n  }\r\n\r\n  // while dragging\r\n  DragHandler.prototype.drag = function(e){\r\n\r\n    var box = this.getBBox()\r\n      , p   = this.transformPoint(e)\r\n      , x   = this.startPoints.box.x + p.x - this.startPoints.point.x\r\n      , y   = this.startPoints.box.y + p.y - this.startPoints.point.y\r\n      , c   = this.constraint\r\n      , gx  = p.x - this.startPoints.point.x\r\n      , gy  = p.y - this.startPoints.point.y\r\n      \r\n    var event = new CustomEvent('dragmove', {\r\n        detail: {\r\n            event: e\r\n          , p: p\r\n          , m: this.m\r\n          , handler: this\r\n        }\r\n      , cancelable: true\r\n    })\r\n      \r\n    this.el.fire(event)\r\n    \r\n    if(event.defaultPrevented) return p\r\n\r\n    // move the element to its new position, if possible by constraint\r\n    if (typeof c == 'function') {\r\n\r\n      var coord = c.call(this.el, x, y, this.m)\r\n\r\n      // bool, just show us if movement is allowed or not\r\n      if (typeof coord == 'boolean') {\r\n        coord = {\r\n          x: coord,\r\n          y: coord\r\n        }\r\n      }\r\n\r\n      // if true, we just move. If !false its a number and we move it there\r\n      if (coord.x === true) {\r\n        this.el.x(x)\r\n      } else if (coord.x !== false) {\r\n        this.el.x(coord.x)\r\n      }\r\n\r\n      if (coord.y === true) {\r\n        this.el.y(y)\r\n      } else if (coord.y !== false) {\r\n        this.el.y(coord.y)\r\n      }\r\n\r\n    } else if (typeof c == 'object') {\r\n\r\n      // keep element within constrained box\r\n      if (c.minX != null && x < c.minX)\r\n        x = c.minX\r\n      else if (c.maxX != null && x > c.maxX - box.width){\r\n        x = c.maxX - box.width\r\n      }if (c.minY != null && y < c.minY)\r\n        y = c.minY\r\n      else if (c.maxY != null && y > c.maxY - box.height)\r\n        y = c.maxY - box.height\r\n        \r\n      if(this.el instanceof SVG.G)\r\n        this.el.matrix(this.startPoints.transform).transform({x:gx, y: gy}, true)\r\n      else\r\n        this.el.move(x, y)\r\n    }\r\n    \r\n    // so we can use it in the end-method, too\r\n    return p\r\n  }\r\n\r\n  DragHandler.prototype.end = function(e){\r\n\r\n    // final drag\r\n    var p = this.drag(e);\r\n\r\n    // fire dragend event\r\n    this.el.fire('dragend', { event: e, p: p, m: this.m, handler: this })\r\n\r\n    // unbind events\r\n    SVG.off(window, 'mousemove.drag')\r\n    SVG.off(window, 'touchmove.drag')\r\n    SVG.off(window, 'mouseup.drag')\r\n    SVG.off(window, 'touchend.drag')\r\n\r\n  }\r\n\r\n  SVG.extend(SVG.Element, {\r\n    // Make element draggable\r\n    // Constraint might be an object (as described in readme.md) or a function in the form \"function (x, y)\" that gets called before every move.\r\n    // The function can return a boolean or an object of the form {x, y}, to which the element will be moved. \"False\" skips moving, true moves to raw x, y.\r\n    draggable: function(value, constraint) {\r\n\r\n      // Check the parameters and reassign if needed\r\n      if (typeof value == 'function' || typeof value == 'object') {\r\n        constraint = value\r\n        value = true\r\n      }\r\n\r\n      var dragHandler = this.remember('_draggable') || new DragHandler(this)\r\n\r\n      // When no parameter is given, value is true\r\n      value = typeof value === 'undefined' ? true : value\r\n\r\n      if(value) dragHandler.init(constraint || {}, value)\r\n      else {\r\n        this.off('mousedown.drag')\r\n        this.off('touchstart.drag')\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n  })\r\n\r\n}).call(this);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3ZnLmRyYWdnYWJsZS5qcy9kaXN0L3N2Zy5kcmFnZ2FibGUuanM/MTljZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQsOENBQThDLGlCQUFpQjtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUFnQywwQkFBMEI7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFLGlEQUFpRCxnQkFBZ0I7QUFDakUsK0NBQStDLGVBQWU7QUFDOUQsZ0RBQWdELGVBQWU7O0FBRS9EO0FBQ0EsK0JBQStCLDhEQUE4RDs7QUFFN0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThELFlBQVk7QUFDMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLDJDQUEyQzs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsS0FBSztBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSCxDQUFDIiwiZmlsZSI6IjQ2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIHN2Zy5kcmFnZ2FibGUuanMgLSB2Mi4yLjEgLSAyMDE2LTA4LTI1XHJcbiogaHR0cHM6Ly9naXRodWIuY29tL3dvdXQvc3ZnLmRyYWdnYWJsZS5qc1xyXG4qIENvcHlyaWdodCAoYykgMjAxNiBXb3V0IEZpZXJlbnM7IExpY2Vuc2VkIE1JVCAqL1xyXG47KGZ1bmN0aW9uKCkge1xyXG5cclxuICAvLyBjcmVhdGVzIGhhbmRsZXIsIHNhdmVzIGl0XHJcbiAgZnVuY3Rpb24gRHJhZ0hhbmRsZXIoZWwpe1xyXG4gICAgZWwucmVtZW1iZXIoJ19kcmFnZ2FibGUnLCB0aGlzKVxyXG4gICAgdGhpcy5lbCA9IGVsXHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gU2V0cyBuZXcgcGFyYW1ldGVyLCBzdGFydHMgZHJhZ2dpbmdcclxuICBEcmFnSGFuZGxlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQsIHZhbCl7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzXHJcbiAgICB0aGlzLmNvbnN0cmFpbnQgPSBjb25zdHJhaW50XHJcbiAgICB0aGlzLnZhbHVlID0gdmFsXHJcbiAgICB0aGlzLmVsLm9uKCdtb3VzZWRvd24uZHJhZycsIGZ1bmN0aW9uKGUpeyBfdGhpcy5zdGFydChlKSB9KVxyXG4gICAgdGhpcy5lbC5vbigndG91Y2hzdGFydC5kcmFnJywgZnVuY3Rpb24oZSl7IF90aGlzLnN0YXJ0KGUpIH0pXHJcbiAgfVxyXG5cclxuICAvLyB0cmFuc2Zvcm1zIG9uZSBwb2ludCBmcm9tIHNjcmVlbiB0byB1c2VyIGNvb3Jkc1xyXG4gIERyYWdIYW5kbGVyLnByb3RvdHlwZS50cmFuc2Zvcm1Qb2ludCA9IGZ1bmN0aW9uKGV2ZW50LCBvZmZzZXQpe1xyXG4gICAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudFxyXG4gICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIHx8IGV2ZW50XHJcbiAgICAgIHRoaXMucC54ID0gdG91Y2hlcy5wYWdlWCAtIChvZmZzZXQgfHwgMClcclxuICAgICAgdGhpcy5wLnkgPSB0b3VjaGVzLnBhZ2VZXHJcbiAgICAgIHJldHVybiB0aGlzLnAubWF0cml4VHJhbnNmb3JtKHRoaXMubSlcclxuICB9XHJcbiAgXHJcbiAgLy8gZ2V0cyBlbGVtZW50cyBib3VuZGluZyBib3ggd2l0aCBzcGVjaWFsIGhhbmRsaW5nIG9mIGdyb3VwcywgbmVzdGVkIGFuZCB1c2VcclxuICBEcmFnSGFuZGxlci5wcm90b3R5cGUuZ2V0QkJveCA9IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgdmFyIGJveCA9IHRoaXMuZWwuYmJveCgpXHJcblxyXG4gICAgaWYodGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5OZXN0ZWQpIGJveCA9IHRoaXMuZWwucmJveCgpXHJcbiAgICBcclxuICAgIGlmICh0aGlzLmVsIGluc3RhbmNlb2YgU1ZHLkcgfHwgdGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5Vc2UgfHwgdGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5OZXN0ZWQpIHtcclxuICAgICAgYm94LnggPSB0aGlzLmVsLngoKVxyXG4gICAgICBib3gueSA9IHRoaXMuZWwueSgpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJveFxyXG4gIH1cclxuXHJcbiAgLy8gc3RhcnQgZHJhZ2dpbmdcclxuICBEcmFnSGFuZGxlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihlKXtcclxuXHJcbiAgICAvLyBjaGVjayBmb3IgbGVmdCBidXR0b25cclxuICAgIGlmKGUudHlwZSA9PSAnY2xpY2snfHwgZS50eXBlID09ICdtb3VzZWRvd24nIHx8IGUudHlwZSA9PSAnbW91c2Vtb3ZlJyl7XHJcbiAgICAgIGlmKChlLndoaWNoIHx8IGUuYnV0dG9ucykgIT0gMSl7XHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgdmFyIF90aGlzID0gdGhpc1xyXG5cclxuICAgIC8vIGZpcmUgYmVmb3JlZHJhZyBldmVudFxyXG4gICAgdGhpcy5lbC5maXJlKCdiZWZvcmVkcmFnJywgeyBldmVudDogZSwgaGFuZGxlcjogdGhpcyB9KVxyXG5cclxuICAgIC8vIHNlYXJjaCBmb3IgcGFyZW50IG9uIHRoZSBmbHkgdG8gbWFrZSBzdXJlIHdlIGNhbiBjYWxsXHJcbiAgICAvLyBkcmFnZ2FibGUoKSBldmVuIHdoZW4gZWxlbWVudCBpcyBub3QgaW4gdGhlIGRvbSBjdXJyZW50bHlcclxuICAgIHRoaXMucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5lbC5wYXJlbnQoU1ZHLk5lc3RlZCkgfHwgdGhpcy5lbC5wYXJlbnQoU1ZHLkRvYylcclxuICAgIHRoaXMucCA9IHRoaXMucGFyZW50Lm5vZGUuY3JlYXRlU1ZHUG9pbnQoKVxyXG5cclxuICAgIC8vIHNhdmUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuICAgIHRoaXMubSA9IHRoaXMuZWwubm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKClcclxuXHJcbiAgICB2YXIgYm94ID0gdGhpcy5nZXRCQm94KClcclxuICAgIFxyXG4gICAgdmFyIGFuY2hvck9mZnNldDtcclxuICAgIFxyXG4gICAgLy8gZml4IHRleHQtYW5jaG9yIGluIHRleHQtZWxlbWVudCAoIzM3KVxyXG4gICAgaWYodGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5UZXh0KXtcclxuICAgICAgYW5jaG9yT2Zmc2V0ID0gdGhpcy5lbC5ub2RlLmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xyXG4gICAgICAgIFxyXG4gICAgICBzd2l0Y2godGhpcy5lbC5hdHRyKCd0ZXh0LWFuY2hvcicpKXtcclxuICAgICAgICBjYXNlICdtaWRkbGUnOlxyXG4gICAgICAgICAgYW5jaG9yT2Zmc2V0IC89IDI7XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ3N0YXJ0JzpcclxuICAgICAgICAgIGFuY2hvck9mZnNldCA9IDA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLnN0YXJ0UG9pbnRzID0ge1xyXG4gICAgICAvLyBXZSB0YWtlIGFic29sdXRlIGNvb3JkaW5hdGVzIHNpbmNlIHdlIGFyZSBqdXN0IHVzaW5nIGEgZGVsdGEgaGVyZVxyXG4gICAgICBwb2ludDogdGhpcy50cmFuc2Zvcm1Qb2ludChlLCBhbmNob3JPZmZzZXQpLFxyXG4gICAgICBib3g6ICAgYm94LFxyXG4gICAgICB0cmFuc2Zvcm06IHRoaXMuZWwudHJhbnNmb3JtKClcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gYWRkIGRyYWcgYW5kIGVuZCBldmVudHMgdG8gd2luZG93XHJcbiAgICBTVkcub24od2luZG93LCAnbW91c2Vtb3ZlLmRyYWcnLCBmdW5jdGlvbihlKXsgX3RoaXMuZHJhZyhlKSB9KVxyXG4gICAgU1ZHLm9uKHdpbmRvdywgJ3RvdWNobW92ZS5kcmFnJywgZnVuY3Rpb24oZSl7IF90aGlzLmRyYWcoZSkgfSlcclxuICAgIFNWRy5vbih3aW5kb3csICdtb3VzZXVwLmRyYWcnLCBmdW5jdGlvbihlKXsgX3RoaXMuZW5kKGUpIH0pXHJcbiAgICBTVkcub24od2luZG93LCAndG91Y2hlbmQuZHJhZycsIGZ1bmN0aW9uKGUpeyBfdGhpcy5lbmQoZSkgfSlcclxuXHJcbiAgICAvLyBmaXJlIGRyYWdzdGFydCBldmVudFxyXG4gICAgdGhpcy5lbC5maXJlKCdkcmFnc3RhcnQnLCB7ZXZlbnQ6IGUsIHA6IHRoaXMuc3RhcnRQb2ludHMucG9pbnQsIG06IHRoaXMubSwgaGFuZGxlcjogdGhpc30pXHJcblxyXG4gICAgLy8gcHJldmVudCBicm93c2VyIGRyYWcgYmVoYXZpb3JcclxuICAgIGUucHJldmVudERlZmF1bHQoKVxyXG5cclxuICAgIC8vIHByZXZlbnQgcHJvcGFnYXRpb24gdG8gYSBwYXJlbnQgdGhhdCBtaWdodCBhbHNvIGhhdmUgZHJhZ2dpbmcgZW5hYmxlZFxyXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICB9XHJcblxyXG4gIC8vIHdoaWxlIGRyYWdnaW5nXHJcbiAgRHJhZ0hhbmRsZXIucHJvdG90eXBlLmRyYWcgPSBmdW5jdGlvbihlKXtcclxuXHJcbiAgICB2YXIgYm94ID0gdGhpcy5nZXRCQm94KClcclxuICAgICAgLCBwICAgPSB0aGlzLnRyYW5zZm9ybVBvaW50KGUpXHJcbiAgICAgICwgeCAgID0gdGhpcy5zdGFydFBvaW50cy5ib3gueCArIHAueCAtIHRoaXMuc3RhcnRQb2ludHMucG9pbnQueFxyXG4gICAgICAsIHkgICA9IHRoaXMuc3RhcnRQb2ludHMuYm94LnkgKyBwLnkgLSB0aGlzLnN0YXJ0UG9pbnRzLnBvaW50LnlcclxuICAgICAgLCBjICAgPSB0aGlzLmNvbnN0cmFpbnRcclxuICAgICAgLCBneCAgPSBwLnggLSB0aGlzLnN0YXJ0UG9pbnRzLnBvaW50LnhcclxuICAgICAgLCBneSAgPSBwLnkgLSB0aGlzLnN0YXJ0UG9pbnRzLnBvaW50LnlcclxuICAgICAgXHJcbiAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2RyYWdtb3ZlJywge1xyXG4gICAgICAgIGRldGFpbDoge1xyXG4gICAgICAgICAgICBldmVudDogZVxyXG4gICAgICAgICAgLCBwOiBwXHJcbiAgICAgICAgICAsIG06IHRoaXMubVxyXG4gICAgICAgICAgLCBoYW5kbGVyOiB0aGlzXHJcbiAgICAgICAgfVxyXG4gICAgICAsIGNhbmNlbGFibGU6IHRydWVcclxuICAgIH0pXHJcbiAgICAgIFxyXG4gICAgdGhpcy5lbC5maXJlKGV2ZW50KVxyXG4gICAgXHJcbiAgICBpZihldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm4gcFxyXG5cclxuICAgIC8vIG1vdmUgdGhlIGVsZW1lbnQgdG8gaXRzIG5ldyBwb3NpdGlvbiwgaWYgcG9zc2libGUgYnkgY29uc3RyYWludFxyXG4gICAgaWYgKHR5cGVvZiBjID09ICdmdW5jdGlvbicpIHtcclxuXHJcbiAgICAgIHZhciBjb29yZCA9IGMuY2FsbCh0aGlzLmVsLCB4LCB5LCB0aGlzLm0pXHJcblxyXG4gICAgICAvLyBib29sLCBqdXN0IHNob3cgdXMgaWYgbW92ZW1lbnQgaXMgYWxsb3dlZCBvciBub3RcclxuICAgICAgaWYgKHR5cGVvZiBjb29yZCA9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICBjb29yZCA9IHtcclxuICAgICAgICAgIHg6IGNvb3JkLFxyXG4gICAgICAgICAgeTogY29vcmRcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGlmIHRydWUsIHdlIGp1c3QgbW92ZS4gSWYgIWZhbHNlIGl0cyBhIG51bWJlciBhbmQgd2UgbW92ZSBpdCB0aGVyZVxyXG4gICAgICBpZiAoY29vcmQueCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuZWwueCh4KVxyXG4gICAgICB9IGVsc2UgaWYgKGNvb3JkLnggIT09IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5lbC54KGNvb3JkLngpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjb29yZC55ID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5lbC55KHkpXHJcbiAgICAgIH0gZWxzZSBpZiAoY29vcmQueSAhPT0gZmFsc2UpIHtcclxuICAgICAgICB0aGlzLmVsLnkoY29vcmQueSlcclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGMgPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgIC8vIGtlZXAgZWxlbWVudCB3aXRoaW4gY29uc3RyYWluZWQgYm94XHJcbiAgICAgIGlmIChjLm1pblggIT0gbnVsbCAmJiB4IDwgYy5taW5YKVxyXG4gICAgICAgIHggPSBjLm1pblhcclxuICAgICAgZWxzZSBpZiAoYy5tYXhYICE9IG51bGwgJiYgeCA+IGMubWF4WCAtIGJveC53aWR0aCl7XHJcbiAgICAgICAgeCA9IGMubWF4WCAtIGJveC53aWR0aFxyXG4gICAgICB9aWYgKGMubWluWSAhPSBudWxsICYmIHkgPCBjLm1pblkpXHJcbiAgICAgICAgeSA9IGMubWluWVxyXG4gICAgICBlbHNlIGlmIChjLm1heFkgIT0gbnVsbCAmJiB5ID4gYy5tYXhZIC0gYm94LmhlaWdodClcclxuICAgICAgICB5ID0gYy5tYXhZIC0gYm94LmhlaWdodFxyXG4gICAgICAgIFxyXG4gICAgICBpZih0aGlzLmVsIGluc3RhbmNlb2YgU1ZHLkcpXHJcbiAgICAgICAgdGhpcy5lbC5tYXRyaXgodGhpcy5zdGFydFBvaW50cy50cmFuc2Zvcm0pLnRyYW5zZm9ybSh7eDpneCwgeTogZ3l9LCB0cnVlKVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5lbC5tb3ZlKHgsIHkpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIHNvIHdlIGNhbiB1c2UgaXQgaW4gdGhlIGVuZC1tZXRob2QsIHRvb1xyXG4gICAgcmV0dXJuIHBcclxuICB9XHJcblxyXG4gIERyYWdIYW5kbGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihlKXtcclxuXHJcbiAgICAvLyBmaW5hbCBkcmFnXHJcbiAgICB2YXIgcCA9IHRoaXMuZHJhZyhlKTtcclxuXHJcbiAgICAvLyBmaXJlIGRyYWdlbmQgZXZlbnRcclxuICAgIHRoaXMuZWwuZmlyZSgnZHJhZ2VuZCcsIHsgZXZlbnQ6IGUsIHA6IHAsIG06IHRoaXMubSwgaGFuZGxlcjogdGhpcyB9KVxyXG5cclxuICAgIC8vIHVuYmluZCBldmVudHNcclxuICAgIFNWRy5vZmYod2luZG93LCAnbW91c2Vtb3ZlLmRyYWcnKVxyXG4gICAgU1ZHLm9mZih3aW5kb3csICd0b3VjaG1vdmUuZHJhZycpXHJcbiAgICBTVkcub2ZmKHdpbmRvdywgJ21vdXNldXAuZHJhZycpXHJcbiAgICBTVkcub2ZmKHdpbmRvdywgJ3RvdWNoZW5kLmRyYWcnKVxyXG5cclxuICB9XHJcblxyXG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAgIC8vIE1ha2UgZWxlbWVudCBkcmFnZ2FibGVcclxuICAgIC8vIENvbnN0cmFpbnQgbWlnaHQgYmUgYW4gb2JqZWN0IChhcyBkZXNjcmliZWQgaW4gcmVhZG1lLm1kKSBvciBhIGZ1bmN0aW9uIGluIHRoZSBmb3JtIFwiZnVuY3Rpb24gKHgsIHkpXCIgdGhhdCBnZXRzIGNhbGxlZCBiZWZvcmUgZXZlcnkgbW92ZS5cclxuICAgIC8vIFRoZSBmdW5jdGlvbiBjYW4gcmV0dXJuIGEgYm9vbGVhbiBvciBhbiBvYmplY3Qgb2YgdGhlIGZvcm0ge3gsIHl9LCB0byB3aGljaCB0aGUgZWxlbWVudCB3aWxsIGJlIG1vdmVkLiBcIkZhbHNlXCIgc2tpcHMgbW92aW5nLCB0cnVlIG1vdmVzIHRvIHJhdyB4LCB5LlxyXG4gICAgZHJhZ2dhYmxlOiBmdW5jdGlvbih2YWx1ZSwgY29uc3RyYWludCkge1xyXG5cclxuICAgICAgLy8gQ2hlY2sgdGhlIHBhcmFtZXRlcnMgYW5kIHJlYXNzaWduIGlmIG5lZWRlZFxyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgY29uc3RyYWludCA9IHZhbHVlXHJcbiAgICAgICAgdmFsdWUgPSB0cnVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBkcmFnSGFuZGxlciA9IHRoaXMucmVtZW1iZXIoJ19kcmFnZ2FibGUnKSB8fCBuZXcgRHJhZ0hhbmRsZXIodGhpcylcclxuXHJcbiAgICAgIC8vIFdoZW4gbm8gcGFyYW1ldGVyIGlzIGdpdmVuLCB2YWx1ZSBpcyB0cnVlXHJcbiAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiB2YWx1ZVxyXG5cclxuICAgICAgaWYodmFsdWUpIGRyYWdIYW5kbGVyLmluaXQoY29uc3RyYWludCB8fCB7fSwgdmFsdWUpXHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMub2ZmKCdtb3VzZWRvd24uZHJhZycpXHJcbiAgICAgICAgdGhpcy5vZmYoJ3RvdWNoc3RhcnQuZHJhZycpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gIH0pXHJcblxyXG59KS5jYWxsKHRoaXMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N2Zy5kcmFnZ2FibGUuanMvZGlzdC9zdmcuZHJhZ2dhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///46\n");

/***/ }),

/***/ 47:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_svgjs_dist_svg_js__ = __webpack_require__(45);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_svgjs_dist_svg_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_svgjs_dist_svg_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_svg_draggable_js_dist_svg_draggable_js__ = __webpack_require__(46);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_svg_draggable_js_dist_svg_draggable_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_svg_draggable_js_dist_svg_draggable_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__css_workflow_css__ = __webpack_require__(38);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__css_workflow_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__css_workflow_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config__ = __webpack_require__(39);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__config__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__svgParts__ = __webpack_require__(54);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * svg node\r\n */\r\n//export default class{\r\n  class SvgNodeUI{\r\n  /**\r\n   * create new instance\r\n   * @param svg  svg.js's instance\r\n   * @param sio  socket.io's instance\r\n   * @param node any node instance to draw\r\n   */\r\n  constructor(svg, sio, node) {\r\n    /** svg.js's instance*/\r\n    this.svg=svg;\r\n\r\n    /** cable instance container */\r\n    this.nextLinks=[];\r\n    this.elseLinks=[];\r\n    this.previousLinks=[];\r\n    this.outputFileLinks=[];\r\n    this.inputFileLinks=[];\r\n\r\n    /** svg representation of this node */\r\n    this.group=svg.group();\r\n    this.group.data({\"index\": node.index, \"type\": node.type}).draggable().addClass('node');\r\n\r\n    // draw node\r\n    const [box, textHeight]= __WEBPACK_IMPORTED_MODULE_4__svgParts__[\"b\" /* createBox */](svg, node.pos.x, node.pos.y, node.type, node.name, node.inputFiles, node.outputFiles, node.state, node.nodes, node.numTotal, node.numFinished, node.numFailed); \r\n    const boxBbox=box.bbox();\r\n    const boxX=box.x();\r\n    const boxY=box.y();\r\n    this.group.add(box);\r\n    this.group.data({\"boxBbox\": boxBbox});\r\n    \r\n    const upper = __WEBPACK_IMPORTED_MODULE_4__svgParts__[\"i\" /* createUpper */](svg, boxX, boxY, boxBbox.width/2, 0);\r\n    upper.data({\"index\": node.index});\r\n    this.group.add(upper);\r\n\r\n    const numLower = node.type === 'if'? 3:2;\r\n    let tmp=null;\r\n    [this.lowerPlug, tmp] = __WEBPACK_IMPORTED_MODULE_4__svgParts__[\"e\" /* createLower */](svg, boxX, boxY, boxBbox.width/numLower, boxBbox.height, __WEBPACK_IMPORTED_MODULE_3__config___default.a.plug_color.flow, sio);\r\n    this.lowerPlug.data({\"next\": node.next});\r\n    this.group.add(this.lowerPlug).add(tmp);\r\n\r\n    this.connectors=[];\r\n    node.outputFiles.forEach((output, fileIndex) => {\r\n      let [plug, cable]= __WEBPACK_IMPORTED_MODULE_4__svgParts__[\"c\" /* createConnector */](svg, boxX, boxY, boxBbox.width, textHeight*fileIndex, sio);\r\n      plug.data({\"name\": output.name, \"dst\": output.dst});\r\n      this.group.add(plug);\r\n      this.group.add(cable);\r\n      this.connectors.push(plug);\r\n    });\r\n\r\n    node.inputFiles.forEach((input, fileIndex) => {\r\n      const receptor = __WEBPACK_IMPORTED_MODULE_4__svgParts__[\"h\" /* createReceptor */](svg, boxX, boxY, 0, textHeight*fileIndex);\r\n      receptor.data({\"index\": node.index, \"name\": input.name});\r\n      this.group.add(receptor);\r\n    });\r\n\r\n    if(numLower === 3){\r\n      [this.lower2Plug, tmp] = __WEBPACK_IMPORTED_MODULE_4__svgParts__[\"e\" /* createLower */](svg, boxX, boxY, boxBbox.width/numLower*2, boxBbox.height, __WEBPACK_IMPORTED_MODULE_3__config___default.a.plug_color.elseFlow, sio)\r\n      this.lower2Plug.addClass('elsePlug').data({\"else\": node.else});\r\n      this.group.add(this.lower2Plug).add(tmp);\r\n    }\r\n\r\n    if(node != null && node.jsonFile != null){\r\n      this.group.data({\"path\": node.path, \"jsonFile\": node.jsonFile});\r\n    }\r\n\r\n    // difference between box origin and mouse pointer\r\n    let diffX=0;\r\n    let diffY=0;\r\n    // mouse pointer coordinate on dragstart\r\n    let startX=0;\r\n    let startY=0;\r\n    // register drag and drop behavior\r\n    this.group\r\n      .on('dragstart',(e)=>{\r\n        diffX=e.detail.p.x - e.target.instance.select('.box').first().x();\r\n        diffY=e.detail.p.y - e.target.instance.select('.box').first().y()\r\n        startX = e.detail.p.x;\r\n        startY = e.detail.p.y;\r\n      })\r\n      .on('dragmove', (e)=>{\r\n        let dx = e.detail.p.x - startX;\r\n        let dy = e.detail.p.y - startY;\r\n        this.reDrawLinks(dx, dy)\r\n      })\r\n      .on('dragend', (e)=>{\r\n        let x = e.detail.p.x;\r\n        let y = e.detail.p.y;\r\n        if(x !== startX || y !== startY){\r\n          sio.emit('updateNode', {index: node.index, property: 'pos', value: {'x': x-diffX, 'y': y-diffY}, cmd: 'update'});\r\n        }\r\n      });\r\n  }\r\n\r\n  /**\r\n   * draw cables between Lower-Upper and Connector-Receptor respectively\r\n   */\r\n  drawLinks(){\r\n    let boxBbox=this.group.data('boxBbox');\r\n    let upperPlugs=this.svg.select('.upperPlug');\r\n    let srcPlug=this.lowerPlug;\r\n    srcPlug.data('next').forEach((dstIndex)=>{\r\n      let dstPlug = upperPlugs.members.find((plug)=>{\r\n        return plug.data('index') === dstIndex;\r\n      });\r\n      const cable = new __WEBPACK_IMPORTED_MODULE_4__svgParts__[\"a\" /* SvgCable */](this.svg, __WEBPACK_IMPORTED_MODULE_3__config___default.a.plug_color.flow, 'DU', srcPlug.cx(), srcPlug.cy(), dstPlug.cx(), dstPlug.cy());\r\n      cable._draw(cable.startX, cable.startY, cable.endX, cable.endY, boxBbox);\r\n      cable.cable.data('dst', dstIndex);\r\n      this.nextLinks.push(cable);\r\n    });\r\n    if(this.hasOwnProperty('lower2Plug')){\r\n      let srcPlug=this.lower2Plug;\r\n      srcPlug.data('else').forEach((dstIndex)=>{\r\n        let dstPlug = upperPlugs.members.find((plug)=>{\r\n          return plug.data('index') === dstIndex;\r\n        });\r\n        const cable = new __WEBPACK_IMPORTED_MODULE_4__svgParts__[\"a\" /* SvgCable */](this.svg, __WEBPACK_IMPORTED_MODULE_3__config___default.a.plug_color.elseFlow, 'DU', srcPlug.cx(), srcPlug.cy(), dstPlug.cx(), dstPlug.cy());\r\n        cable._draw(cable.startX, cable.startY, cable.endX, cable.endY, boxBbox);\r\n        cable.cable.data('dst', dstIndex);\r\n        this.elseLinks.push(cable);\r\n      });\r\n    }\r\n    let receptorPlugs=this.svg.select('.receptorPlug');\r\n    console.log(receptorPlugs);\r\n    \r\n    this.connectors.forEach((srcPlug)=>{\r\n      console.log(this.connectors);\r\n      console.log(srcPlug.data('dst'));  \r\n      srcPlug.data('dst').forEach((dst)=>{\r\n        let dstPlug = receptorPlugs.members.find((plug)=>{\r\n          return plug.data('index') === dst.dstNode && plug.data('name') === dst.dstName;\r\n        });\r\n        console.log(dstPlug);\r\n        \r\n        const cable = new __WEBPACK_IMPORTED_MODULE_4__svgParts__[\"a\" /* SvgCable */](this.svg, __WEBPACK_IMPORTED_MODULE_3__config___default.a.plug_color.file, 'RL', srcPlug.cx(), srcPlug.cy(), dstPlug.cx(), dstPlug.cy());\r\n        cable._draw(cable.startX, cable.startY, cable.endX, cable.endY, boxBbox);\r\n        cable.cable.data('dst', dst.dstNode);\r\n        this.outputFileLinks.push(cable);\r\n      });\r\n    });\r\n  }\r\n  /**\r\n   * redraw cables between Lower-Upper and Connector-Receptor respectively\r\n   * @param offsetX x coordinate difference from dragstart\r\n   * @param offsetY y coordinate difference from dragstart\r\n   */\r\n  reDrawLinks(offsetX, offsetY){\r\n    let boxBbox=this.group.data('boxBbox');\r\n    this.nextLinks.forEach((v)=>{\r\n      v.dragStartPoint(offsetX, offsetY, boxBbox);\r\n    });\r\n    this.elseLinks.forEach((v)=>{\r\n      v.dragStartPoint(offsetX, offsetY, boxBbox);\r\n    });\r\n    this.outputFileLinks.forEach((v)=>{\r\n      v.dragStartPoint(offsetX, offsetY, boxBbox);\r\n    });\r\n    this.previousLinks.forEach((v)=>{\r\n      v.dragEndPoint(offsetX, offsetY, boxBbox);\r\n    });\r\n    this.inputFileLinks.forEach((v)=>{\r\n      v.dragEndPoint(offsetX, offsetY, boxBbox);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * delete svg element of this node\r\n   */\r\n  remove(){\r\n    this.group.remove();\r\n    this.nextLinks.forEach((v)=>{\r\n      v.cable.remove();\r\n    });\r\n    this.elseLinks.forEach((v)=>{\r\n      v.cable.remove();\r\n    });\r\n    this.outputFileLinks.forEach((v)=>{\r\n      v.cable.remove();\r\n    });\r\n    this.previousLinks.forEach((v)=>{\r\n      v.cable.remove();\r\n    });\r\n    this.inputFileLinks.forEach((v)=>{\r\n      v.cable.remove();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * register callback function to 'mousedown' event\r\n   */\r\n  onMousedown(callback){\r\n    this.group.on('mousedown', callback);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * register callback function to 'dblclick' event\r\n   */\r\n  onDblclick(callback){\r\n    this.group.on('dblclick', callback);\r\n    return this;\r\n  }\r\n\r\n  onClick(callback){\r\n    this.group.on('click', callback);\r\n    return this;\r\n  }\r\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = SvgNodeUI;\n\r\n\r\n/**\r\n * svg parent node\r\n */\r\nclass SvgParentNodeUI{\r\n  /**\r\n   * create new instance\r\n   * @param svg  svg.js's instance\r\n   * @param sio  socket.io's instance\r\n   * @param parentnode parent inputFiles instance to draw\r\n   */\r\n  constructor(svg, sio, parentnode) {\r\n    /** svg.js's instance*/\r\n    this.svg=svg;\r\n\r\n    /** cable instance container */\r\n    this.outputFileLinks=[];\r\n    this.inputFileLinks=[];\r\n\r\n    /** svg representation of this node */\r\n    this.group=svg.group();\r\n   //this.group.data({\"index\": parentnode.index, \"type\": parentnode.type}).draggable().addClass('parentnode');\r\n\r\n    // draw input output file name\r\n    // draw node\r\n    const [box, textHeight]= __WEBPACK_IMPORTED_MODULE_4__svgParts__[\"d\" /* createFilesNameBox */](svg, 36, 0, parentnode.type, parentnode.name, parentnode.inputFiles, parentnode.outputFiles); \r\n    const boxBbox=box.bbox();\r\n    const boxX=box.x();\r\n    const boxY=box.y();\r\n    this.group.add(box);\r\n    this.group.data({\"boxBbox\": boxBbox});\r\n\r\n    // draw connector\r\n    this.connectors=[];\r\n    //parentnode.outputFiles.forEach((output, fileIndex) => {\r\n    parentnode.inputFiles.forEach((input, fileIndex) => {        \r\n      let [plug, cable]= __WEBPACK_IMPORTED_MODULE_4__svgParts__[\"f\" /* createParentConnector */](svg, 32, 40, 0, 40*fileIndex, sio);\r\n      //const boxBbox=plug.bbox();  \r\n      //plug.data({\"name\": output.name, \"dst\": output.dst});\r\n      let dstArray = [];\r\n      if (input.srcName === null){\r\n        dstArray = [];\r\n      } else {\r\n        dstArray = [input.srcNode, input.srcName];\r\n      }\r\n      plug.data({\"name\": input.name, \"dst\": dstArray});\r\n      console.log(input);\r\n      \r\n      this.group.add(plug);\r\n      this.group.add(cable);\r\n      this.connectors.push(plug);\r\n      console.log(plug);\r\n      \r\n    });\r\n    console.log(this.connectors);\r\n    \r\n    // draw receptor\r\n    //parentnode.inputFiles.forEach((input, fileIndex) => {      \r\n    parentnode.outputFiles.forEach((output, fileIndex) => {\r\n      const receptor = __WEBPACK_IMPORTED_MODULE_4__svgParts__[\"g\" /* createParentReceptor */](svg, 16, 800, 0, 40*fileIndex);\r\n      //receptor.data({\"index\": parentnode.index, \"name\": output.name});\r\n      receptor.data({\"index\": \"parent\", \"name\": output.name});\r\n      console.log(\"receptor\");      \r\n      console.log(receptor);\r\n      \r\n      this.group.add(receptor);\r\n    });\r\n\r\n    // difference between box origin and mouse pointer\r\n    let diffX=0;\r\n    let diffY=0;\r\n    // mouse pointer coordinate on dragstart\r\n    let startX=0;\r\n    let startY=0;\r\n    // register drag and drop behavior\r\n    this.group\r\n      .on('dragstart',(e)=>{\r\n        diffX=e.detail.p.x - e.target.instance.select('.box').first().x();\r\n        diffY=e.detail.p.y - e.target.instance.select('.box').first().y()\r\n        startX = e.detail.p.x;\r\n        startY = e.detail.p.y;\r\n      })\r\n      .on('dragmove', (e)=>{\r\n        let dx = e.detail.p.x - startX;\r\n        let dy = e.detail.p.y - startY;\r\n        this.reDrawParentLinks(dx, dy)\r\n      })\r\n      .on('dragend', (e)=>{\r\n        let x = e.detail.p.x;\r\n        let y = e.detail.p.y;\r\n        if(x !== startX || y !== startY){\r\n          sio.emit('updateNode', {index: parentnode.index, property: 'pos', value: {'x': x-diffX, 'y': y-diffY}, cmd: 'update'});\r\n        }\r\n      });\r\n  }\r\n\r\n  /**\r\n   * draw Connector-Receptor\r\n   */\r\n  drawParentLinks(){\r\n    let boxBbox=this.group.data('boxBbox');\r\n\r\n    let receptorPlugs=this.svg.select('.receptorPlug');\r\n    console.log(\"receptorPlugs\");\r\n    \r\n    console.log(receptorPlugs);\r\n    this.connectors.forEach((srcPlug)=>{\r\n      console.log(this.connectors);\r\n      console.log(srcPlug.data('dst'));      \r\n      srcPlug.data('dst').forEach((dst)=>{\r\n        //console.log(srcPlug.data('dst'));\r\n        \r\n        let dstPlug = receptorPlugs.members.find((plug)=>{\r\n          return plug.data('index') === dst.dstNode && plug.data('name') === dst.dstName;\r\n        });\r\n        console.log(dst);\r\n        console.log(dstPlug);\r\n        \r\n        const cable = new __WEBPACK_IMPORTED_MODULE_4__svgParts__[\"a\" /* SvgCable */](this.svg, __WEBPACK_IMPORTED_MODULE_3__config___default.a.plug_color.file, 'RL', srcPlug.cx(), srcPlug.cy(), dstPlug.cx(), dstPlug.cy());\r\n        console.log(cable);\r\n        cable._draw(cable.startX, cable.startY, cable.endX, cable.endY, boxBbox);\r\n        cable.cable.data('dst', dst.dstNode);\r\n        this.outputFileLinks.push(cable);\r\n      });\r\n    });\r\n  }\r\n  /**\r\n   * redraw cables between Lower-Upper and Connector-Receptor respectively\r\n   * @param offsetX x coordinate difference from dragstart\r\n   * @param offsetY y coordinate difference from dragstart\r\n   */\r\n  reDrawParentLinks(offsetX, offsetY){\r\n    let boxBbox=this.group.data('boxBbox');\r\n    this.outputFileLinks.forEach((v)=>{\r\n      v.dragStartPoint(offsetX, offsetY, boxBbox);\r\n    });\r\n    this.inputFileLinks.forEach((v)=>{\r\n      v.dragEndPoint(offsetX, offsetY, boxBbox);\r\n    });\r\n  }\r\n\r\n    /**\r\n   * delete svg element of this node\r\n   */\r\n  remove(){\r\n    this.group.remove();\r\n    this.outputFileLinks.forEach((v)=>{\r\n      v.cable.remove();\r\n    });\r\n    this.inputFileLinks.forEach((v)=>{\r\n      v.cable.remove();\r\n    });\r\n  }\r\n\r\n    /**\r\n   * register callback function to 'mousedown' event\r\n   */\r\n  onMousedown(callback){\r\n    this.group.on('mousedown', callback);\r\n    return this;\r\n  }\r\n\r\n}\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = SvgParentNodeUI;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2pzL3N2Z05vZGVVSS5qcz9lMTdhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsdUNBQXVDOztBQUU1RDtBQUNBLHlQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1COztBQUV4QztBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUNBQXVDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHFCQUFxQix3Q0FBd0M7QUFDN0Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxpREFBaUQsa0JBQWtCO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsNkNBQTZDO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRDQUE0QywyQkFBMkIsZ0JBQWdCO0FBQ3pIO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLG1EQUFtRDs7QUFFekU7QUFDQTtBQUNBLGdNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQSx5RDtBQUNBO0FBQ0Esa0M7QUFDQSxtQkFBbUIsdUNBQXVDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSwyRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQStDO0FBQ3RFLHFCQUFxQix1Q0FBdUM7QUFDNUQsOEI7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0RBQWtELDJCQUEyQixnQkFBZ0I7QUFDL0g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEMiLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU1ZHIGZyb20gJ3N2Z2pzL2Rpc3Qvc3ZnLmpzJztcclxuaW1wb3J0ICdzdmcuZHJhZ2dhYmxlLmpzL2Rpc3Qvc3ZnLmRyYWdnYWJsZS5qcyc7XHJcbmltcG9ydCAnLi4vY3NzL3dvcmtmbG93LmNzcyc7XHJcblxyXG5pbXBvcnQgY29uZmlnIGZyb20gJy4vY29uZmlnJztcclxuaW1wb3J0ICogYXMgcGFydHMgZnJvbSAnLi9zdmdQYXJ0cyc7XHJcblxyXG4vKipcclxuICogc3ZnIG5vZGVcclxuICovXHJcbi8vZXhwb3J0IGRlZmF1bHQgY2xhc3N7XHJcbiAgZXhwb3J0IGNsYXNzIFN2Z05vZGVVSXtcclxuICAvKipcclxuICAgKiBjcmVhdGUgbmV3IGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHN2ZyAgc3ZnLmpzJ3MgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gc2lvICBzb2NrZXQuaW8ncyBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSBub2RlIGFueSBub2RlIGluc3RhbmNlIHRvIGRyYXdcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihzdmcsIHNpbywgbm9kZSkge1xyXG4gICAgLyoqIHN2Zy5qcydzIGluc3RhbmNlKi9cclxuICAgIHRoaXMuc3ZnPXN2ZztcclxuXHJcbiAgICAvKiogY2FibGUgaW5zdGFuY2UgY29udGFpbmVyICovXHJcbiAgICB0aGlzLm5leHRMaW5rcz1bXTtcclxuICAgIHRoaXMuZWxzZUxpbmtzPVtdO1xyXG4gICAgdGhpcy5wcmV2aW91c0xpbmtzPVtdO1xyXG4gICAgdGhpcy5vdXRwdXRGaWxlTGlua3M9W107XHJcbiAgICB0aGlzLmlucHV0RmlsZUxpbmtzPVtdO1xyXG5cclxuICAgIC8qKiBzdmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlICovXHJcbiAgICB0aGlzLmdyb3VwPXN2Zy5ncm91cCgpO1xyXG4gICAgdGhpcy5ncm91cC5kYXRhKHtcImluZGV4XCI6IG5vZGUuaW5kZXgsIFwidHlwZVwiOiBub2RlLnR5cGV9KS5kcmFnZ2FibGUoKS5hZGRDbGFzcygnbm9kZScpO1xyXG5cclxuICAgIC8vIGRyYXcgbm9kZVxyXG4gICAgY29uc3QgW2JveCwgdGV4dEhlaWdodF09IHBhcnRzLmNyZWF0ZUJveChzdmcsIG5vZGUucG9zLngsIG5vZGUucG9zLnksIG5vZGUudHlwZSwgbm9kZS5uYW1lLCBub2RlLmlucHV0RmlsZXMsIG5vZGUub3V0cHV0RmlsZXMsIG5vZGUuc3RhdGUsIG5vZGUubm9kZXMsIG5vZGUubnVtVG90YWwsIG5vZGUubnVtRmluaXNoZWQsIG5vZGUubnVtRmFpbGVkKTsgXHJcbiAgICBjb25zdCBib3hCYm94PWJveC5iYm94KCk7XHJcbiAgICBjb25zdCBib3hYPWJveC54KCk7XHJcbiAgICBjb25zdCBib3hZPWJveC55KCk7XHJcbiAgICB0aGlzLmdyb3VwLmFkZChib3gpO1xyXG4gICAgdGhpcy5ncm91cC5kYXRhKHtcImJveEJib3hcIjogYm94QmJveH0pO1xyXG4gICAgXHJcbiAgICBjb25zdCB1cHBlciA9IHBhcnRzLmNyZWF0ZVVwcGVyKHN2ZywgYm94WCwgYm94WSwgYm94QmJveC53aWR0aC8yLCAwKTtcclxuICAgIHVwcGVyLmRhdGEoe1wiaW5kZXhcIjogbm9kZS5pbmRleH0pO1xyXG4gICAgdGhpcy5ncm91cC5hZGQodXBwZXIpO1xyXG5cclxuICAgIGNvbnN0IG51bUxvd2VyID0gbm9kZS50eXBlID09PSAnaWYnPyAzOjI7XHJcbiAgICBsZXQgdG1wPW51bGw7XHJcbiAgICBbdGhpcy5sb3dlclBsdWcsIHRtcF0gPSBwYXJ0cy5jcmVhdGVMb3dlcihzdmcsIGJveFgsIGJveFksIGJveEJib3gud2lkdGgvbnVtTG93ZXIsIGJveEJib3guaGVpZ2h0LCBjb25maWcucGx1Z19jb2xvci5mbG93LCBzaW8pO1xyXG4gICAgdGhpcy5sb3dlclBsdWcuZGF0YSh7XCJuZXh0XCI6IG5vZGUubmV4dH0pO1xyXG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5sb3dlclBsdWcpLmFkZCh0bXApO1xyXG5cclxuICAgIHRoaXMuY29ubmVjdG9ycz1bXTtcclxuICAgIG5vZGUub3V0cHV0RmlsZXMuZm9yRWFjaCgob3V0cHV0LCBmaWxlSW5kZXgpID0+IHtcclxuICAgICAgbGV0IFtwbHVnLCBjYWJsZV09IHBhcnRzLmNyZWF0ZUNvbm5lY3RvcihzdmcsIGJveFgsIGJveFksIGJveEJib3gud2lkdGgsIHRleHRIZWlnaHQqZmlsZUluZGV4LCBzaW8pO1xyXG4gICAgICBwbHVnLmRhdGEoe1wibmFtZVwiOiBvdXRwdXQubmFtZSwgXCJkc3RcIjogb3V0cHV0LmRzdH0pO1xyXG4gICAgICB0aGlzLmdyb3VwLmFkZChwbHVnKTtcclxuICAgICAgdGhpcy5ncm91cC5hZGQoY2FibGUpO1xyXG4gICAgICB0aGlzLmNvbm5lY3RvcnMucHVzaChwbHVnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIG5vZGUuaW5wdXRGaWxlcy5mb3JFYWNoKChpbnB1dCwgZmlsZUluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlY2VwdG9yID0gcGFydHMuY3JlYXRlUmVjZXB0b3Ioc3ZnLCBib3hYLCBib3hZLCAwLCB0ZXh0SGVpZ2h0KmZpbGVJbmRleCk7XHJcbiAgICAgIHJlY2VwdG9yLmRhdGEoe1wiaW5kZXhcIjogbm9kZS5pbmRleCwgXCJuYW1lXCI6IGlucHV0Lm5hbWV9KTtcclxuICAgICAgdGhpcy5ncm91cC5hZGQocmVjZXB0b3IpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYobnVtTG93ZXIgPT09IDMpe1xyXG4gICAgICBbdGhpcy5sb3dlcjJQbHVnLCB0bXBdID0gcGFydHMuY3JlYXRlTG93ZXIoc3ZnLCBib3hYLCBib3hZLCBib3hCYm94LndpZHRoL251bUxvd2VyKjIsIGJveEJib3guaGVpZ2h0LCBjb25maWcucGx1Z19jb2xvci5lbHNlRmxvdywgc2lvKVxyXG4gICAgICB0aGlzLmxvd2VyMlBsdWcuYWRkQ2xhc3MoJ2Vsc2VQbHVnJykuZGF0YSh7XCJlbHNlXCI6IG5vZGUuZWxzZX0pO1xyXG4gICAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLmxvd2VyMlBsdWcpLmFkZCh0bXApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKG5vZGUgIT0gbnVsbCAmJiBub2RlLmpzb25GaWxlICE9IG51bGwpe1xyXG4gICAgICB0aGlzLmdyb3VwLmRhdGEoe1wicGF0aFwiOiBub2RlLnBhdGgsIFwianNvbkZpbGVcIjogbm9kZS5qc29uRmlsZX0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRpZmZlcmVuY2UgYmV0d2VlbiBib3ggb3JpZ2luIGFuZCBtb3VzZSBwb2ludGVyXHJcbiAgICBsZXQgZGlmZlg9MDtcclxuICAgIGxldCBkaWZmWT0wO1xyXG4gICAgLy8gbW91c2UgcG9pbnRlciBjb29yZGluYXRlIG9uIGRyYWdzdGFydFxyXG4gICAgbGV0IHN0YXJ0WD0wO1xyXG4gICAgbGV0IHN0YXJ0WT0wO1xyXG4gICAgLy8gcmVnaXN0ZXIgZHJhZyBhbmQgZHJvcCBiZWhhdmlvclxyXG4gICAgdGhpcy5ncm91cFxyXG4gICAgICAub24oJ2RyYWdzdGFydCcsKGUpPT57XHJcbiAgICAgICAgZGlmZlg9ZS5kZXRhaWwucC54IC0gZS50YXJnZXQuaW5zdGFuY2Uuc2VsZWN0KCcuYm94JykuZmlyc3QoKS54KCk7XHJcbiAgICAgICAgZGlmZlk9ZS5kZXRhaWwucC55IC0gZS50YXJnZXQuaW5zdGFuY2Uuc2VsZWN0KCcuYm94JykuZmlyc3QoKS55KClcclxuICAgICAgICBzdGFydFggPSBlLmRldGFpbC5wLng7XHJcbiAgICAgICAgc3RhcnRZID0gZS5kZXRhaWwucC55O1xyXG4gICAgICB9KVxyXG4gICAgICAub24oJ2RyYWdtb3ZlJywgKGUpPT57XHJcbiAgICAgICAgbGV0IGR4ID0gZS5kZXRhaWwucC54IC0gc3RhcnRYO1xyXG4gICAgICAgIGxldCBkeSA9IGUuZGV0YWlsLnAueSAtIHN0YXJ0WTtcclxuICAgICAgICB0aGlzLnJlRHJhd0xpbmtzKGR4LCBkeSlcclxuICAgICAgfSlcclxuICAgICAgLm9uKCdkcmFnZW5kJywgKGUpPT57XHJcbiAgICAgICAgbGV0IHggPSBlLmRldGFpbC5wLng7XHJcbiAgICAgICAgbGV0IHkgPSBlLmRldGFpbC5wLnk7XHJcbiAgICAgICAgaWYoeCAhPT0gc3RhcnRYIHx8IHkgIT09IHN0YXJ0WSl7XHJcbiAgICAgICAgICBzaW8uZW1pdCgndXBkYXRlTm9kZScsIHtpbmRleDogbm9kZS5pbmRleCwgcHJvcGVydHk6ICdwb3MnLCB2YWx1ZTogeyd4JzogeC1kaWZmWCwgJ3knOiB5LWRpZmZZfSwgY21kOiAndXBkYXRlJ30pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBkcmF3IGNhYmxlcyBiZXR3ZWVuIExvd2VyLVVwcGVyIGFuZCBDb25uZWN0b3ItUmVjZXB0b3IgcmVzcGVjdGl2ZWx5XHJcbiAgICovXHJcbiAgZHJhd0xpbmtzKCl7XHJcbiAgICBsZXQgYm94QmJveD10aGlzLmdyb3VwLmRhdGEoJ2JveEJib3gnKTtcclxuICAgIGxldCB1cHBlclBsdWdzPXRoaXMuc3ZnLnNlbGVjdCgnLnVwcGVyUGx1ZycpO1xyXG4gICAgbGV0IHNyY1BsdWc9dGhpcy5sb3dlclBsdWc7XHJcbiAgICBzcmNQbHVnLmRhdGEoJ25leHQnKS5mb3JFYWNoKChkc3RJbmRleCk9PntcclxuICAgICAgbGV0IGRzdFBsdWcgPSB1cHBlclBsdWdzLm1lbWJlcnMuZmluZCgocGx1Zyk9PntcclxuICAgICAgICByZXR1cm4gcGx1Zy5kYXRhKCdpbmRleCcpID09PSBkc3RJbmRleDtcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IGNhYmxlID0gbmV3IHBhcnRzLlN2Z0NhYmxlKHRoaXMuc3ZnLCBjb25maWcucGx1Z19jb2xvci5mbG93LCAnRFUnLCBzcmNQbHVnLmN4KCksIHNyY1BsdWcuY3koKSwgZHN0UGx1Zy5jeCgpLCBkc3RQbHVnLmN5KCkpO1xyXG4gICAgICBjYWJsZS5fZHJhdyhjYWJsZS5zdGFydFgsIGNhYmxlLnN0YXJ0WSwgY2FibGUuZW5kWCwgY2FibGUuZW5kWSwgYm94QmJveCk7XHJcbiAgICAgIGNhYmxlLmNhYmxlLmRhdGEoJ2RzdCcsIGRzdEluZGV4KTtcclxuICAgICAgdGhpcy5uZXh0TGlua3MucHVzaChjYWJsZSk7XHJcbiAgICB9KTtcclxuICAgIGlmKHRoaXMuaGFzT3duUHJvcGVydHkoJ2xvd2VyMlBsdWcnKSl7XHJcbiAgICAgIGxldCBzcmNQbHVnPXRoaXMubG93ZXIyUGx1ZztcclxuICAgICAgc3JjUGx1Zy5kYXRhKCdlbHNlJykuZm9yRWFjaCgoZHN0SW5kZXgpPT57XHJcbiAgICAgICAgbGV0IGRzdFBsdWcgPSB1cHBlclBsdWdzLm1lbWJlcnMuZmluZCgocGx1Zyk9PntcclxuICAgICAgICAgIHJldHVybiBwbHVnLmRhdGEoJ2luZGV4JykgPT09IGRzdEluZGV4O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGNhYmxlID0gbmV3IHBhcnRzLlN2Z0NhYmxlKHRoaXMuc3ZnLCBjb25maWcucGx1Z19jb2xvci5lbHNlRmxvdywgJ0RVJywgc3JjUGx1Zy5jeCgpLCBzcmNQbHVnLmN5KCksIGRzdFBsdWcuY3goKSwgZHN0UGx1Zy5jeSgpKTtcclxuICAgICAgICBjYWJsZS5fZHJhdyhjYWJsZS5zdGFydFgsIGNhYmxlLnN0YXJ0WSwgY2FibGUuZW5kWCwgY2FibGUuZW5kWSwgYm94QmJveCk7XHJcbiAgICAgICAgY2FibGUuY2FibGUuZGF0YSgnZHN0JywgZHN0SW5kZXgpO1xyXG4gICAgICAgIHRoaXMuZWxzZUxpbmtzLnB1c2goY2FibGUpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGxldCByZWNlcHRvclBsdWdzPXRoaXMuc3ZnLnNlbGVjdCgnLnJlY2VwdG9yUGx1ZycpO1xyXG4gICAgY29uc29sZS5sb2cocmVjZXB0b3JQbHVncyk7XHJcbiAgICBcclxuICAgIHRoaXMuY29ubmVjdG9ycy5mb3JFYWNoKChzcmNQbHVnKT0+e1xyXG4gICAgICBjb25zb2xlLmxvZyh0aGlzLmNvbm5lY3RvcnMpO1xyXG4gICAgICBjb25zb2xlLmxvZyhzcmNQbHVnLmRhdGEoJ2RzdCcpKTsgIFxyXG4gICAgICBzcmNQbHVnLmRhdGEoJ2RzdCcpLmZvckVhY2goKGRzdCk9PntcclxuICAgICAgICBsZXQgZHN0UGx1ZyA9IHJlY2VwdG9yUGx1Z3MubWVtYmVycy5maW5kKChwbHVnKT0+e1xyXG4gICAgICAgICAgcmV0dXJuIHBsdWcuZGF0YSgnaW5kZXgnKSA9PT0gZHN0LmRzdE5vZGUgJiYgcGx1Zy5kYXRhKCduYW1lJykgPT09IGRzdC5kc3ROYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGRzdFBsdWcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGNhYmxlID0gbmV3IHBhcnRzLlN2Z0NhYmxlKHRoaXMuc3ZnLCBjb25maWcucGx1Z19jb2xvci5maWxlLCAnUkwnLCBzcmNQbHVnLmN4KCksIHNyY1BsdWcuY3koKSwgZHN0UGx1Zy5jeCgpLCBkc3RQbHVnLmN5KCkpO1xyXG4gICAgICAgIGNhYmxlLl9kcmF3KGNhYmxlLnN0YXJ0WCwgY2FibGUuc3RhcnRZLCBjYWJsZS5lbmRYLCBjYWJsZS5lbmRZLCBib3hCYm94KTtcclxuICAgICAgICBjYWJsZS5jYWJsZS5kYXRhKCdkc3QnLCBkc3QuZHN0Tm9kZSk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRGaWxlTGlua3MucHVzaChjYWJsZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIHJlZHJhdyBjYWJsZXMgYmV0d2VlbiBMb3dlci1VcHBlciBhbmQgQ29ubmVjdG9yLVJlY2VwdG9yIHJlc3BlY3RpdmVseVxyXG4gICAqIEBwYXJhbSBvZmZzZXRYIHggY29vcmRpbmF0ZSBkaWZmZXJlbmNlIGZyb20gZHJhZ3N0YXJ0XHJcbiAgICogQHBhcmFtIG9mZnNldFkgeSBjb29yZGluYXRlIGRpZmZlcmVuY2UgZnJvbSBkcmFnc3RhcnRcclxuICAgKi9cclxuICByZURyYXdMaW5rcyhvZmZzZXRYLCBvZmZzZXRZKXtcclxuICAgIGxldCBib3hCYm94PXRoaXMuZ3JvdXAuZGF0YSgnYm94QmJveCcpO1xyXG4gICAgdGhpcy5uZXh0TGlua3MuZm9yRWFjaCgodik9PntcclxuICAgICAgdi5kcmFnU3RhcnRQb2ludChvZmZzZXRYLCBvZmZzZXRZLCBib3hCYm94KTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5lbHNlTGlua3MuZm9yRWFjaCgodik9PntcclxuICAgICAgdi5kcmFnU3RhcnRQb2ludChvZmZzZXRYLCBvZmZzZXRZLCBib3hCYm94KTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5vdXRwdXRGaWxlTGlua3MuZm9yRWFjaCgodik9PntcclxuICAgICAgdi5kcmFnU3RhcnRQb2ludChvZmZzZXRYLCBvZmZzZXRZLCBib3hCYm94KTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5wcmV2aW91c0xpbmtzLmZvckVhY2goKHYpPT57XHJcbiAgICAgIHYuZHJhZ0VuZFBvaW50KG9mZnNldFgsIG9mZnNldFksIGJveEJib3gpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmlucHV0RmlsZUxpbmtzLmZvckVhY2goKHYpPT57XHJcbiAgICAgIHYuZHJhZ0VuZFBvaW50KG9mZnNldFgsIG9mZnNldFksIGJveEJib3gpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBkZWxldGUgc3ZnIGVsZW1lbnQgb2YgdGhpcyBub2RlXHJcbiAgICovXHJcbiAgcmVtb3ZlKCl7XHJcbiAgICB0aGlzLmdyb3VwLnJlbW92ZSgpO1xyXG4gICAgdGhpcy5uZXh0TGlua3MuZm9yRWFjaCgodik9PntcclxuICAgICAgdi5jYWJsZS5yZW1vdmUoKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5lbHNlTGlua3MuZm9yRWFjaCgodik9PntcclxuICAgICAgdi5jYWJsZS5yZW1vdmUoKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5vdXRwdXRGaWxlTGlua3MuZm9yRWFjaCgodik9PntcclxuICAgICAgdi5jYWJsZS5yZW1vdmUoKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5wcmV2aW91c0xpbmtzLmZvckVhY2goKHYpPT57XHJcbiAgICAgIHYuY2FibGUucmVtb3ZlKCk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuaW5wdXRGaWxlTGlua3MuZm9yRWFjaCgodik9PntcclxuICAgICAgdi5jYWJsZS5yZW1vdmUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogcmVnaXN0ZXIgY2FsbGJhY2sgZnVuY3Rpb24gdG8gJ21vdXNlZG93bicgZXZlbnRcclxuICAgKi9cclxuICBvbk1vdXNlZG93bihjYWxsYmFjayl7XHJcbiAgICB0aGlzLmdyb3VwLm9uKCdtb3VzZWRvd24nLCBjYWxsYmFjayk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHJlZ2lzdGVyIGNhbGxiYWNrIGZ1bmN0aW9uIHRvICdkYmxjbGljaycgZXZlbnRcclxuICAgKi9cclxuICBvbkRibGNsaWNrKGNhbGxiYWNrKXtcclxuICAgIHRoaXMuZ3JvdXAub24oJ2RibGNsaWNrJywgY2FsbGJhY2spO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBvbkNsaWNrKGNhbGxiYWNrKXtcclxuICAgIHRoaXMuZ3JvdXAub24oJ2NsaWNrJywgY2FsbGJhY2spO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogc3ZnIHBhcmVudCBub2RlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU3ZnUGFyZW50Tm9kZVVJe1xyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSBuZXcgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gc3ZnICBzdmcuanMncyBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSBzaW8gIHNvY2tldC5pbydzIGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHBhcmVudG5vZGUgcGFyZW50IGlucHV0RmlsZXMgaW5zdGFuY2UgdG8gZHJhd1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHN2Zywgc2lvLCBwYXJlbnRub2RlKSB7XHJcbiAgICAvKiogc3ZnLmpzJ3MgaW5zdGFuY2UqL1xyXG4gICAgdGhpcy5zdmc9c3ZnO1xyXG5cclxuICAgIC8qKiBjYWJsZSBpbnN0YW5jZSBjb250YWluZXIgKi9cclxuICAgIHRoaXMub3V0cHV0RmlsZUxpbmtzPVtdO1xyXG4gICAgdGhpcy5pbnB1dEZpbGVMaW5rcz1bXTtcclxuXHJcbiAgICAvKiogc3ZnIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZSAqL1xyXG4gICAgdGhpcy5ncm91cD1zdmcuZ3JvdXAoKTtcclxuICAgLy90aGlzLmdyb3VwLmRhdGEoe1wiaW5kZXhcIjogcGFyZW50bm9kZS5pbmRleCwgXCJ0eXBlXCI6IHBhcmVudG5vZGUudHlwZX0pLmRyYWdnYWJsZSgpLmFkZENsYXNzKCdwYXJlbnRub2RlJyk7XHJcblxyXG4gICAgLy8gZHJhdyBpbnB1dCBvdXRwdXQgZmlsZSBuYW1lXHJcbiAgICAvLyBkcmF3IG5vZGVcclxuICAgIGNvbnN0IFtib3gsIHRleHRIZWlnaHRdPSBwYXJ0cy5jcmVhdGVGaWxlc05hbWVCb3goc3ZnLCAzNiwgMCwgcGFyZW50bm9kZS50eXBlLCBwYXJlbnRub2RlLm5hbWUsIHBhcmVudG5vZGUuaW5wdXRGaWxlcywgcGFyZW50bm9kZS5vdXRwdXRGaWxlcyk7IFxyXG4gICAgY29uc3QgYm94QmJveD1ib3guYmJveCgpO1xyXG4gICAgY29uc3QgYm94WD1ib3gueCgpO1xyXG4gICAgY29uc3QgYm94WT1ib3gueSgpO1xyXG4gICAgdGhpcy5ncm91cC5hZGQoYm94KTtcclxuICAgIHRoaXMuZ3JvdXAuZGF0YSh7XCJib3hCYm94XCI6IGJveEJib3h9KTtcclxuXHJcbiAgICAvLyBkcmF3IGNvbm5lY3RvclxyXG4gICAgdGhpcy5jb25uZWN0b3JzPVtdO1xyXG4gICAgLy9wYXJlbnRub2RlLm91dHB1dEZpbGVzLmZvckVhY2goKG91dHB1dCwgZmlsZUluZGV4KSA9PiB7XHJcbiAgICBwYXJlbnRub2RlLmlucHV0RmlsZXMuZm9yRWFjaCgoaW5wdXQsIGZpbGVJbmRleCkgPT4geyAgICAgICAgXHJcbiAgICAgIGxldCBbcGx1ZywgY2FibGVdPSBwYXJ0cy5jcmVhdGVQYXJlbnRDb25uZWN0b3Ioc3ZnLCAzMiwgNDAsIDAsIDQwKmZpbGVJbmRleCwgc2lvKTtcclxuICAgICAgLy9jb25zdCBib3hCYm94PXBsdWcuYmJveCgpOyAgXHJcbiAgICAgIC8vcGx1Zy5kYXRhKHtcIm5hbWVcIjogb3V0cHV0Lm5hbWUsIFwiZHN0XCI6IG91dHB1dC5kc3R9KTtcclxuICAgICAgbGV0IGRzdEFycmF5ID0gW107XHJcbiAgICAgIGlmIChpbnB1dC5zcmNOYW1lID09PSBudWxsKXtcclxuICAgICAgICBkc3RBcnJheSA9IFtdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRzdEFycmF5ID0gW2lucHV0LnNyY05vZGUsIGlucHV0LnNyY05hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIHBsdWcuZGF0YSh7XCJuYW1lXCI6IGlucHV0Lm5hbWUsIFwiZHN0XCI6IGRzdEFycmF5fSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGlucHV0KTtcclxuICAgICAgXHJcbiAgICAgIHRoaXMuZ3JvdXAuYWRkKHBsdWcpO1xyXG4gICAgICB0aGlzLmdyb3VwLmFkZChjYWJsZSk7XHJcbiAgICAgIHRoaXMuY29ubmVjdG9ycy5wdXNoKHBsdWcpO1xyXG4gICAgICBjb25zb2xlLmxvZyhwbHVnKTtcclxuICAgICAgXHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMuY29ubmVjdG9ycyk7XHJcbiAgICBcclxuICAgIC8vIGRyYXcgcmVjZXB0b3JcclxuICAgIC8vcGFyZW50bm9kZS5pbnB1dEZpbGVzLmZvckVhY2goKGlucHV0LCBmaWxlSW5kZXgpID0+IHsgICAgICBcclxuICAgIHBhcmVudG5vZGUub3V0cHV0RmlsZXMuZm9yRWFjaCgob3V0cHV0LCBmaWxlSW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgcmVjZXB0b3IgPSBwYXJ0cy5jcmVhdGVQYXJlbnRSZWNlcHRvcihzdmcsIDE2LCA4MDAsIDAsIDQwKmZpbGVJbmRleCk7XHJcbiAgICAgIC8vcmVjZXB0b3IuZGF0YSh7XCJpbmRleFwiOiBwYXJlbnRub2RlLmluZGV4LCBcIm5hbWVcIjogb3V0cHV0Lm5hbWV9KTtcclxuICAgICAgcmVjZXB0b3IuZGF0YSh7XCJpbmRleFwiOiBcInBhcmVudFwiLCBcIm5hbWVcIjogb3V0cHV0Lm5hbWV9KTtcclxuICAgICAgY29uc29sZS5sb2coXCJyZWNlcHRvclwiKTsgICAgICBcclxuICAgICAgY29uc29sZS5sb2cocmVjZXB0b3IpO1xyXG4gICAgICBcclxuICAgICAgdGhpcy5ncm91cC5hZGQocmVjZXB0b3IpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIGJveCBvcmlnaW4gYW5kIG1vdXNlIHBvaW50ZXJcclxuICAgIGxldCBkaWZmWD0wO1xyXG4gICAgbGV0IGRpZmZZPTA7XHJcbiAgICAvLyBtb3VzZSBwb2ludGVyIGNvb3JkaW5hdGUgb24gZHJhZ3N0YXJ0XHJcbiAgICBsZXQgc3RhcnRYPTA7XHJcbiAgICBsZXQgc3RhcnRZPTA7XHJcbiAgICAvLyByZWdpc3RlciBkcmFnIGFuZCBkcm9wIGJlaGF2aW9yXHJcbiAgICB0aGlzLmdyb3VwXHJcbiAgICAgIC5vbignZHJhZ3N0YXJ0JywoZSk9PntcclxuICAgICAgICBkaWZmWD1lLmRldGFpbC5wLnggLSBlLnRhcmdldC5pbnN0YW5jZS5zZWxlY3QoJy5ib3gnKS5maXJzdCgpLngoKTtcclxuICAgICAgICBkaWZmWT1lLmRldGFpbC5wLnkgLSBlLnRhcmdldC5pbnN0YW5jZS5zZWxlY3QoJy5ib3gnKS5maXJzdCgpLnkoKVxyXG4gICAgICAgIHN0YXJ0WCA9IGUuZGV0YWlsLnAueDtcclxuICAgICAgICBzdGFydFkgPSBlLmRldGFpbC5wLnk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5vbignZHJhZ21vdmUnLCAoZSk9PntcclxuICAgICAgICBsZXQgZHggPSBlLmRldGFpbC5wLnggLSBzdGFydFg7XHJcbiAgICAgICAgbGV0IGR5ID0gZS5kZXRhaWwucC55IC0gc3RhcnRZO1xyXG4gICAgICAgIHRoaXMucmVEcmF3UGFyZW50TGlua3MoZHgsIGR5KVxyXG4gICAgICB9KVxyXG4gICAgICAub24oJ2RyYWdlbmQnLCAoZSk9PntcclxuICAgICAgICBsZXQgeCA9IGUuZGV0YWlsLnAueDtcclxuICAgICAgICBsZXQgeSA9IGUuZGV0YWlsLnAueTtcclxuICAgICAgICBpZih4ICE9PSBzdGFydFggfHwgeSAhPT0gc3RhcnRZKXtcclxuICAgICAgICAgIHNpby5lbWl0KCd1cGRhdGVOb2RlJywge2luZGV4OiBwYXJlbnRub2RlLmluZGV4LCBwcm9wZXJ0eTogJ3BvcycsIHZhbHVlOiB7J3gnOiB4LWRpZmZYLCAneSc6IHktZGlmZll9LCBjbWQ6ICd1cGRhdGUnfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGRyYXcgQ29ubmVjdG9yLVJlY2VwdG9yXHJcbiAgICovXHJcbiAgZHJhd1BhcmVudExpbmtzKCl7XHJcbiAgICBsZXQgYm94QmJveD10aGlzLmdyb3VwLmRhdGEoJ2JveEJib3gnKTtcclxuXHJcbiAgICBsZXQgcmVjZXB0b3JQbHVncz10aGlzLnN2Zy5zZWxlY3QoJy5yZWNlcHRvclBsdWcnKTtcclxuICAgIGNvbnNvbGUubG9nKFwicmVjZXB0b3JQbHVnc1wiKTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2cocmVjZXB0b3JQbHVncyk7XHJcbiAgICB0aGlzLmNvbm5lY3RvcnMuZm9yRWFjaCgoc3JjUGx1Zyk9PntcclxuICAgICAgY29uc29sZS5sb2codGhpcy5jb25uZWN0b3JzKTtcclxuICAgICAgY29uc29sZS5sb2coc3JjUGx1Zy5kYXRhKCdkc3QnKSk7ICAgICAgXHJcbiAgICAgIHNyY1BsdWcuZGF0YSgnZHN0JykuZm9yRWFjaCgoZHN0KT0+e1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coc3JjUGx1Zy5kYXRhKCdkc3QnKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IGRzdFBsdWcgPSByZWNlcHRvclBsdWdzLm1lbWJlcnMuZmluZCgocGx1Zyk9PntcclxuICAgICAgICAgIHJldHVybiBwbHVnLmRhdGEoJ2luZGV4JykgPT09IGRzdC5kc3ROb2RlICYmIHBsdWcuZGF0YSgnbmFtZScpID09PSBkc3QuZHN0TmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zb2xlLmxvZyhkc3QpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGRzdFBsdWcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGNhYmxlID0gbmV3IHBhcnRzLlN2Z0NhYmxlKHRoaXMuc3ZnLCBjb25maWcucGx1Z19jb2xvci5maWxlLCAnUkwnLCBzcmNQbHVnLmN4KCksIHNyY1BsdWcuY3koKSwgZHN0UGx1Zy5jeCgpLCBkc3RQbHVnLmN5KCkpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGNhYmxlKTtcclxuICAgICAgICBjYWJsZS5fZHJhdyhjYWJsZS5zdGFydFgsIGNhYmxlLnN0YXJ0WSwgY2FibGUuZW5kWCwgY2FibGUuZW5kWSwgYm94QmJveCk7XHJcbiAgICAgICAgY2FibGUuY2FibGUuZGF0YSgnZHN0JywgZHN0LmRzdE5vZGUpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0RmlsZUxpbmtzLnB1c2goY2FibGUpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiByZWRyYXcgY2FibGVzIGJldHdlZW4gTG93ZXItVXBwZXIgYW5kIENvbm5lY3Rvci1SZWNlcHRvciByZXNwZWN0aXZlbHlcclxuICAgKiBAcGFyYW0gb2Zmc2V0WCB4IGNvb3JkaW5hdGUgZGlmZmVyZW5jZSBmcm9tIGRyYWdzdGFydFxyXG4gICAqIEBwYXJhbSBvZmZzZXRZIHkgY29vcmRpbmF0ZSBkaWZmZXJlbmNlIGZyb20gZHJhZ3N0YXJ0XHJcbiAgICovXHJcbiAgcmVEcmF3UGFyZW50TGlua3Mob2Zmc2V0WCwgb2Zmc2V0WSl7XHJcbiAgICBsZXQgYm94QmJveD10aGlzLmdyb3VwLmRhdGEoJ2JveEJib3gnKTtcclxuICAgIHRoaXMub3V0cHV0RmlsZUxpbmtzLmZvckVhY2goKHYpPT57XHJcbiAgICAgIHYuZHJhZ1N0YXJ0UG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSwgYm94QmJveCk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuaW5wdXRGaWxlTGlua3MuZm9yRWFjaCgodik9PntcclxuICAgICAgdi5kcmFnRW5kUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSwgYm94QmJveCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICogZGVsZXRlIHN2ZyBlbGVtZW50IG9mIHRoaXMgbm9kZVxyXG4gICAqL1xyXG4gIHJlbW92ZSgpe1xyXG4gICAgdGhpcy5ncm91cC5yZW1vdmUoKTtcclxuICAgIHRoaXMub3V0cHV0RmlsZUxpbmtzLmZvckVhY2goKHYpPT57XHJcbiAgICAgIHYuY2FibGUucmVtb3ZlKCk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuaW5wdXRGaWxlTGlua3MuZm9yRWFjaCgodik9PntcclxuICAgICAgdi5jYWJsZS5yZW1vdmUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgICAvKipcclxuICAgKiByZWdpc3RlciBjYWxsYmFjayBmdW5jdGlvbiB0byAnbW91c2Vkb3duJyBldmVudFxyXG4gICAqL1xyXG4gIG9uTW91c2Vkb3duKGNhbGxiYWNrKXtcclxuICAgIHRoaXMuZ3JvdXAub24oJ21vdXNlZG93bicsIGNhbGxiYWNrKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9zcmMvanMvc3ZnTm9kZVVJLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///47\n");

/***/ }),

/***/ 52:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery_ui_ui_widgets_sortable__ = __webpack_require__(40);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery_ui_ui_widgets_sortable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery_ui_ui_widgets_sortable__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jquery_contextmenu__ = __webpack_require__(41);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jquery_contextmenu___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_jquery_contextmenu__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery_ui_themes_base_theme_css__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery_ui_themes_base_theme_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_jquery_ui_themes_base_theme_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_jquery_ui_themes_base_sortable_css__ = __webpack_require__(42);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_jquery_ui_themes_base_sortable_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_jquery_ui_themes_base_sortable_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_jquery_contextmenu_dist_jquery_contextMenu_css__ = __webpack_require__(43);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_jquery_contextmenu_dist_jquery_contextMenu_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_jquery_contextmenu_dist_jquery_contextMenu_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__css_workflow_css__ = __webpack_require__(38);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__css_workflow_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__css_workflow_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_vue_dist_vue_esm_js__ = __webpack_require__(18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_js_cookie__ = __webpack_require__(44);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_js_cookie___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_js_cookie__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_svgjs_dist_svg_js__ = __webpack_require__(45);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_svgjs_dist_svg_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_svgjs_dist_svg_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_svg_draggable_js_dist_svg_draggable_js__ = __webpack_require__(46);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_svg_draggable_js_dist_svg_draggable_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_svg_draggable_js_dist_svg_draggable_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__fileBrowser__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__dialogWrapper__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__logReciever__ = __webpack_require__(53);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__config__ = __webpack_require__(39);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14__config__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__svgNodeUI__ = __webpack_require__(47);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n__WEBPACK_IMPORTED_MODULE_0_jquery___default()(() => {\r\n  // chek project Json file path\r\n  const projectFilePath = __WEBPACK_IMPORTED_MODULE_8_js_cookie___default.a.get('project');\r\n  if (projectFilePath == null) {\r\n    throw new Error('illegal access');\r\n  }\r\n  let rootWorkflow = __WEBPACK_IMPORTED_MODULE_8_js_cookie___default.a.get('root');\r\n  let rootDir = __WEBPACK_IMPORTED_MODULE_8_js_cookie___default.a.get('rootDir');\r\n  let currentWorkFlow = rootWorkflow;\r\n  let currentWorkDir = rootDir;\r\n  let currentNode = '';\r\n  let nodeStack = [''];\r\n  let nodeTypeStack = [''];\r\n  let dirStack = [rootDir];\r\n  let wfStack = [rootWorkflow];\r\n  let childrenViewBoxList = [];\r\n\r\n  let projectLootDir = currentWorkDir;\r\n\r\n  // create vue.js instance for property subscreen\r\n  let vm = new __WEBPACK_IMPORTED_MODULE_7_vue_dist_vue_esm_js__[\"a\" /* default */]({\r\n    el: '#property',\r\n    data: {\r\n      node: {},\r\n      newInputFilename: \"\",\r\n      newOutputFilename: \"\",\r\n      newIndexOfForeach: \"\",\r\n      names: []\r\n    },\r\n    methods:{\r\n      addInputFile: function(){\r\n        let filename=this.newInputFilename;\r\n        if(filename === \"\") return\r\n        let duplicate = this.node.inputFiles.some((e)=>{\r\n          return e.name === filename;\r\n        });\r\n        if(duplicate) return\r\n        this.newInputFilename=\"\";\r\n        let newVal={name: filename, srcNode: null, srcName: null}\r\n        sio.emit('updateNode', {index: this.node.index, property: 'inputFiles', value: newVal, cmd: 'add'});\r\n      },\r\n      addOutputFile: function(){\r\n        let filename=this.newOutputFilename;\r\n        if(filename === \"\") return\r\n        let duplicate = this.node.outputFiles.some((e)=>{\r\n          return e.name === filename;\r\n        });\r\n        if(duplicate) return\r\n        this.newOutputFilename=\"\";\r\n        let newVal={name: filename, dst: []}\r\n        sio.emit('updateNode', {index: this.node.index, property: 'outputFiles', value: newVal, cmd: 'add'});\r\n      },\r\n      addIndexOfForeach: function(){\r\n        let val = this.newIndexOfForeach;\r\n        if(val === \"\") return\r\n        let duplicate = this.node.indexList.some((e)=>{\r\n          return e.label === val;\r\n        });\r\n        if(duplicate) return\r\n        this.newIndexOfForeach = \"\";\r\n        let newVal = {label: val};\r\n        sio.emit('updateNode', {index: this.node.index, property: 'indexList', value: newVal, cmd: 'add'});\r\n      },\r\n      delInputFile: function(i){\r\n        let val = this.node.inputFiles[i]\r\n        sio.emit('updateNode', {index: this.node.index, property: 'inputFiles', value: val, cmd: 'del'});\r\n      },\r\n      delOutputFile: function(i){\r\n        let val = this.node.outputFiles[i]\r\n        sio.emit('updateNode', {index: this.node.index, property: 'outputFiles', value: val, cmd: 'del'});\r\n      },\r\n      delIndexOfForeach: function(i){\r\n        let val = this.node.indexList[i]\r\n        sio.emit('updateNode', {index: this.node.index, property: 'indexList', value: val, cmd: 'del'});\r\n      },\r\n      updateNodeName: function(){\r\n        let val = this.node.name;\r\n        let dup = this.names.some((name)=>{\r\n          return name === val;\r\n        })\r\n        if(! dup){\r\n          sio.emit('updateNode', {index: this.node.index, property: 'name', value: this.node.name, cmd: 'update'});\r\n        }else{\r\n          console.log('duplicated name is not allowd!');\r\n        }\r\n      },\r\n      updateProperty: function(property, arrayFlag){\r\n        let val=this.node[property];\r\n        let cmd = arrayFlag ? 'updataArrayProperty': 'update';\r\n        sio.emit('updateNode', {index: this.node.index, property: property, value: val, cmd: cmd});\r\n      }\r\n    }\r\n  });\r\n\r\n  // set default view\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#project_manage_area').hide();\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#graphView').prop('checked', true);\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#log_area').hide();\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#property').hide();\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#parentDirBtn').hide();\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#taskLibraryMenu').hide();\r\n\r\n  // setup socket.io client\r\n  const sio = io('/workflow');\r\n\r\n  // setup FileBrowser\r\n  const fb = new __WEBPACK_IMPORTED_MODULE_11__fileBrowser__[\"a\" /* default */](sio, '#fileList', 'fileList', true, {\r\n    'edit': {\r\n      name: 'edit',\r\n      callback: function() {\r\n        const path = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).data('path');\r\n        const filename = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).data('name');\r\n        const params= __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.param({\r\n          \"path\": path,\r\n          \"filename\": filename,\r\n          \"pm\": false\r\n        });\r\n        window.open(`/editor?${params}`);\r\n      }\r\n    },\r\n    'edit for parameter survey': {\r\n      name: 'edit for PS',\r\n      callback: function() {\r\n        const path = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).data('path');\r\n        const filename = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).data('name');\r\n        const params= __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.param({\r\n          \"path\": path,\r\n          \"filename\": filename,\r\n          \"pm\": true\r\n        });\r\n        window.open(`/editor?${params}`);\r\n      }\r\n    }\r\n    // TODO download \r\n    // ,'download file': {\r\n    //   name: 'Download',\r\n    //   callback: function() {\r\n    //     const path = $(this).data('path');\r\n    //     const filename = $(this).data('name');\r\n    //     const message= {\r\n    //       \"path\": path,\r\n    //       \"name\": filename\r\n    //     };\r\n    //     sio.emit('download', message);\r\n    //   }\r\n    // }\r\n  });\r\n\r\n  // sio.on('download', (message) => {\r\n  //   console.log(message.toString());\r\n  // });\r\n\r\n  // container of svg elements\r\n  let nodes = [];\r\n  let parentnode =[];\r\n  let selectedNode = 0;\r\n  let selectedParent = 0;\r\n  let remotehost = '';\r\n  let remotehostArray = [];\r\n  let queueArray = [];\r\n  let selectedHostQueue = '';\r\n\r\n  const svg = __WEBPACK_IMPORTED_MODULE_9_svgjs_dist_svg_js___default()('node_svg');\r\n  sio.on('connect', function () {\r\n    fb.request('getFileList', currentWorkDir, null);\r\n    sio.emit('getWorkflow', currentWorkFlow);\r\n    sio.emit('getProjectJson', rootWorkflow);\r\n    sio.emit('getProjectState', rootWorkflow);\r\n    \r\n    sio.on('workflow', function(wf){\r\n      console.log(\"on\");\r\n      \r\n      nodeStack[nodeStack.length - 1] = wf.name;\r\n      nodeTypeStack[nodeStack.length - 1] = wf.type;\r\n\r\n      updateBreadrumb();\r\n\r\n      // remove all node from workflow editor\r\n      nodes.forEach(function(v){\r\n        if (v !== null) v.remove();\r\n      });\r\n      nodes = [];\r\n      if (wf.nodes.length > 0) {\r\n        let names = wf.nodes.map((e) => {\r\n          return e != null? e.name : null;\r\n        });\r\n        vm.names = names;\r\n        vm.node = wf.nodes[selectedNode];\r\n      }\r\n      //remove parent node\r\n      parentnode.forEach(function(vv){\r\n        if (vv !== null) vv.remove();\r\n      });\r\n      parentnode = [];\r\n      if (wf.length > 0) {\r\n        let names = wf.map((e) => {\r\n          return e != null? e.name : null;\r\n        });\r\n        vm.names = names;\r\n        vm.node = wf[selectedParent];\r\n      }\r\n      \r\n      console.log(\"draw\");\r\n      console.log(wf.nodes);\r\n      \r\n      drawNodes(wf.nodes);\r\n      drawLinks(nodes);\r\n      drawParentFileRelation(wf);\r\n      drawParentLinks(parentnode);\r\n    });\r\n\r\n    //å­è¡¨ç¤ºç¨ã¨ãã¦ä½æãããå®è£æ¹æ³å¤æ´ã®ããä¸æçã«ã³ã¡ã³ãã¢ã¦ã\r\n/*     //children nodes view\r\n    let childrenNodes = [];\r\n    let selectedChildrenNodes = 0;    \r\n    sio.on('nodes', function(wfForChildren){\r\n      console.log(\"sio.on drawNodesNodes\");      \r\n      console.log(wfForChildren);\r\n          \r\n      childrenNodes.forEach(function(v){\r\n        if (v !== null) v.remove();\r\n      });\r\n      childrenNodes = [];\r\n      if (wfForChildren.nodes.length > 0) {\r\n        let names = wfForChildren.nodes.map((e) => {\r\n          return e != null? e.name : null;\r\n        });\r\n        vm.names = names;\r\n        vm.node = wfForChildren.nodes[selectedChildrenNodes];\r\n      }\r\n\r\n      console.log(\"SVG-drawNodesNodes\");      \r\n      drawNodesNodes(wfForChildren.nodes);\r\n    });*/\r\n    \r\n    sio.on('taskStateList', (taskStateList) => {\r\n      updateTaskStateTable(taskStateList);\r\n     })\r\n\r\n    // TODO ç¾å¨ã®ãã­ã¸ã§ã¯ãç¶æã®åå¾ããµã¼ãã«ãªã¯ã¨ã¹ããã\r\n    sio.on('projectJson', (projectJson) => {\r\n\r\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#project_name').text(projectJson.name);\r\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#project_state').text(projectJson.state);\r\n      // ä»®ã§ç¾å¨æ¥æãè¡¨ç¤º\r\n      let now = new Date();\r\n      let date = '' + now.getFullYear() + '/' + now.getMonth() + '/' + now.getDate() + ' ' + now.getHours() + ':' + ('0' + now.getMinutes()).slice(-2);\r\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#project_create_date').text(projectJson.ctime);\r\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#project_update_date').text(projectJson.mtime);\r\n\r\n    });\r\n\r\n    sio.on('projectState', (state)=>{\r\n      console.log(\"statetest\");\r\n      if (state === 'running') {\r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#project_state').text('Running');\r\n      } else if(state === 'failed') {\r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#project_state').text('Failed');\r\n      } else if (state === 'finished') {\r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#project_state').text('Finished');\r\n      } else {\r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#project_state').text('Not-Started');\r\n      }\r\n    });\r\n\r\n    /*create host, queue selectbox*/ \r\n    sio.on('hostList', function(hostlist){\r\n      console.log(hostlist);\r\n      let remotehostSelectField = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#remotehostSelectField');\r\n      remotehostSelectField.empty();\r\n      remotehostArray = [];\r\n      \r\n      remotehostSelectField.append(`<option value=\"localhost\">localhost</option>`);\r\n      for (let index = 0; index < hostlist.length; index++) {\r\n        remotehostSelectField.append(`<option value=\"${hostlist[index].name}\">${hostlist[index].name}</option>`);\r\n        remotehostArray.push(hostlist[index].name);\r\n      }\r\n      //selectboxã¸ã®è¨­å®\r\n      remotehostSelectField.val(remotehost);\r\n      console.log(remotehost);      \r\n      \r\n      let queueSelectField = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#queueSelectField');\r\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#remotehostSelectField').change(function() {\r\n        console.log(hostlist);        \r\n        queueSelectField.empty();\r\n        let selectedHost = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#remotehostSelectField option:selected').text();        \r\n        \r\n        if(selectedHost === 'localhost'){\r\n          queueArray = ['null'];\r\n        } else {\r\n          let hostListIndex = remotehostArray.indexOf(selectedHost);\r\n          console.log(selectedHost);\r\n          console.log(hostListIndex);\r\n          let queueList = hostlist[hostListIndex].queue;\r\n          queueArray = queueList.split(',');\r\n          queueSelectField.append(`<option value=\"null\">null</option>`);                        \r\n        }\r\n        for (let index = 0; index < queueArray.length; index++) {\r\n          queueSelectField.append(`<option value=${queueArray[index]}>${queueArray[index]}</option>`);\r\n        }\r\n        queueSelectField.val(selectedHostQueue);\r\n        });\r\n    });\r\n/* \r\n    sio.emit('getWorkflow', currentWorkFlow);\r\n\r\n    //ä¸åãããã§emitãã¨ã\r\n    sio.emit('getProjectJson', rootWorkflow); */\r\n    \r\n    //setup log reciever\r\n    Object(__WEBPACK_IMPORTED_MODULE_13__logReciever__[\"a\" /* default */])(sio);\r\n\r\n  });\r\n\r\n  // register btn click event listeners\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#run_menu').on('click',function(){\r\n    sio.emit('runProject', rootWorkflow);\r\n  });\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#pause_menu').on('click',function(){\r\n    sio.emit('pauseProject', true);\r\n  });\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#clean_menu').on('click',function(){\r\n    sio.emit('cleanProject', true);\r\n  });\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#stop_menu').on('click',function(){\r\n    sio.emit('stopProject', true);\r\n  });\r\n\r\n  //save,revert\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#save_button').on('click',function(){\r\n    //ãµã¼ãã¼å´æªå®è£\r\n    sio.emit('saveProject', null, (result) => {\r\n      console.log(result);\r\n    });\r\n  });\r\n\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#revert_button').on('click',function(){\r\n    //ãµã¼ãã¼å´æªå®è£\r\n    sio.emit('revertProject', null, (result) => {\r\n      console.log(result);\r\n    });\r\nã});\r\n\r\n\r\n  // hide property and select parent WF if background is clicked\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#node_svg').on('mousedown', function(){\r\n    fb.request('getFileList', currentWorkDir, null);\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#property').hide();\r\n  });\r\n\r\n  // setup file uploader\r\n  const uploader = new SocketIOFileUpload(sio);\r\n  uploader.listenOnDrop(document.getElementById('fileBrowser'));  \r\n  uploader.listenOnInput(document.getElementById('fileSelector'));\r\n\r\n\r\n  // show or hide log area\r\n  var isDisplayLog = false;\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#displayLogButton').click(function () {\r\n    isDisplayLog = !isDisplayLog;\r\n    if (isDisplayLog) {\r\n      showLog();\r\n    } else {\r\n      hideLog();\r\n    }\r\n  });\r\n\r\n  //ãã¿ã³ã§ã®viewã®åãæ¿ã\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#listView').click(function () {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#workflow_manage_area').hide();\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#project_manage_area').show();\r\n    sio.emit('getTaskStateList', rootWorkflow);\r\n  });\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#graphView').click(function () {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#project_manage_area').hide();\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#workflow_manage_area').show();\r\n  }); \r\n\r\n  // setup context menu\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.contextMenu({\r\n    selector: 'g',\r\n    autoHide: true,\r\n    reposition: false,\r\n    callback: function(itemKey, opt){\r\n      var pos=getClickPosition(opt);\r\n      sio.emit('createNode', {\"type\": itemKey, \"pos\": pos});\r\n    },\r\n    items: {\r\n      /*\"new\": {\r\n         \"name\": \"new\",\r\n         \"items\":\r\n         {\r\n           \"task\":    {name: \"task\"},\r\n           \"workflow\":{name: \"workflow\"},\r\n           \"PS\":      {name: \"parameter study\"},\r\n           \"if\":      {name: \"if\"},\r\n           \"for\":     {name: \"for\"},\r\n           \"while\":   {name: \"while\"},\r\n           \"foreach\": {name: \"foreach\"}\r\n         } \r\n      },*/\r\n      \"delete\": {\r\n        \"name\": \"delete\",\r\n\r\n        callback: function(){\r\n          sio.emit('removeNode', selectedNode);\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  //ã¿ã¹ã¯ã®ãã©ãã°ã¢ã³ããã­ããæä½\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#workflowComponents .type').mouseover(function () {      \r\n    var target = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).attr(\"id\");\r\n    var objectDrag = document.getElementById(target); \r\n    var objectDrop = document.getElementById(\"node_svg\");\r\n\r\n    objectDrag.ondragstart = function(event){\r\n      event.dataTransfer.setData(\"text\", event.target.id);\r\n    };\r\n\r\n    objectDrop.ondragover = function(event){\r\n      event.preventDefault();\r\n    };\r\n\r\n    objectDrop.ondrop = function(event){\r\n      event.preventDefault();\r\n      var objectName = event.dataTransfer.getData(\"text\");\r\n      var xCoordinate = event.offsetX;\r\n      var yCoordinate = event.offsetY;\r\n  \r\n      const pos = {x: xCoordinate, y: yCoordinate};\r\n      sio.emit('createNode', {\"type\": objectName, \"pos\": pos});    \r\n    };\r\n  });\r\n\r\n  //ã¿ã¹ã¯ã©ã¤ãã©ãªã¼ã®è¡¨ç¤ºéè¡¨ç¤º\r\n  // function definition\r\n  function showTaskLibrary() {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#taskLibraryButton').show().animate({left: '256px'},50);\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#taskLibraryMenu').show().animate({width: '256px', 'min-width': '256px'}, 50);\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#libraryButton').attr(\"src\", \"/image/btn_openCloseL_n.png\");    \r\n  }\r\n\r\n  function hideTaskLibrary() {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#taskLibraryButton').show().animate({left: '-=256px'},100);    \r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#taskLibraryMenu').hide();\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#libraryButton').attr(\"src\", \"/image/btn_openCloseR_n.png\");        \r\n  }\r\n\r\n  // show or hide log area\r\n  var isDisplayLog = false;\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#taskLibraryButton').click(function () {\r\n    isDisplayLog = !isDisplayLog;\r\n    if (isDisplayLog) {\r\n      showTaskLibrary();\r\n    } else {\r\n      hideTaskLibrary();\r\n    }\r\n  });\r\n\r\n  // function definition\r\n  function showLog() {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logArea').show();\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#displayLogButton').toggleClass('display', true);\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#img_displayLogButton').attr(\"src\", \"/image/btn_openCloseD_n.png\");        \r\n  }\r\n\r\n  function hideLog() {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logArea').hide();\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#displayLogButton').toggleClass('display', false);\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#img_displayLogButton').attr(\"src\", \"/image/btn_openCloseU_n.png\");        \r\n  }\r\n\r\n  /**\r\n   * get mouse positoin where contextmenu is created\r\n   * @param option second argument of callback function of jquery.contextMenu\r\n   */\r\n  function getClickPosition(option) {\r\n    const parentOffset = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(option.selector).offset();\r\n    const clickPosition = option.$menu.position();\r\n    const position = {\r\n      x: Math.round(clickPosition.left - parentOffset.left),\r\n      y: Math.round(clickPosition.top - parentOffset.top)\r\n    };\r\n    return position;\r\n  }\r\n\r\n  /**\r\n   * check if filename is already in inputFiles or outputFiles\r\n   * @param files inputFiles or outputFiles of any workflow component\r\n   * @param filename testee\r\n   */\r\n  function isDupulicated(files, filename) {\r\n    return -1 !== files.findIndex(function(v){\r\n      return v.name === filename;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * draw nodes\r\n   * @param nodeInWF node list in workflow Json\r\n   */\r\n  var buttonFlag = false;\r\n  function drawNodes(nodesInWF) {\r\n      nodesInWF.forEach(function(v,i){\r\n        console.log(v);\r\n        // workflowåã®nodeã¨SVGè¦ç´ ã®nodeã®indexãä¸è´ããããã«nullã§æ¶ããã¦ããæãnodesã®è¦ç´ ã¯ä½æãã\r\n        if(v === null){\r\n          nodes.push(null);\r\n          childrenViewBoxList.push(null);\r\n        }else{\r\n          let node=new __WEBPACK_IMPORTED_MODULE_15__svgNodeUI__[\"a\" /* SvgNodeUI */](svg, sio, v);\r\n          console.log(node);\r\n\r\n/*           let childrenWorkflow = currentWorkDir+'/'+v.name+'/'+v.jsonFile;\r\n          if(v.type === 'workflow' || v.type === 'parameterStudy' || v.type === 'for' || v.type === 'while' || v.type === 'foreach'){\r\n            sio.emit('getNodes', childrenWorkflow);\r\n          }\r\n          childrenViewBoxList.push(svg); */\r\n\r\n          node.onMousedown(function(e){\r\n            let nodeIndex=e.target.instance.parent('.node').data('index');\r\n            selectedNode=nodeIndex;\r\n            let name = nodesInWF[nodeIndex].name;         \r\n            let nodePath = currentWorkDir+'/'+nodesInWF[nodeIndex].name;\r\n            //ãã¡ã¤ã«ãã©ã¦ã¶ç¨\r\n            fb.request('getFileList', nodePath, null);\r\n\r\n            //ãã­ããã£è¡¨ç¤ºç¨ç¸å¯¾ãã¹\r\n            let currentPropertyDir = \".\"+currentWorkDir.replace(projectLootDir,\"\")+\"/\"+nodesInWF[nodeIndex].name;\r\n            let nodeType = nodesInWF[nodeIndex].type;\r\n            //iconã®å¤æ´\r\n            let nodeIconPath = __WEBPACK_IMPORTED_MODULE_14__config___default.a.node_icon[nodeType];\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#img_node_type').attr(\"src\", nodeIconPath);\r\n            \r\n            if(nodeType === 'task'){\r\n              sio.emit('getHostList', true);\r\n              //vueã§è¨­å®ããJsonã®å¤ãå¼ã£å¼µã¦ãã¦æç»ãã            \r\n              remotehost = nodesInWF[nodeIndex].host;        \r\n              selectedHostQueue = nodesInWF[nodeIndex].queue;                                              \r\n            }\r\n\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#propertyTypeName').html(nodesInWF[nodeIndex].type);            \r\n            vm.node=v;\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#componentPath').html(currentPropertyDir);\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#property').show().animate({width: '272px', 'min-width': '272px'}, 100);\r\n          })\r\n          .onDblclick(function(e){\r\n            console.log(\"Dbc\");            \r\n            let nodeType=e.target.instance.parent('.node').data('type');\r\n            if(nodeType === 'workflow' ||nodeType === 'parameterStudy' || nodeType === 'for' || nodeType === 'while' || nodeType === 'foreach'){\r\n              let nodeIndex=e.target.instance.parent('.node').data('index');\r\n              let name = nodesInWF[nodeIndex].name;\r\n              let path=e.target.instance.parent('.node').data('path');\r\n              let json=e.target.instance.parent('.node').data('jsonFile');\r\n              currentWorkDir=currentWorkDir+'/'+name;\r\n              currentWorkFlow=currentWorkDir+'/'+json;\r\n              //dirStack.push({dir: currentWorkDir, wf: currentWorkFlow});\r\n              dirStack.push(currentWorkDir);\r\n              wfStack.push(currentWorkFlow);\r\n              nodeStack.push(name);\r\n              nodeTypeStack.push(nodeType);\r\n              console.log(currentWorkDir);              \r\n              console.log(currentWorkFlow);\r\n              \r\n              process.nextTick(function () {                \r\n              fb.request('getFileList', currentWorkDir, null);\r\n              sio.emit('getWorkflow', currentWorkFlow);\r\n              console.log(\"emit\");\r\n              });\r\n            }\r\n          })\r\n          .onClick(function(e){\r\n            console.log(buttonFlag);\r\n            let nodeType=e.target.instance.parent('.node').data('type');\r\n            if(nodeType === 'workflow' ||nodeType === 'parameterStudy' || nodeType === 'for' || nodeType === 'while' || nodeType === 'foreach'){\r\n              console.log(\"clickcheck\");\r\n              if( buttonFlag === false){\r\n                console.log(\"flagfcheck\");\r\n                __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.viewNodes').show();                         \r\n                buttonFlag = true;              \r\n              } else {\r\n                __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.viewNodes').css('display', 'none');                                       \r\n                buttonFlag = false;\r\n              }\r\n            }\r\n          });\r\n          \r\n          nodes.push(node);\r\n        }\r\n      });\r\n  }\r\n\r\n  //å­è¡¨ç¤ºç¨ã¨ãã¦ä½æãããå®è£æ¹æ³å¤æ´ã®ããä¸æçã«ã³ã¡ã³ãã¢ã¦ã\r\n    /**\r\n   * draw nodes children\r\n   * @param nodeForChildren node list in workflow Json\r\n   */\r\n  /* function drawNodesNodes(nodeForChildren){\r\n    //viewBoxListã«ç»é²ããå­è¦ç´ è¡¨ç¤ºå¯¾è±¡nodeã®ã¤ã³ã¹ã¿ã³ã¹ãä½æãã\r\n    nodeForChildren.forEach(function(v,i){\r\n      //indexã¨iãä¸ç·ã®æãå­è¡¨ç¤ºããã\r\n      if(v !== null){\r\n        console.log(v);\r\n        console.log(i);\r\n        console.log(childrenViewBoxList);\r\n        let childrenNode = new svgNode.SvgChildrenNodeUI(childrenViewBoxList[i], v);\r\n        //let childrenNode = new svgNode.SvgChildrenNodeUI(svg, v);\r\n\r\n      }\r\n    });\r\n  } */\r\n  /**\r\n   * draw cables between Lower and Upper plug Connector and Receptor plug respectively\r\n   * @param nodeInWF node list in workflow Json\r\n   */\r\n  function drawLinks(nodes) {\r\n    nodes.forEach(function(node){\r\n      if(node != null){\r\n        node.drawLinks();\r\n      }\r\n    });\r\n    nodes.forEach(function(node){\r\n      if(node != null){\r\n        node.nextLinks.forEach(function(cable){\r\n          let dst = cable.cable.data('dst');\r\n          nodes[dst].previousLinks.push(cable);\r\n        });\r\n        node.elseLinks.forEach(function(cable){\r\n          let dst = cable.cable.data('dst');\r\n          nodes[dst].previousLinks.push(cable);\r\n        });\r\n        node.outputFileLinks.forEach(function(cable){\r\n          let dst = cable.cable.data('dst');\r\n          nodes[dst].inputFileLinks.push(cable);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n    /**\r\n   * draw parent children file relation\r\n   * @param  files list in workflow Json\r\n   */\r\n  function drawParentFileRelation(parentwf){\r\n    //selectedParent = nodeIndex;    \r\n    let node=new __WEBPACK_IMPORTED_MODULE_15__svgNodeUI__[\"b\" /* SvgParentNodeUI */](svg, sio, parentwf);\r\n    parentnode.push(node);\r\n    console.log(\"parentnode\");\r\n    console.log(parentnode);\r\n/*     parentwf.inputFiles.forEach(function(inputFiles){\r\n      if(inputFiles != null){\r\n        inputFiles.drawParentFileRelation();\r\n      }\r\n    }); */\r\n  }\r\n\r\n    /**\r\n   * draw cables between Lower and Upper plug Connector and Receptor plug respectively\r\n   * @param nodeInWF node list in workflow Json\r\n   */\r\n  function drawParentLinks(parentnode) {\r\n    console.log(\"draw Parent Link\");\r\n    parentnode.forEach(function(node){\r\n      if(node != null){\r\n        node.drawParentLinks();\r\n      }\r\n    });\r\n    parentnode.forEach(function(node){\r\n      if(node != null){\r\n        node.outputFileLinks.forEach(function(cable){\r\n          let dst = cable.cable.data('dst');\r\n          parentnode[dst].inputFileLinks.push(cable);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  function updateBreadrumb() {\r\n    let breadcrumb = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#breadcrumb');\r\n    breadcrumb.empty();\r\n\r\n    for (let index = 0; index < nodeStack.length; index++) {\r\n      if (0 < index) {\r\n        breadcrumb.append(`<span class=\"img_pankuzuArrow_icon\"><img src=\"/image/img_pankuzuArrow.png\"  /></span>`) \r\n      }\r\n      let id = `breadcrumbButton_${index}`;\r\n      //iconã®è¨­å®\r\n      let nodeIconPath = __WEBPACK_IMPORTED_MODULE_14__config___default.a.node_icon[nodeTypeStack[index]];\r\n      let correctNodeIconPath = nodeIconPath.replace(\".png\",\"_p.png\"); \r\n      let nodeColor = __WEBPACK_IMPORTED_MODULE_14__config___default.a.node_color[nodeTypeStack[index]];\r\n      breadcrumb.append(`<button type=\"button\" id=${id} class=\"breadcrumbButton\" value=${nodeStack[index]}>\r\n        <img src=${correctNodeIconPath} class=\"img_breadcrumbButton_icon\" /><span class=\"breadcrunbName\">${nodeStack[index]}</span></button>`)\r\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(`#${id}`).css(\"background-color\", nodeColor);\r\n      \r\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(`#${id}`).click(function () {\r\n\r\n        while (index + 1 < nodeStack.length) {\r\n          currentNode = nodeStack.pop();\r\n          dirStack.pop();\r\n          currentWorkDir = dirStack[nodeStack.length-1];\r\n          currentWorkFlow = wfStack[nodeStack.length-1];\r\n        }\r\n        updateBreadrumb(); \r\n\r\n        fb.request('getFileList', currentWorkDir, null);\r\n        sio.emit('getWorkflow', currentWorkFlow);\r\n        console.log(\"emit bread\");\r\n      });\r\n    }\r\n  }\r\n\r\n  function updateTaskStateTable(taskStateList) {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#project_table_body').empty();\r\n    let taskStateTable = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#project_table_body');\r\n    for (let i = 0; i < taskStateList.length; i++) {\r\n      //for test\r\n      let nodeType = \"task\";\r\n      //let nodeType = taskStateList[i].type;\r\n      let nodeState = \"running\";\r\n      //let nodeState = taskStateList[i].state;\r\n\r\n      let nodeIconPath = __WEBPACK_IMPORTED_MODULE_14__config___default.a.node_icon[nodeType];\r\n      let nodeColor = __WEBPACK_IMPORTED_MODULE_14__config___default.a.node_color[nodeType];\r\n      let nodeComponentState = __WEBPACK_IMPORTED_MODULE_14__config___default.a.state_icon[nodeState]; \r\n\r\n      let id = `taskLabel_${i}`;      \r\n\r\n      taskStateTable.append(`<tr><td id=${id} class=\"componentName\"><img src=${nodeIconPath} class=\"workflow_component_icon\"/><label class=\"nameLabel\">${taskStateList[i].name}</label></td>\r\n      <td class=\"componentState\"><img src=${nodeComponentState}/><label class=\"stateLabel\">${taskStateList[i].state}</label></td>\r\n      <td class=\"componentStartTime\">${taskStateList[i].startTime}</td>\r\n      <td class=\"componentEndTime\">${taskStateList[i].endTime}</td>\r\n      <td class=\"componentDescription\">${taskStateList[i].description}</td></tr>`);\r\n\r\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(`#${id}`).css(\"background-color\", nodeColor);\r\n      \r\n    }\r\n  }\r\n\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#useJobSchedulerFlagField').change(function() {\r\n    //let checkedValue = $('#queueSelectField:checked').val();\r\n      console.log(\"checkedValue\");        \r\n      \r\n      if(__WEBPACK_IMPORTED_MODULE_0_jquery___default()('#useJobSchedulerFlagField').prop('checked')){\r\n        console.log(\"test\");\r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#queueSelectField').prop('disabled',false);\r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#queueSelectField').css('background-color', '#000000');\r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#queueSelectField').css('color', '#FFFFFF');                            \r\n        \r\n      } else {\r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#queueSelectField').prop('disabled',true);\r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#queueSelectField').css('background-color', '#333333');\r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#queueSelectField').css('color', '#000000');                    \r\n      }\r\n  });\r\n\r\n\r\n  //ãã­ããã£ã¨ãªã¢ã®ãã¡ã¤ã«ããã©ã«ãã¼æ°è¦ä½æ\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#createFileButton').click(function () {\r\n    const html = '<p class=\"dialogTitle\">New file name (ex. aaa.txt)</p><input type=text class=\"dialogTextbox\">'\r\n    Object(__WEBPACK_IMPORTED_MODULE_12__dialogWrapper__[\"a\" /* default */])('#dialog', html)\r\n      .done(function () {\r\n        let newFileName = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#newFileName').val();\r\n        let newFilePath = fb.getRequestedPath() + \"/\" + newFileName;\r\n        sio.emit('createNewFile', newFilePath, (result) => {\r\n          console.log(result);\r\n          console.log(newFilePath);          \r\n      });\r\n  ã});\r\nã});\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#createFolderButton').click(function () {\r\n    const html = '<p class=\"dialogTitle\">New folder name</p><input type=text class=\"dialogTextbox\">'\r\n    Object(__WEBPACK_IMPORTED_MODULE_12__dialogWrapper__[\"a\" /* default */])('#dialog', html)\r\n      .done(function () {\r\n        let newFolderName = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#newFolderName').val();\r\n        let newFolderPath = fb.getRequestedPath() + \"/\" + newFolderName;        \r\n        sio.emit('createNewDir', newFolderPath, (result) => {\r\n          console.log(result);\r\n          console.log(newFolderPath);\r\n      });\r\n    });\r\nã});\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#fileUploadButton').click(function () {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#fileSelector').click();\r\n  });\r\n\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#drawer_button').click(function () {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#drawer_menu').toggleClass('action', true);\r\n  });\r\n\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#drawer_menu').mouseleave(function () {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#drawer_menu').toggleClass('action', false);\r\n  });\r\n\r\n/*   $('.viewButton').click(function(){\r\n    $(\".viewNodes\").css('display', 'block');    \r\n  }); */\r\n\r\n  //ãã¿ã³ã§ã®viewã®åãæ¿ã\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.viewButton').mouseover(function() {\r\n    var viewButtonID = document.getElementById('.viewButton'); \r\n    console.log(viewButtonID);\r\n    //setAttributeã¡ã½ããã§fillå±æ§ã®å¤ãéã«å¤æ´ \r\n\r\n/* circle1.setAttribute(\"fill\",\"#0000ff\"); \r\n\r\n    svg1 = document.getElementById('svg1');\r\n    $('.viewNodes').css('display', 'block'); */\r\n  });\r\n\r\n  \r\n  function getSelectLabel(index){\r\n    var obj = document.getElementById(index);\r\n    var idx = obj.selectedIndex;       //ã¤ã³ããã¯ã¹çªå·ãåå¾\r\n    var val = obj.options[idx].value;  //valueå¤ãåå¾\r\n    var txt  = obj.options[idx].text;  //ã©ãã«ãåå¾\r\n    console.log(idx);\r\n    console.log(val);\r\n    \r\n  }\r\n\r\n  var pos=__WEBPACK_IMPORTED_MODULE_0_jquery___default()(\"#titleUserName\").offset();\r\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()(\"#img_user\").css('right', window.innerWidth - 8 - pos.left + \"px\");\r\n  \r\n});\r\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(5)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2pzL3dvcmtmbG93LmpzPzQwOTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixnQ0FBZ0MsMEVBQTBFO0FBQzFHLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsZ0NBQWdDLDJFQUEyRTtBQUMzRyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGdDQUFnQyx5RUFBeUU7QUFDekcsT0FBTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0MsdUVBQXVFO0FBQ3ZHLE9BQU87QUFDUDtBQUNBO0FBQ0EsZ0NBQWdDLHdFQUF3RTtBQUN4RyxPQUFPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQyxzRUFBc0U7QUFDdEcsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLCtFQUErRTtBQUNqSCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUVBQWlFO0FBQ2pHO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwrQkFBK0IsT0FBTztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxrQztBQUNBO0FBQ0EsMkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSx3QztBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xELHVEQUF1RCxxQkFBcUIsSUFBSSxxQkFBcUI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Qjs7QUFFQTtBQUNBO0FBQ0EsOEI7QUFDQTtBQUNBLDJIOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3RELG1EQUFtRCxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDMUY7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZ0U7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDRCQUE0QjtBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDLHVCQUF1QixpQkFBaUI7QUFDeEMsdUJBQXVCLHdCQUF3QjtBQUMvQyx1QkFBdUIsV0FBVztBQUNsQyx1QkFBdUIsWUFBWTtBQUNuQyx1QkFBdUIsY0FBYztBQUNyQyx1QkFBdUI7QUFDdkIsVTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EscUc7QUFDQTtBQUNBLHFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQiw4QkFBOEIsK0JBQStCLEU7QUFDN0Q7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHlGQUE0QyxjQUFjO0FBQzFELHVGQUEwQyxxQ0FBcUM7QUFDL0UsZ0g7QUFDQTs7QUFFQTtBQUNBLHlGQUE0QyxnQkFBZ0IsTTtBQUM1RDtBQUNBLGdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBLGlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxRDtBQUNBLDZEO0FBQ0E7O0FBRUEsZ0g7QUFDQTtBQUNBO0FBQ0Esd0ZBQTJDLHFDQUFxQztBQUNoRixXQUFXO0FBQ1g7QUFDQSwrQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseUNBQXlDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEM7QUFDQTs7QUFFQSw0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GO0FBQ0Esa0M7QUFDQSxlQUFlO0FBQ2Ysb0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQSxzRTtBQUNBO0FBQ0Esb0RBQW9ELEdBQUcsa0NBQWtDLGlCQUFpQjtBQUMxRyxtQkFBbUIsb0JBQW9CLG9FQUFvRSxpQkFBaUI7QUFDNUgseURBQVksR0FBRzs7QUFFZix5REFBWSxHQUFHOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0c7O0FBRUEsNEJBQTRCLEVBQUUsRTs7QUFFOUIsMENBQTBDLEdBQUcsa0NBQWtDLGFBQWEsNkRBQTZELHNCQUFzQjtBQUMvSyw0Q0FBNEMsbUJBQW1CLDhCQUE4Qix1QkFBdUI7QUFDcEgsdUNBQXVDLDJCQUEyQjtBQUNsRSxxQ0FBcUMseUJBQXlCO0FBQzlELHlDQUF5Qyw2QkFBNkI7O0FBRXRFLHlEQUFZLEdBQUc7O0FBRWY7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRzs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG9HO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQztBQUNBLE9BQU87QUFDUCxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsRUFBRTtBQUNGO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsNEM7QUFDQSxHQUFHLEVBQUU7O0FBRUw7QUFDQTtBQUNBLDhEO0FBQ0E7QUFDQTs7QUFFQSwwQzs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QyxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLENBQUMiLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xyXG5pbXBvcnQgJ2pxdWVyeS11aS91aS93aWRnZXRzL3NvcnRhYmxlJztcclxuaW1wb3J0ICdqcXVlcnktY29udGV4dG1lbnUnO1xyXG5cclxuaW1wb3J0ICdqcXVlcnktdWkvdGhlbWVzL2Jhc2UvdGhlbWUuY3NzJztcclxuaW1wb3J0ICdqcXVlcnktdWkvdGhlbWVzL2Jhc2Uvc29ydGFibGUuY3NzJztcclxuaW1wb3J0ICdqcXVlcnktY29udGV4dG1lbnUvZGlzdC9qcXVlcnkuY29udGV4dE1lbnUuY3NzJztcclxuXHJcbmltcG9ydCAnLi4vY3NzL3dvcmtmbG93LmNzcyc7XHJcblxyXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5lc20uanMnO1xyXG5pbXBvcnQgQ29va2llcyBmcm9tICdqcy1jb29raWUnO1xyXG5pbXBvcnQgU1ZHIGZyb20gJ3N2Z2pzL2Rpc3Qvc3ZnLmpzJztcclxuaW1wb3J0ICdzdmcuZHJhZ2dhYmxlLmpzL2Rpc3Qvc3ZnLmRyYWdnYWJsZS5qcyc7XHJcblxyXG5pbXBvcnQgRmlsZUJyb3dzZXIgZnJvbSAgJy4vZmlsZUJyb3dzZXInO1xyXG5pbXBvcnQgZGlhbG9nV3JhcHBlciBmcm9tICcuL2RpYWxvZ1dyYXBwZXInO1xyXG5pbXBvcnQgbG9nUmVjaWV2ZXIgZnJvbSAnLi9sb2dSZWNpZXZlcic7XHJcbmltcG9ydCBjb25maWcgZnJvbSAnLi9jb25maWcnO1xyXG5pbXBvcnQgU3ZnTm9kZVVJIGZyb20gJy4vc3ZnTm9kZVVJJztcclxuaW1wb3J0ICogYXMgc3ZnTm9kZSBmcm9tICcuL3N2Z05vZGVVSSc7XHJcblxyXG5cclxuJCgoKSA9PiB7XHJcbiAgLy8gY2hlayBwcm9qZWN0IEpzb24gZmlsZSBwYXRoXHJcbiAgY29uc3QgcHJvamVjdEZpbGVQYXRoID0gQ29va2llcy5nZXQoJ3Byb2plY3QnKTtcclxuICBpZiAocHJvamVjdEZpbGVQYXRoID09IG51bGwpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignaWxsZWdhbCBhY2Nlc3MnKTtcclxuICB9XHJcbiAgbGV0IHJvb3RXb3JrZmxvdyA9IENvb2tpZXMuZ2V0KCdyb290Jyk7XHJcbiAgbGV0IHJvb3REaXIgPSBDb29raWVzLmdldCgncm9vdERpcicpO1xyXG4gIGxldCBjdXJyZW50V29ya0Zsb3cgPSByb290V29ya2Zsb3c7XHJcbiAgbGV0IGN1cnJlbnRXb3JrRGlyID0gcm9vdERpcjtcclxuICBsZXQgY3VycmVudE5vZGUgPSAnJztcclxuICBsZXQgbm9kZVN0YWNrID0gWycnXTtcclxuICBsZXQgbm9kZVR5cGVTdGFjayA9IFsnJ107XHJcbiAgbGV0IGRpclN0YWNrID0gW3Jvb3REaXJdO1xyXG4gIGxldCB3ZlN0YWNrID0gW3Jvb3RXb3JrZmxvd107XHJcbiAgbGV0IGNoaWxkcmVuVmlld0JveExpc3QgPSBbXTtcclxuXHJcbiAgbGV0IHByb2plY3RMb290RGlyID0gY3VycmVudFdvcmtEaXI7XHJcblxyXG4gIC8vIGNyZWF0ZSB2dWUuanMgaW5zdGFuY2UgZm9yIHByb3BlcnR5IHN1YnNjcmVlblxyXG4gIGxldCB2bSA9IG5ldyBWdWUoe1xyXG4gICAgZWw6ICcjcHJvcGVydHknLFxyXG4gICAgZGF0YToge1xyXG4gICAgICBub2RlOiB7fSxcclxuICAgICAgbmV3SW5wdXRGaWxlbmFtZTogXCJcIixcclxuICAgICAgbmV3T3V0cHV0RmlsZW5hbWU6IFwiXCIsXHJcbiAgICAgIG5ld0luZGV4T2ZGb3JlYWNoOiBcIlwiLFxyXG4gICAgICBuYW1lczogW11cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOntcclxuICAgICAgYWRkSW5wdXRGaWxlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGxldCBmaWxlbmFtZT10aGlzLm5ld0lucHV0RmlsZW5hbWU7XHJcbiAgICAgICAgaWYoZmlsZW5hbWUgPT09IFwiXCIpIHJldHVyblxyXG4gICAgICAgIGxldCBkdXBsaWNhdGUgPSB0aGlzLm5vZGUuaW5wdXRGaWxlcy5zb21lKChlKT0+e1xyXG4gICAgICAgICAgcmV0dXJuIGUubmFtZSA9PT0gZmlsZW5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYoZHVwbGljYXRlKSByZXR1cm5cclxuICAgICAgICB0aGlzLm5ld0lucHV0RmlsZW5hbWU9XCJcIjtcclxuICAgICAgICBsZXQgbmV3VmFsPXtuYW1lOiBmaWxlbmFtZSwgc3JjTm9kZTogbnVsbCwgc3JjTmFtZTogbnVsbH1cclxuICAgICAgICBzaW8uZW1pdCgndXBkYXRlTm9kZScsIHtpbmRleDogdGhpcy5ub2RlLmluZGV4LCBwcm9wZXJ0eTogJ2lucHV0RmlsZXMnLCB2YWx1ZTogbmV3VmFsLCBjbWQ6ICdhZGQnfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGFkZE91dHB1dEZpbGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgbGV0IGZpbGVuYW1lPXRoaXMubmV3T3V0cHV0RmlsZW5hbWU7XHJcbiAgICAgICAgaWYoZmlsZW5hbWUgPT09IFwiXCIpIHJldHVyblxyXG4gICAgICAgIGxldCBkdXBsaWNhdGUgPSB0aGlzLm5vZGUub3V0cHV0RmlsZXMuc29tZSgoZSk9PntcclxuICAgICAgICAgIHJldHVybiBlLm5hbWUgPT09IGZpbGVuYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmKGR1cGxpY2F0ZSkgcmV0dXJuXHJcbiAgICAgICAgdGhpcy5uZXdPdXRwdXRGaWxlbmFtZT1cIlwiO1xyXG4gICAgICAgIGxldCBuZXdWYWw9e25hbWU6IGZpbGVuYW1lLCBkc3Q6IFtdfVxyXG4gICAgICAgIHNpby5lbWl0KCd1cGRhdGVOb2RlJywge2luZGV4OiB0aGlzLm5vZGUuaW5kZXgsIHByb3BlcnR5OiAnb3V0cHV0RmlsZXMnLCB2YWx1ZTogbmV3VmFsLCBjbWQ6ICdhZGQnfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGFkZEluZGV4T2ZGb3JlYWNoOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGxldCB2YWwgPSB0aGlzLm5ld0luZGV4T2ZGb3JlYWNoO1xyXG4gICAgICAgIGlmKHZhbCA9PT0gXCJcIikgcmV0dXJuXHJcbiAgICAgICAgbGV0IGR1cGxpY2F0ZSA9IHRoaXMubm9kZS5pbmRleExpc3Quc29tZSgoZSk9PntcclxuICAgICAgICAgIHJldHVybiBlLmxhYmVsID09PSB2YWw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYoZHVwbGljYXRlKSByZXR1cm5cclxuICAgICAgICB0aGlzLm5ld0luZGV4T2ZGb3JlYWNoID0gXCJcIjtcclxuICAgICAgICBsZXQgbmV3VmFsID0ge2xhYmVsOiB2YWx9O1xyXG4gICAgICAgIHNpby5lbWl0KCd1cGRhdGVOb2RlJywge2luZGV4OiB0aGlzLm5vZGUuaW5kZXgsIHByb3BlcnR5OiAnaW5kZXhMaXN0JywgdmFsdWU6IG5ld1ZhbCwgY21kOiAnYWRkJ30pO1xyXG4gICAgICB9LFxyXG4gICAgICBkZWxJbnB1dEZpbGU6IGZ1bmN0aW9uKGkpe1xyXG4gICAgICAgIGxldCB2YWwgPSB0aGlzLm5vZGUuaW5wdXRGaWxlc1tpXVxyXG4gICAgICAgIHNpby5lbWl0KCd1cGRhdGVOb2RlJywge2luZGV4OiB0aGlzLm5vZGUuaW5kZXgsIHByb3BlcnR5OiAnaW5wdXRGaWxlcycsIHZhbHVlOiB2YWwsIGNtZDogJ2RlbCd9KTtcclxuICAgICAgfSxcclxuICAgICAgZGVsT3V0cHV0RmlsZTogZnVuY3Rpb24oaSl7XHJcbiAgICAgICAgbGV0IHZhbCA9IHRoaXMubm9kZS5vdXRwdXRGaWxlc1tpXVxyXG4gICAgICAgIHNpby5lbWl0KCd1cGRhdGVOb2RlJywge2luZGV4OiB0aGlzLm5vZGUuaW5kZXgsIHByb3BlcnR5OiAnb3V0cHV0RmlsZXMnLCB2YWx1ZTogdmFsLCBjbWQ6ICdkZWwnfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGRlbEluZGV4T2ZGb3JlYWNoOiBmdW5jdGlvbihpKXtcclxuICAgICAgICBsZXQgdmFsID0gdGhpcy5ub2RlLmluZGV4TGlzdFtpXVxyXG4gICAgICAgIHNpby5lbWl0KCd1cGRhdGVOb2RlJywge2luZGV4OiB0aGlzLm5vZGUuaW5kZXgsIHByb3BlcnR5OiAnaW5kZXhMaXN0JywgdmFsdWU6IHZhbCwgY21kOiAnZGVsJ30pO1xyXG4gICAgICB9LFxyXG4gICAgICB1cGRhdGVOb2RlTmFtZTogZnVuY3Rpb24oKXtcclxuICAgICAgICBsZXQgdmFsID0gdGhpcy5ub2RlLm5hbWU7XHJcbiAgICAgICAgbGV0IGR1cCA9IHRoaXMubmFtZXMuc29tZSgobmFtZSk9PntcclxuICAgICAgICAgIHJldHVybiBuYW1lID09PSB2YWw7XHJcbiAgICAgICAgfSlcclxuICAgICAgICBpZighIGR1cCl7XHJcbiAgICAgICAgICBzaW8uZW1pdCgndXBkYXRlTm9kZScsIHtpbmRleDogdGhpcy5ub2RlLmluZGV4LCBwcm9wZXJ0eTogJ25hbWUnLCB2YWx1ZTogdGhpcy5ub2RlLm5hbWUsIGNtZDogJ3VwZGF0ZSd9KTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdkdXBsaWNhdGVkIG5hbWUgaXMgbm90IGFsbG93ZCEnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHVwZGF0ZVByb3BlcnR5OiBmdW5jdGlvbihwcm9wZXJ0eSwgYXJyYXlGbGFnKXtcclxuICAgICAgICBsZXQgdmFsPXRoaXMubm9kZVtwcm9wZXJ0eV07XHJcbiAgICAgICAgbGV0IGNtZCA9IGFycmF5RmxhZyA/ICd1cGRhdGFBcnJheVByb3BlcnR5JzogJ3VwZGF0ZSc7XHJcbiAgICAgICAgc2lvLmVtaXQoJ3VwZGF0ZU5vZGUnLCB7aW5kZXg6IHRoaXMubm9kZS5pbmRleCwgcHJvcGVydHk6IHByb3BlcnR5LCB2YWx1ZTogdmFsLCBjbWQ6IGNtZH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIHNldCBkZWZhdWx0IHZpZXdcclxuICAkKCcjcHJvamVjdF9tYW5hZ2VfYXJlYScpLmhpZGUoKTtcclxuICAkKCcjZ3JhcGhWaWV3JykucHJvcCgnY2hlY2tlZCcsIHRydWUpO1xyXG4gICQoJyNsb2dfYXJlYScpLmhpZGUoKTtcclxuICAkKCcjcHJvcGVydHknKS5oaWRlKCk7XHJcbiAgJCgnI3BhcmVudERpckJ0bicpLmhpZGUoKTtcclxuICAkKCcjdGFza0xpYnJhcnlNZW51JykuaGlkZSgpO1xyXG5cclxuICAvLyBzZXR1cCBzb2NrZXQuaW8gY2xpZW50XHJcbiAgY29uc3Qgc2lvID0gaW8oJy93b3JrZmxvdycpO1xyXG5cclxuICAvLyBzZXR1cCBGaWxlQnJvd3NlclxyXG4gIGNvbnN0IGZiID0gbmV3IEZpbGVCcm93c2VyKHNpbywgJyNmaWxlTGlzdCcsICdmaWxlTGlzdCcsIHRydWUsIHtcclxuICAgICdlZGl0Jzoge1xyXG4gICAgICBuYW1lOiAnZWRpdCcsXHJcbiAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBjb25zdCBwYXRoID0gJCh0aGlzKS5kYXRhKCdwYXRoJyk7XHJcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAkKHRoaXMpLmRhdGEoJ25hbWUnKTtcclxuICAgICAgICBjb25zdCBwYXJhbXM9ICQucGFyYW0oe1xyXG4gICAgICAgICAgXCJwYXRoXCI6IHBhdGgsXHJcbiAgICAgICAgICBcImZpbGVuYW1lXCI6IGZpbGVuYW1lLFxyXG4gICAgICAgICAgXCJwbVwiOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdpbmRvdy5vcGVuKGAvZWRpdG9yPyR7cGFyYW1zfWApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgJ2VkaXQgZm9yIHBhcmFtZXRlciBzdXJ2ZXknOiB7XHJcbiAgICAgIG5hbWU6ICdlZGl0IGZvciBQUycsXHJcbiAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBjb25zdCBwYXRoID0gJCh0aGlzKS5kYXRhKCdwYXRoJyk7XHJcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAkKHRoaXMpLmRhdGEoJ25hbWUnKTtcclxuICAgICAgICBjb25zdCBwYXJhbXM9ICQucGFyYW0oe1xyXG4gICAgICAgICAgXCJwYXRoXCI6IHBhdGgsXHJcbiAgICAgICAgICBcImZpbGVuYW1lXCI6IGZpbGVuYW1lLFxyXG4gICAgICAgICAgXCJwbVwiOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgd2luZG93Lm9wZW4oYC9lZGl0b3I/JHtwYXJhbXN9YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFRPRE8gZG93bmxvYWQgXHJcbiAgICAvLyAsJ2Rvd25sb2FkIGZpbGUnOiB7XHJcbiAgICAvLyAgIG5hbWU6ICdEb3dubG9hZCcsXHJcbiAgICAvLyAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHtcclxuICAgIC8vICAgICBjb25zdCBwYXRoID0gJCh0aGlzKS5kYXRhKCdwYXRoJyk7XHJcbiAgICAvLyAgICAgY29uc3QgZmlsZW5hbWUgPSAkKHRoaXMpLmRhdGEoJ25hbWUnKTtcclxuICAgIC8vICAgICBjb25zdCBtZXNzYWdlPSB7XHJcbiAgICAvLyAgICAgICBcInBhdGhcIjogcGF0aCxcclxuICAgIC8vICAgICAgIFwibmFtZVwiOiBmaWxlbmFtZVxyXG4gICAgLy8gICAgIH07XHJcbiAgICAvLyAgICAgc2lvLmVtaXQoJ2Rvd25sb2FkJywgbWVzc2FnZSk7XHJcbiAgICAvLyAgIH1cclxuICAgIC8vIH1cclxuICB9KTtcclxuXHJcbiAgLy8gc2lvLm9uKCdkb3dubG9hZCcsIChtZXNzYWdlKSA9PiB7XHJcbiAgLy8gICBjb25zb2xlLmxvZyhtZXNzYWdlLnRvU3RyaW5nKCkpO1xyXG4gIC8vIH0pO1xyXG5cclxuICAvLyBjb250YWluZXIgb2Ygc3ZnIGVsZW1lbnRzXHJcbiAgbGV0IG5vZGVzID0gW107XHJcbiAgbGV0IHBhcmVudG5vZGUgPVtdO1xyXG4gIGxldCBzZWxlY3RlZE5vZGUgPSAwO1xyXG4gIGxldCBzZWxlY3RlZFBhcmVudCA9IDA7XHJcbiAgbGV0IHJlbW90ZWhvc3QgPSAnJztcclxuICBsZXQgcmVtb3RlaG9zdEFycmF5ID0gW107XHJcbiAgbGV0IHF1ZXVlQXJyYXkgPSBbXTtcclxuICBsZXQgc2VsZWN0ZWRIb3N0UXVldWUgPSAnJztcclxuXHJcbiAgY29uc3Qgc3ZnID0gU1ZHKCdub2RlX3N2ZycpO1xyXG4gIHNpby5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcclxuICAgIGZiLnJlcXVlc3QoJ2dldEZpbGVMaXN0JywgY3VycmVudFdvcmtEaXIsIG51bGwpO1xyXG4gICAgc2lvLmVtaXQoJ2dldFdvcmtmbG93JywgY3VycmVudFdvcmtGbG93KTtcclxuICAgIHNpby5lbWl0KCdnZXRQcm9qZWN0SnNvbicsIHJvb3RXb3JrZmxvdyk7XHJcbiAgICBzaW8uZW1pdCgnZ2V0UHJvamVjdFN0YXRlJywgcm9vdFdvcmtmbG93KTtcclxuICAgIFxyXG4gICAgc2lvLm9uKCd3b3JrZmxvdycsIGZ1bmN0aW9uKHdmKXtcclxuICAgICAgY29uc29sZS5sb2coXCJvblwiKTtcclxuICAgICAgXHJcbiAgICAgIG5vZGVTdGFja1tub2RlU3RhY2subGVuZ3RoIC0gMV0gPSB3Zi5uYW1lO1xyXG4gICAgICBub2RlVHlwZVN0YWNrW25vZGVTdGFjay5sZW5ndGggLSAxXSA9IHdmLnR5cGU7XHJcblxyXG4gICAgICB1cGRhdGVCcmVhZHJ1bWIoKTtcclxuXHJcbiAgICAgIC8vIHJlbW92ZSBhbGwgbm9kZSBmcm9tIHdvcmtmbG93IGVkaXRvclxyXG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIGlmICh2ICE9PSBudWxsKSB2LnJlbW92ZSgpO1xyXG4gICAgICB9KTtcclxuICAgICAgbm9kZXMgPSBbXTtcclxuICAgICAgaWYgKHdmLm5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBsZXQgbmFtZXMgPSB3Zi5ub2Rlcy5tYXAoKGUpID0+IHtcclxuICAgICAgICAgIHJldHVybiBlICE9IG51bGw/IGUubmFtZSA6IG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdm0ubmFtZXMgPSBuYW1lcztcclxuICAgICAgICB2bS5ub2RlID0gd2Yubm9kZXNbc2VsZWN0ZWROb2RlXTtcclxuICAgICAgfVxyXG4gICAgICAvL3JlbW92ZSBwYXJlbnQgbm9kZVxyXG4gICAgICBwYXJlbnRub2RlLmZvckVhY2goZnVuY3Rpb24odnYpe1xyXG4gICAgICAgIGlmICh2diAhPT0gbnVsbCkgdnYucmVtb3ZlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBwYXJlbnRub2RlID0gW107XHJcbiAgICAgIGlmICh3Zi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgbGV0IG5hbWVzID0gd2YubWFwKChlKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gZSAhPSBudWxsPyBlLm5hbWUgOiBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZtLm5hbWVzID0gbmFtZXM7XHJcbiAgICAgICAgdm0ubm9kZSA9IHdmW3NlbGVjdGVkUGFyZW50XTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coXCJkcmF3XCIpO1xyXG4gICAgICBjb25zb2xlLmxvZyh3Zi5ub2Rlcyk7XHJcbiAgICAgIFxyXG4gICAgICBkcmF3Tm9kZXMod2Yubm9kZXMpO1xyXG4gICAgICBkcmF3TGlua3Mobm9kZXMpO1xyXG4gICAgICBkcmF3UGFyZW50RmlsZVJlbGF0aW9uKHdmKTtcclxuICAgICAgZHJhd1BhcmVudExpbmtzKHBhcmVudG5vZGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy/lrZDooajnpLrnlKjjgajjgZfjgabkvZzmiJDjgZfjgZ/jgYzlrp/oo4Xmlrnms5XlpInmm7Tjga7jgZ/jgoHkuIDmmYLnmoTjgavjgrPjg6Hjg7Pjg4jjgqLjgqbjg4hcclxuLyogICAgIC8vY2hpbGRyZW4gbm9kZXMgdmlld1xyXG4gICAgbGV0IGNoaWxkcmVuTm9kZXMgPSBbXTtcclxuICAgIGxldCBzZWxlY3RlZENoaWxkcmVuTm9kZXMgPSAwOyAgICBcclxuICAgIHNpby5vbignbm9kZXMnLCBmdW5jdGlvbih3ZkZvckNoaWxkcmVuKXtcclxuICAgICAgY29uc29sZS5sb2coXCJzaW8ub24gZHJhd05vZGVzTm9kZXNcIik7ICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKHdmRm9yQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgXHJcbiAgICAgIGNoaWxkcmVuTm9kZXMuZm9yRWFjaChmdW5jdGlvbih2KXtcclxuICAgICAgICBpZiAodiAhPT0gbnVsbCkgdi5yZW1vdmUoKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGNoaWxkcmVuTm9kZXMgPSBbXTtcclxuICAgICAgaWYgKHdmRm9yQ2hpbGRyZW4ubm9kZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGxldCBuYW1lcyA9IHdmRm9yQ2hpbGRyZW4ubm9kZXMubWFwKChlKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gZSAhPSBudWxsPyBlLm5hbWUgOiBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZtLm5hbWVzID0gbmFtZXM7XHJcbiAgICAgICAgdm0ubm9kZSA9IHdmRm9yQ2hpbGRyZW4ubm9kZXNbc2VsZWN0ZWRDaGlsZHJlbk5vZGVzXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coXCJTVkctZHJhd05vZGVzTm9kZXNcIik7ICAgICAgXHJcbiAgICAgIGRyYXdOb2Rlc05vZGVzKHdmRm9yQ2hpbGRyZW4ubm9kZXMpO1xyXG4gICAgfSk7Ki9cclxuICAgIFxyXG4gICAgc2lvLm9uKCd0YXNrU3RhdGVMaXN0JywgKHRhc2tTdGF0ZUxpc3QpID0+IHtcclxuICAgICAgdXBkYXRlVGFza1N0YXRlVGFibGUodGFza1N0YXRlTGlzdCk7XHJcbiAgICAgfSlcclxuXHJcbiAgICAvLyBUT0RPIOePvuWcqOOBruODl+ODreOCuOOCp+OCr+ODiOeKtuaFi+OBruWPluW+l+OCkuOCteODvOODkOOBq+ODquOCr+OCqOOCueODiOOBmeOCi1xyXG4gICAgc2lvLm9uKCdwcm9qZWN0SnNvbicsIChwcm9qZWN0SnNvbikgPT4ge1xyXG5cclxuICAgICAgJCgnI3Byb2plY3RfbmFtZScpLnRleHQocHJvamVjdEpzb24ubmFtZSk7XHJcbiAgICAgICQoJyNwcm9qZWN0X3N0YXRlJykudGV4dChwcm9qZWN0SnNvbi5zdGF0ZSk7XHJcbiAgICAgIC8vIOS7ruOBp+ePvuWcqOaXpeaZguOCkuihqOekulxyXG4gICAgICBsZXQgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgbGV0IGRhdGUgPSAnJyArIG5vdy5nZXRGdWxsWWVhcigpICsgJy8nICsgbm93LmdldE1vbnRoKCkgKyAnLycgKyBub3cuZ2V0RGF0ZSgpICsgJyAnICsgbm93LmdldEhvdXJzKCkgKyAnOicgKyAoJzAnICsgbm93LmdldE1pbnV0ZXMoKSkuc2xpY2UoLTIpO1xyXG4gICAgICAkKCcjcHJvamVjdF9jcmVhdGVfZGF0ZScpLnRleHQocHJvamVjdEpzb24uY3RpbWUpO1xyXG4gICAgICAkKCcjcHJvamVjdF91cGRhdGVfZGF0ZScpLnRleHQocHJvamVjdEpzb24ubXRpbWUpO1xyXG5cclxuICAgIH0pO1xyXG5cclxuICAgIHNpby5vbigncHJvamVjdFN0YXRlJywgKHN0YXRlKT0+e1xyXG4gICAgICBjb25zb2xlLmxvZyhcInN0YXRldGVzdFwiKTtcclxuICAgICAgaWYgKHN0YXRlID09PSAncnVubmluZycpIHtcclxuICAgICAgICAkKCcjcHJvamVjdF9zdGF0ZScpLnRleHQoJ1J1bm5pbmcnKTtcclxuICAgICAgfSBlbHNlIGlmKHN0YXRlID09PSAnZmFpbGVkJykge1xyXG4gICAgICAgICQoJyNwcm9qZWN0X3N0YXRlJykudGV4dCgnRmFpbGVkJyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdmaW5pc2hlZCcpIHtcclxuICAgICAgICAkKCcjcHJvamVjdF9zdGF0ZScpLnRleHQoJ0ZpbmlzaGVkJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgJCgnI3Byb2plY3Rfc3RhdGUnKS50ZXh0KCdOb3QtU3RhcnRlZCcpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKmNyZWF0ZSBob3N0LCBxdWV1ZSBzZWxlY3Rib3gqLyBcclxuICAgIHNpby5vbignaG9zdExpc3QnLCBmdW5jdGlvbihob3N0bGlzdCl7XHJcbiAgICAgIGNvbnNvbGUubG9nKGhvc3RsaXN0KTtcclxuICAgICAgbGV0IHJlbW90ZWhvc3RTZWxlY3RGaWVsZCA9ICQoJyNyZW1vdGVob3N0U2VsZWN0RmllbGQnKTtcclxuICAgICAgcmVtb3RlaG9zdFNlbGVjdEZpZWxkLmVtcHR5KCk7XHJcbiAgICAgIHJlbW90ZWhvc3RBcnJheSA9IFtdO1xyXG4gICAgICBcclxuICAgICAgcmVtb3RlaG9zdFNlbGVjdEZpZWxkLmFwcGVuZChgPG9wdGlvbiB2YWx1ZT1cImxvY2FsaG9zdFwiPmxvY2FsaG9zdDwvb3B0aW9uPmApO1xyXG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgaG9zdGxpc3QubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgcmVtb3RlaG9zdFNlbGVjdEZpZWxkLmFwcGVuZChgPG9wdGlvbiB2YWx1ZT1cIiR7aG9zdGxpc3RbaW5kZXhdLm5hbWV9XCI+JHtob3N0bGlzdFtpbmRleF0ubmFtZX08L29wdGlvbj5gKTtcclxuICAgICAgICByZW1vdGVob3N0QXJyYXkucHVzaChob3N0bGlzdFtpbmRleF0ubmFtZSk7XHJcbiAgICAgIH1cclxuICAgICAgLy9zZWxlY3Rib3jjgbjjga7oqK3lrppcclxuICAgICAgcmVtb3RlaG9zdFNlbGVjdEZpZWxkLnZhbChyZW1vdGVob3N0KTtcclxuICAgICAgY29uc29sZS5sb2cocmVtb3RlaG9zdCk7ICAgICAgXHJcbiAgICAgIFxyXG4gICAgICBsZXQgcXVldWVTZWxlY3RGaWVsZCA9ICQoJyNxdWV1ZVNlbGVjdEZpZWxkJyk7XHJcbiAgICAgICQoJyNyZW1vdGVob3N0U2VsZWN0RmllbGQnKS5jaGFuZ2UoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coaG9zdGxpc3QpOyAgICAgICAgXHJcbiAgICAgICAgcXVldWVTZWxlY3RGaWVsZC5lbXB0eSgpO1xyXG4gICAgICAgIGxldCBzZWxlY3RlZEhvc3QgPSAkKCcjcmVtb3RlaG9zdFNlbGVjdEZpZWxkIG9wdGlvbjpzZWxlY3RlZCcpLnRleHQoKTsgICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHNlbGVjdGVkSG9zdCA9PT0gJ2xvY2FsaG9zdCcpe1xyXG4gICAgICAgICAgcXVldWVBcnJheSA9IFsnbnVsbCddO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsZXQgaG9zdExpc3RJbmRleCA9IHJlbW90ZWhvc3RBcnJheS5pbmRleE9mKHNlbGVjdGVkSG9zdCk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhzZWxlY3RlZEhvc3QpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coaG9zdExpc3RJbmRleCk7XHJcbiAgICAgICAgICBsZXQgcXVldWVMaXN0ID0gaG9zdGxpc3RbaG9zdExpc3RJbmRleF0ucXVldWU7XHJcbiAgICAgICAgICBxdWV1ZUFycmF5ID0gcXVldWVMaXN0LnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICBxdWV1ZVNlbGVjdEZpZWxkLmFwcGVuZChgPG9wdGlvbiB2YWx1ZT1cIm51bGxcIj5udWxsPC9vcHRpb24+YCk7ICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZUFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgcXVldWVTZWxlY3RGaWVsZC5hcHBlbmQoYDxvcHRpb24gdmFsdWU9JHtxdWV1ZUFycmF5W2luZGV4XX0+JHtxdWV1ZUFycmF5W2luZGV4XX08L29wdGlvbj5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVTZWxlY3RGaWVsZC52YWwoc2VsZWN0ZWRIb3N0UXVldWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbi8qIFxyXG4gICAgc2lvLmVtaXQoJ2dldFdvcmtmbG93JywgY3VycmVudFdvcmtGbG93KTtcclxuXHJcbiAgICAvL+S4gOWFiOOBmuOBk+OBk+OBp2VtaXTjgZfjgajjgY9cclxuICAgIHNpby5lbWl0KCdnZXRQcm9qZWN0SnNvbicsIHJvb3RXb3JrZmxvdyk7ICovXHJcbiAgICBcclxuICAgIC8vc2V0dXAgbG9nIHJlY2lldmVyXHJcbiAgICBsb2dSZWNpZXZlcihzaW8pO1xyXG5cclxuICB9KTtcclxuXHJcbiAgLy8gcmVnaXN0ZXIgYnRuIGNsaWNrIGV2ZW50IGxpc3RlbmVyc1xyXG4gICQoJyNydW5fbWVudScpLm9uKCdjbGljaycsZnVuY3Rpb24oKXtcclxuICAgIHNpby5lbWl0KCdydW5Qcm9qZWN0Jywgcm9vdFdvcmtmbG93KTtcclxuICB9KTtcclxuICAkKCcjcGF1c2VfbWVudScpLm9uKCdjbGljaycsZnVuY3Rpb24oKXtcclxuICAgIHNpby5lbWl0KCdwYXVzZVByb2plY3QnLCB0cnVlKTtcclxuICB9KTtcclxuICAkKCcjY2xlYW5fbWVudScpLm9uKCdjbGljaycsZnVuY3Rpb24oKXtcclxuICAgIHNpby5lbWl0KCdjbGVhblByb2plY3QnLCB0cnVlKTtcclxuICB9KTtcclxuICAkKCcjc3RvcF9tZW51Jykub24oJ2NsaWNrJyxmdW5jdGlvbigpe1xyXG4gICAgc2lvLmVtaXQoJ3N0b3BQcm9qZWN0JywgdHJ1ZSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vc2F2ZSxyZXZlcnRcclxuICAkKCcjc2F2ZV9idXR0b24nKS5vbignY2xpY2snLGZ1bmN0aW9uKCl7XHJcbiAgICAvL+OCteODvOODkOODvOWBtOacquWun+ijhVxyXG4gICAgc2lvLmVtaXQoJ3NhdmVQcm9qZWN0JywgbnVsbCwgKHJlc3VsdCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gICQoJyNyZXZlcnRfYnV0dG9uJykub24oJ2NsaWNrJyxmdW5jdGlvbigpe1xyXG4gICAgLy/jgrXjg7zjg5Djg7zlgbTmnKrlrp/oo4VcclxuICAgIHNpby5lbWl0KCdyZXZlcnRQcm9qZWN0JywgbnVsbCwgKHJlc3VsdCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xyXG4gICAgfSk7XHJcbuOAgH0pO1xyXG5cclxuXHJcbiAgLy8gaGlkZSBwcm9wZXJ0eSBhbmQgc2VsZWN0IHBhcmVudCBXRiBpZiBiYWNrZ3JvdW5kIGlzIGNsaWNrZWRcclxuICAkKCcjbm9kZV9zdmcnKS5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oKXtcclxuICAgIGZiLnJlcXVlc3QoJ2dldEZpbGVMaXN0JywgY3VycmVudFdvcmtEaXIsIG51bGwpO1xyXG4gICAgJCgnI3Byb3BlcnR5JykuaGlkZSgpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBzZXR1cCBmaWxlIHVwbG9hZGVyXHJcbiAgY29uc3QgdXBsb2FkZXIgPSBuZXcgU29ja2V0SU9GaWxlVXBsb2FkKHNpbyk7XHJcbiAgdXBsb2FkZXIubGlzdGVuT25Ecm9wKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlQnJvd3NlcicpKTsgIFxyXG4gIHVwbG9hZGVyLmxpc3Rlbk9uSW5wdXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbGVTZWxlY3RvcicpKTtcclxuXHJcblxyXG4gIC8vIHNob3cgb3IgaGlkZSBsb2cgYXJlYVxyXG4gIHZhciBpc0Rpc3BsYXlMb2cgPSBmYWxzZTtcclxuICAkKCcjZGlzcGxheUxvZ0J1dHRvbicpLmNsaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgIGlzRGlzcGxheUxvZyA9ICFpc0Rpc3BsYXlMb2c7XHJcbiAgICBpZiAoaXNEaXNwbGF5TG9nKSB7XHJcbiAgICAgIHNob3dMb2coKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhpZGVMb2coKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy/jg5zjgr/jg7Pjgafjga52aWV344Gu5YiH44KK5pu/44GIXHJcbiAgJCgnI2xpc3RWaWV3JykuY2xpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgJCgnI3dvcmtmbG93X21hbmFnZV9hcmVhJykuaGlkZSgpO1xyXG4gICAgJCgnI3Byb2plY3RfbWFuYWdlX2FyZWEnKS5zaG93KCk7XHJcbiAgICBzaW8uZW1pdCgnZ2V0VGFza1N0YXRlTGlzdCcsIHJvb3RXb3JrZmxvdyk7XHJcbiAgfSk7XHJcbiAgJCgnI2dyYXBoVmlldycpLmNsaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICQoJyNwcm9qZWN0X21hbmFnZV9hcmVhJykuaGlkZSgpO1xyXG4gICAgJCgnI3dvcmtmbG93X21hbmFnZV9hcmVhJykuc2hvdygpO1xyXG4gIH0pOyBcclxuXHJcbiAgLy8gc2V0dXAgY29udGV4dCBtZW51XHJcbiAgJC5jb250ZXh0TWVudSh7XHJcbiAgICBzZWxlY3RvcjogJ2cnLFxyXG4gICAgYXV0b0hpZGU6IHRydWUsXHJcbiAgICByZXBvc2l0aW9uOiBmYWxzZSxcclxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbihpdGVtS2V5LCBvcHQpe1xyXG4gICAgICB2YXIgcG9zPWdldENsaWNrUG9zaXRpb24ob3B0KTtcclxuICAgICAgc2lvLmVtaXQoJ2NyZWF0ZU5vZGUnLCB7XCJ0eXBlXCI6IGl0ZW1LZXksIFwicG9zXCI6IHBvc30pO1xyXG4gICAgfSxcclxuICAgIGl0ZW1zOiB7XHJcbiAgICAgIC8qXCJuZXdcIjoge1xyXG4gICAgICAgICBcIm5hbWVcIjogXCJuZXdcIixcclxuICAgICAgICAgXCJpdGVtc1wiOlxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgXCJ0YXNrXCI6ICAgIHtuYW1lOiBcInRhc2tcIn0sXHJcbiAgICAgICAgICAgXCJ3b3JrZmxvd1wiOntuYW1lOiBcIndvcmtmbG93XCJ9LFxyXG4gICAgICAgICAgIFwiUFNcIjogICAgICB7bmFtZTogXCJwYXJhbWV0ZXIgc3R1ZHlcIn0sXHJcbiAgICAgICAgICAgXCJpZlwiOiAgICAgIHtuYW1lOiBcImlmXCJ9LFxyXG4gICAgICAgICAgIFwiZm9yXCI6ICAgICB7bmFtZTogXCJmb3JcIn0sXHJcbiAgICAgICAgICAgXCJ3aGlsZVwiOiAgIHtuYW1lOiBcIndoaWxlXCJ9LFxyXG4gICAgICAgICAgIFwiZm9yZWFjaFwiOiB7bmFtZTogXCJmb3JlYWNoXCJ9XHJcbiAgICAgICAgIH0gXHJcbiAgICAgIH0sKi9cclxuICAgICAgXCJkZWxldGVcIjoge1xyXG4gICAgICAgIFwibmFtZVwiOiBcImRlbGV0ZVwiLFxyXG5cclxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oKXtcclxuICAgICAgICAgIHNpby5lbWl0KCdyZW1vdmVOb2RlJywgc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy/jgr/jgrnjgq/jga7jg4njg6njg4PjgrDjgqLjg7Pjg4njg4njg63jg4Pjg5fmk43kvZxcclxuICAkKCcjd29ya2Zsb3dDb21wb25lbnRzIC50eXBlJykubW91c2VvdmVyKGZ1bmN0aW9uICgpIHsgICAgICBcclxuICAgIHZhciB0YXJnZXQgPSAkKHRoaXMpLmF0dHIoXCJpZFwiKTtcclxuICAgIHZhciBvYmplY3REcmFnID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KTsgXHJcbiAgICB2YXIgb2JqZWN0RHJvcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibm9kZV9zdmdcIik7XHJcblxyXG4gICAgb2JqZWN0RHJhZy5vbmRyYWdzdGFydCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0XCIsIGV2ZW50LnRhcmdldC5pZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIG9iamVjdERyb3Aub25kcmFnb3ZlciA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH07XHJcblxyXG4gICAgb2JqZWN0RHJvcC5vbmRyb3AgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHZhciBvYmplY3ROYW1lID0gZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0XCIpO1xyXG4gICAgICB2YXIgeENvb3JkaW5hdGUgPSBldmVudC5vZmZzZXRYO1xyXG4gICAgICB2YXIgeUNvb3JkaW5hdGUgPSBldmVudC5vZmZzZXRZO1xyXG4gIFxyXG4gICAgICBjb25zdCBwb3MgPSB7eDogeENvb3JkaW5hdGUsIHk6IHlDb29yZGluYXRlfTtcclxuICAgICAgc2lvLmVtaXQoJ2NyZWF0ZU5vZGUnLCB7XCJ0eXBlXCI6IG9iamVjdE5hbWUsIFwicG9zXCI6IHBvc30pOyAgICBcclxuICAgIH07XHJcbiAgfSk7XHJcblxyXG4gIC8v44K/44K544Kv44Op44Kk44OW44Op44Oq44O844Gu6KGo56S66Z2e6KGo56S6XHJcbiAgLy8gZnVuY3Rpb24gZGVmaW5pdGlvblxyXG4gIGZ1bmN0aW9uIHNob3dUYXNrTGlicmFyeSgpIHtcclxuICAgICQoJyN0YXNrTGlicmFyeUJ1dHRvbicpLnNob3coKS5hbmltYXRlKHtsZWZ0OiAnMjU2cHgnfSw1MCk7XHJcbiAgICAkKCcjdGFza0xpYnJhcnlNZW51Jykuc2hvdygpLmFuaW1hdGUoe3dpZHRoOiAnMjU2cHgnLCAnbWluLXdpZHRoJzogJzI1NnB4J30sIDUwKTtcclxuICAgICQoJyNsaWJyYXJ5QnV0dG9uJykuYXR0cihcInNyY1wiLCBcIi9pbWFnZS9idG5fb3BlbkNsb3NlTF9uLnBuZ1wiKTsgICAgXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBoaWRlVGFza0xpYnJhcnkoKSB7XHJcbiAgICAkKCcjdGFza0xpYnJhcnlCdXR0b24nKS5zaG93KCkuYW5pbWF0ZSh7bGVmdDogJy09MjU2cHgnfSwxMDApOyAgICBcclxuICAgICQoJyN0YXNrTGlicmFyeU1lbnUnKS5oaWRlKCk7XHJcbiAgICAkKCcjbGlicmFyeUJ1dHRvbicpLmF0dHIoXCJzcmNcIiwgXCIvaW1hZ2UvYnRuX29wZW5DbG9zZVJfbi5wbmdcIik7ICAgICAgICBcclxuICB9XHJcblxyXG4gIC8vIHNob3cgb3IgaGlkZSBsb2cgYXJlYVxyXG4gIHZhciBpc0Rpc3BsYXlMb2cgPSBmYWxzZTtcclxuICAkKCcjdGFza0xpYnJhcnlCdXR0b24nKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICBpc0Rpc3BsYXlMb2cgPSAhaXNEaXNwbGF5TG9nO1xyXG4gICAgaWYgKGlzRGlzcGxheUxvZykge1xyXG4gICAgICBzaG93VGFza0xpYnJhcnkoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhpZGVUYXNrTGlicmFyeSgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBmdW5jdGlvbiBkZWZpbml0aW9uXHJcbiAgZnVuY3Rpb24gc2hvd0xvZygpIHtcclxuICAgICQoJyNsb2dBcmVhJykuc2hvdygpO1xyXG4gICAgJCgnI2Rpc3BsYXlMb2dCdXR0b24nKS50b2dnbGVDbGFzcygnZGlzcGxheScsIHRydWUpO1xyXG4gICAgJCgnI2ltZ19kaXNwbGF5TG9nQnV0dG9uJykuYXR0cihcInNyY1wiLCBcIi9pbWFnZS9idG5fb3BlbkNsb3NlRF9uLnBuZ1wiKTsgICAgICAgIFxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaGlkZUxvZygpIHtcclxuICAgICQoJyNsb2dBcmVhJykuaGlkZSgpO1xyXG4gICAgJCgnI2Rpc3BsYXlMb2dCdXR0b24nKS50b2dnbGVDbGFzcygnZGlzcGxheScsIGZhbHNlKTtcclxuICAgICQoJyNpbWdfZGlzcGxheUxvZ0J1dHRvbicpLmF0dHIoXCJzcmNcIiwgXCIvaW1hZ2UvYnRuX29wZW5DbG9zZVVfbi5wbmdcIik7ICAgICAgICBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGdldCBtb3VzZSBwb3NpdG9pbiB3aGVyZSBjb250ZXh0bWVudSBpcyBjcmVhdGVkXHJcbiAgICogQHBhcmFtIG9wdGlvbiBzZWNvbmQgYXJndW1lbnQgb2YgY2FsbGJhY2sgZnVuY3Rpb24gb2YganF1ZXJ5LmNvbnRleHRNZW51XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZ2V0Q2xpY2tQb3NpdGlvbihvcHRpb24pIHtcclxuICAgIGNvbnN0IHBhcmVudE9mZnNldCA9ICQob3B0aW9uLnNlbGVjdG9yKS5vZmZzZXQoKTtcclxuICAgIGNvbnN0IGNsaWNrUG9zaXRpb24gPSBvcHRpb24uJG1lbnUucG9zaXRpb24oKTtcclxuICAgIGNvbnN0IHBvc2l0aW9uID0ge1xyXG4gICAgICB4OiBNYXRoLnJvdW5kKGNsaWNrUG9zaXRpb24ubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0KSxcclxuICAgICAgeTogTWF0aC5yb3VuZChjbGlja1Bvc2l0aW9uLnRvcCAtIHBhcmVudE9mZnNldC50b3ApXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogY2hlY2sgaWYgZmlsZW5hbWUgaXMgYWxyZWFkeSBpbiBpbnB1dEZpbGVzIG9yIG91dHB1dEZpbGVzXHJcbiAgICogQHBhcmFtIGZpbGVzIGlucHV0RmlsZXMgb3Igb3V0cHV0RmlsZXMgb2YgYW55IHdvcmtmbG93IGNvbXBvbmVudFxyXG4gICAqIEBwYXJhbSBmaWxlbmFtZSB0ZXN0ZWVcclxuICAgKi9cclxuICBmdW5jdGlvbiBpc0R1cHVsaWNhdGVkKGZpbGVzLCBmaWxlbmFtZSkge1xyXG4gICAgcmV0dXJuIC0xICE9PSBmaWxlcy5maW5kSW5kZXgoZnVuY3Rpb24odil7XHJcbiAgICAgIHJldHVybiB2Lm5hbWUgPT09IGZpbGVuYW1lO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBkcmF3IG5vZGVzXHJcbiAgICogQHBhcmFtIG5vZGVJbldGIG5vZGUgbGlzdCBpbiB3b3JrZmxvdyBKc29uXHJcbiAgICovXHJcbiAgdmFyIGJ1dHRvbkZsYWcgPSBmYWxzZTtcclxuICBmdW5jdGlvbiBkcmF3Tm9kZXMobm9kZXNJbldGKSB7XHJcbiAgICAgIG5vZGVzSW5XRi5mb3JFYWNoKGZ1bmN0aW9uKHYsaSl7XHJcbiAgICAgICAgY29uc29sZS5sb2codik7XHJcbiAgICAgICAgLy8gd29ya2Zsb3flhoXjga5ub2Rl44GoU1ZH6KaB57Sg44Gubm9kZeOBrmluZGV444GM5LiA6Ie044GZ44KL44KI44GG44GrbnVsbOOBp+a2iOOBleOCjOOBpuOBhOOCi+aZguOCgm5vZGVz44Gu6KaB57Sg44Gv5L2c5oiQ44GZ44KLXHJcbiAgICAgICAgaWYodiA9PT0gbnVsbCl7XHJcbiAgICAgICAgICBub2Rlcy5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgY2hpbGRyZW5WaWV3Qm94TGlzdC5wdXNoKG51bGwpO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgbGV0IG5vZGU9bmV3IHN2Z05vZGUuU3ZnTm9kZVVJKHN2Zywgc2lvLCB2KTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKG5vZGUpO1xyXG5cclxuLyogICAgICAgICAgIGxldCBjaGlsZHJlbldvcmtmbG93ID0gY3VycmVudFdvcmtEaXIrJy8nK3YubmFtZSsnLycrdi5qc29uRmlsZTtcclxuICAgICAgICAgIGlmKHYudHlwZSA9PT0gJ3dvcmtmbG93JyB8fCB2LnR5cGUgPT09ICdwYXJhbWV0ZXJTdHVkeScgfHwgdi50eXBlID09PSAnZm9yJyB8fCB2LnR5cGUgPT09ICd3aGlsZScgfHwgdi50eXBlID09PSAnZm9yZWFjaCcpe1xyXG4gICAgICAgICAgICBzaW8uZW1pdCgnZ2V0Tm9kZXMnLCBjaGlsZHJlbldvcmtmbG93KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNoaWxkcmVuVmlld0JveExpc3QucHVzaChzdmcpOyAqL1xyXG5cclxuICAgICAgICAgIG5vZGUub25Nb3VzZWRvd24oZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgIGxldCBub2RlSW5kZXg9ZS50YXJnZXQuaW5zdGFuY2UucGFyZW50KCcubm9kZScpLmRhdGEoJ2luZGV4Jyk7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkTm9kZT1ub2RlSW5kZXg7XHJcbiAgICAgICAgICAgIGxldCBuYW1lID0gbm9kZXNJbldGW25vZGVJbmRleF0ubmFtZTsgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IG5vZGVQYXRoID0gY3VycmVudFdvcmtEaXIrJy8nK25vZGVzSW5XRltub2RlSW5kZXhdLm5hbWU7XHJcbiAgICAgICAgICAgIC8v44OV44Kh44Kk44Or44OW44Op44Km44K255SoXHJcbiAgICAgICAgICAgIGZiLnJlcXVlc3QoJ2dldEZpbGVMaXN0Jywgbm9kZVBhdGgsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgLy/jg5fjg63jg5Hjg4bjgqPooajnpLrnlKjnm7jlr77jg5HjgrlcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRQcm9wZXJ0eURpciA9IFwiLlwiK2N1cnJlbnRXb3JrRGlyLnJlcGxhY2UocHJvamVjdExvb3REaXIsXCJcIikrXCIvXCIrbm9kZXNJbldGW25vZGVJbmRleF0ubmFtZTtcclxuICAgICAgICAgICAgbGV0IG5vZGVUeXBlID0gbm9kZXNJbldGW25vZGVJbmRleF0udHlwZTtcclxuICAgICAgICAgICAgLy9pY29u44Gu5aSJ5pu0XHJcbiAgICAgICAgICAgIGxldCBub2RlSWNvblBhdGggPSBjb25maWcubm9kZV9pY29uW25vZGVUeXBlXTtcclxuICAgICAgICAgICAgJCgnI2ltZ19ub2RlX3R5cGUnKS5hdHRyKFwic3JjXCIsIG5vZGVJY29uUGF0aCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihub2RlVHlwZSA9PT0gJ3Rhc2snKXtcclxuICAgICAgICAgICAgICBzaW8uZW1pdCgnZ2V0SG9zdExpc3QnLCB0cnVlKTtcclxuICAgICAgICAgICAgICAvL3Z1ZeOBp+ioreWumuOBl+OBn0pzb27jga7lgKTjgpLlvJXjgaPlvLXjgabjgY3jgabmj4/nlLvjgZnjgosgICAgICAgICAgICBcclxuICAgICAgICAgICAgICByZW1vdGVob3N0ID0gbm9kZXNJbldGW25vZGVJbmRleF0uaG9zdDsgICAgICAgIFxyXG4gICAgICAgICAgICAgIHNlbGVjdGVkSG9zdFF1ZXVlID0gbm9kZXNJbldGW25vZGVJbmRleF0ucXVldWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAkKCcjcHJvcGVydHlUeXBlTmFtZScpLmh0bWwobm9kZXNJbldGW25vZGVJbmRleF0udHlwZSk7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZtLm5vZGU9djtcclxuICAgICAgICAgICAgJCgnI2NvbXBvbmVudFBhdGgnKS5odG1sKGN1cnJlbnRQcm9wZXJ0eURpcik7XHJcbiAgICAgICAgICAgICQoJyNwcm9wZXJ0eScpLnNob3coKS5hbmltYXRlKHt3aWR0aDogJzI3MnB4JywgJ21pbi13aWR0aCc6ICcyNzJweCd9LCAxMDApO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5vbkRibGNsaWNrKGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRiY1wiKTsgICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IG5vZGVUeXBlPWUudGFyZ2V0Lmluc3RhbmNlLnBhcmVudCgnLm5vZGUnKS5kYXRhKCd0eXBlJyk7XHJcbiAgICAgICAgICAgIGlmKG5vZGVUeXBlID09PSAnd29ya2Zsb3cnIHx8bm9kZVR5cGUgPT09ICdwYXJhbWV0ZXJTdHVkeScgfHwgbm9kZVR5cGUgPT09ICdmb3InIHx8IG5vZGVUeXBlID09PSAnd2hpbGUnIHx8IG5vZGVUeXBlID09PSAnZm9yZWFjaCcpe1xyXG4gICAgICAgICAgICAgIGxldCBub2RlSW5kZXg9ZS50YXJnZXQuaW5zdGFuY2UucGFyZW50KCcubm9kZScpLmRhdGEoJ2luZGV4Jyk7XHJcbiAgICAgICAgICAgICAgbGV0IG5hbWUgPSBub2Rlc0luV0Zbbm9kZUluZGV4XS5uYW1lO1xyXG4gICAgICAgICAgICAgIGxldCBwYXRoPWUudGFyZ2V0Lmluc3RhbmNlLnBhcmVudCgnLm5vZGUnKS5kYXRhKCdwYXRoJyk7XHJcbiAgICAgICAgICAgICAgbGV0IGpzb249ZS50YXJnZXQuaW5zdGFuY2UucGFyZW50KCcubm9kZScpLmRhdGEoJ2pzb25GaWxlJyk7XHJcbiAgICAgICAgICAgICAgY3VycmVudFdvcmtEaXI9Y3VycmVudFdvcmtEaXIrJy8nK25hbWU7XHJcbiAgICAgICAgICAgICAgY3VycmVudFdvcmtGbG93PWN1cnJlbnRXb3JrRGlyKycvJytqc29uO1xyXG4gICAgICAgICAgICAgIC8vZGlyU3RhY2sucHVzaCh7ZGlyOiBjdXJyZW50V29ya0Rpciwgd2Y6IGN1cnJlbnRXb3JrRmxvd30pO1xyXG4gICAgICAgICAgICAgIGRpclN0YWNrLnB1c2goY3VycmVudFdvcmtEaXIpO1xyXG4gICAgICAgICAgICAgIHdmU3RhY2sucHVzaChjdXJyZW50V29ya0Zsb3cpO1xyXG4gICAgICAgICAgICAgIG5vZGVTdGFjay5wdXNoKG5hbWUpO1xyXG4gICAgICAgICAgICAgIG5vZGVUeXBlU3RhY2sucHVzaChub2RlVHlwZSk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coY3VycmVudFdvcmtEaXIpOyAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coY3VycmVudFdvcmtGbG93KTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgZmIucmVxdWVzdCgnZ2V0RmlsZUxpc3QnLCBjdXJyZW50V29ya0RpciwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgc2lvLmVtaXQoJ2dldFdvcmtmbG93JywgY3VycmVudFdvcmtGbG93KTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImVtaXRcIik7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAub25DbGljayhmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYnV0dG9uRmxhZyk7XHJcbiAgICAgICAgICAgIGxldCBub2RlVHlwZT1lLnRhcmdldC5pbnN0YW5jZS5wYXJlbnQoJy5ub2RlJykuZGF0YSgndHlwZScpO1xyXG4gICAgICAgICAgICBpZihub2RlVHlwZSA9PT0gJ3dvcmtmbG93JyB8fG5vZGVUeXBlID09PSAncGFyYW1ldGVyU3R1ZHknIHx8IG5vZGVUeXBlID09PSAnZm9yJyB8fCBub2RlVHlwZSA9PT0gJ3doaWxlJyB8fCBub2RlVHlwZSA9PT0gJ2ZvcmVhY2gnKXtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNsaWNrY2hlY2tcIik7XHJcbiAgICAgICAgICAgICAgaWYoIGJ1dHRvbkZsYWcgPT09IGZhbHNlKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZmxhZ2ZjaGVja1wiKTtcclxuICAgICAgICAgICAgICAgICQoJy52aWV3Tm9kZXMnKS5zaG93KCk7ICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgYnV0dG9uRmxhZyA9IHRydWU7ICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJCgnLnZpZXdOb2RlcycpLmNzcygnZGlzcGxheScsICdub25lJyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBidXR0b25GbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy/lrZDooajnpLrnlKjjgajjgZfjgabkvZzmiJDjgZfjgZ/jgYzlrp/oo4Xmlrnms5XlpInmm7Tjga7jgZ/jgoHkuIDmmYLnmoTjgavjgrPjg6Hjg7Pjg4jjgqLjgqbjg4hcclxuICAgIC8qKlxyXG4gICAqIGRyYXcgbm9kZXMgY2hpbGRyZW5cclxuICAgKiBAcGFyYW0gbm9kZUZvckNoaWxkcmVuIG5vZGUgbGlzdCBpbiB3b3JrZmxvdyBKc29uXHJcbiAgICovXHJcbiAgLyogZnVuY3Rpb24gZHJhd05vZGVzTm9kZXMobm9kZUZvckNoaWxkcmVuKXtcclxuICAgIC8vdmlld0JveExpc3TjgavnmbvpjLLjgZfjgZ/lrZDopoHntKDooajnpLrlr77osaFub2Rl44Gu44Kk44Oz44K544K/44Oz44K544KS5L2c5oiQ44GZ44KLXHJcbiAgICBub2RlRm9yQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbih2LGkpe1xyXG4gICAgICAvL2luZGV444GoaeOBjOS4gOe3kuOBruaZguOAgeWtkOihqOekuuOCkuOBmeOCi1xyXG4gICAgICBpZih2ICE9PSBudWxsKXtcclxuICAgICAgICBjb25zb2xlLmxvZyh2KTtcclxuICAgICAgICBjb25zb2xlLmxvZyhpKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhjaGlsZHJlblZpZXdCb3hMaXN0KTtcclxuICAgICAgICBsZXQgY2hpbGRyZW5Ob2RlID0gbmV3IHN2Z05vZGUuU3ZnQ2hpbGRyZW5Ob2RlVUkoY2hpbGRyZW5WaWV3Qm94TGlzdFtpXSwgdik7XHJcbiAgICAgICAgLy9sZXQgY2hpbGRyZW5Ob2RlID0gbmV3IHN2Z05vZGUuU3ZnQ2hpbGRyZW5Ob2RlVUkoc3ZnLCB2KTtcclxuXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0gKi9cclxuICAvKipcclxuICAgKiBkcmF3IGNhYmxlcyBiZXR3ZWVuIExvd2VyIGFuZCBVcHBlciBwbHVnIENvbm5lY3RvciBhbmQgUmVjZXB0b3IgcGx1ZyByZXNwZWN0aXZlbHlcclxuICAgKiBAcGFyYW0gbm9kZUluV0Ygbm9kZSBsaXN0IGluIHdvcmtmbG93IEpzb25cclxuICAgKi9cclxuICBmdW5jdGlvbiBkcmF3TGlua3Mobm9kZXMpIHtcclxuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSl7XHJcbiAgICAgIGlmKG5vZGUgIT0gbnVsbCl7XHJcbiAgICAgICAgbm9kZS5kcmF3TGlua3MoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpe1xyXG4gICAgICBpZihub2RlICE9IG51bGwpe1xyXG4gICAgICAgIG5vZGUubmV4dExpbmtzLmZvckVhY2goZnVuY3Rpb24oY2FibGUpe1xyXG4gICAgICAgICAgbGV0IGRzdCA9IGNhYmxlLmNhYmxlLmRhdGEoJ2RzdCcpO1xyXG4gICAgICAgICAgbm9kZXNbZHN0XS5wcmV2aW91c0xpbmtzLnB1c2goY2FibGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5vZGUuZWxzZUxpbmtzLmZvckVhY2goZnVuY3Rpb24oY2FibGUpe1xyXG4gICAgICAgICAgbGV0IGRzdCA9IGNhYmxlLmNhYmxlLmRhdGEoJ2RzdCcpO1xyXG4gICAgICAgICAgbm9kZXNbZHN0XS5wcmV2aW91c0xpbmtzLnB1c2goY2FibGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5vZGUub3V0cHV0RmlsZUxpbmtzLmZvckVhY2goZnVuY3Rpb24oY2FibGUpe1xyXG4gICAgICAgICAgbGV0IGRzdCA9IGNhYmxlLmNhYmxlLmRhdGEoJ2RzdCcpO1xyXG4gICAgICAgICAgbm9kZXNbZHN0XS5pbnB1dEZpbGVMaW5rcy5wdXNoKGNhYmxlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAqIGRyYXcgcGFyZW50IGNoaWxkcmVuIGZpbGUgcmVsYXRpb25cclxuICAgKiBAcGFyYW0gIGZpbGVzIGxpc3QgaW4gd29ya2Zsb3cgSnNvblxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGRyYXdQYXJlbnRGaWxlUmVsYXRpb24ocGFyZW50d2Ype1xyXG4gICAgLy9zZWxlY3RlZFBhcmVudCA9IG5vZGVJbmRleDsgICAgXHJcbiAgICBsZXQgbm9kZT1uZXcgc3ZnTm9kZS5TdmdQYXJlbnROb2RlVUkoc3ZnLCBzaW8sIHBhcmVudHdmKTtcclxuICAgIHBhcmVudG5vZGUucHVzaChub2RlKTtcclxuICAgIGNvbnNvbGUubG9nKFwicGFyZW50bm9kZVwiKTtcclxuICAgIGNvbnNvbGUubG9nKHBhcmVudG5vZGUpO1xyXG4vKiAgICAgcGFyZW50d2YuaW5wdXRGaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGlucHV0RmlsZXMpe1xyXG4gICAgICBpZihpbnB1dEZpbGVzICE9IG51bGwpe1xyXG4gICAgICAgIGlucHV0RmlsZXMuZHJhd1BhcmVudEZpbGVSZWxhdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICB9KTsgKi9cclxuICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICogZHJhdyBjYWJsZXMgYmV0d2VlbiBMb3dlciBhbmQgVXBwZXIgcGx1ZyBDb25uZWN0b3IgYW5kIFJlY2VwdG9yIHBsdWcgcmVzcGVjdGl2ZWx5XHJcbiAgICogQHBhcmFtIG5vZGVJbldGIG5vZGUgbGlzdCBpbiB3b3JrZmxvdyBKc29uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZHJhd1BhcmVudExpbmtzKHBhcmVudG5vZGUpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiZHJhdyBQYXJlbnQgTGlua1wiKTtcclxuICAgIHBhcmVudG5vZGUuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcclxuICAgICAgaWYobm9kZSAhPSBudWxsKXtcclxuICAgICAgICBub2RlLmRyYXdQYXJlbnRMaW5rcygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHBhcmVudG5vZGUuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcclxuICAgICAgaWYobm9kZSAhPSBudWxsKXtcclxuICAgICAgICBub2RlLm91dHB1dEZpbGVMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGNhYmxlKXtcclxuICAgICAgICAgIGxldCBkc3QgPSBjYWJsZS5jYWJsZS5kYXRhKCdkc3QnKTtcclxuICAgICAgICAgIHBhcmVudG5vZGVbZHN0XS5pbnB1dEZpbGVMaW5rcy5wdXNoKGNhYmxlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVCcmVhZHJ1bWIoKSB7XHJcbiAgICBsZXQgYnJlYWRjcnVtYiA9ICQoJyNicmVhZGNydW1iJyk7XHJcbiAgICBicmVhZGNydW1iLmVtcHR5KCk7XHJcblxyXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG5vZGVTdGFjay5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgaWYgKDAgPCBpbmRleCkge1xyXG4gICAgICAgIGJyZWFkY3J1bWIuYXBwZW5kKGA8c3BhbiBjbGFzcz1cImltZ19wYW5rdXp1QXJyb3dfaWNvblwiPjxpbWcgc3JjPVwiL2ltYWdlL2ltZ19wYW5rdXp1QXJyb3cucG5nXCIgIC8+PC9zcGFuPmApIFxyXG4gICAgICB9XHJcbiAgICAgIGxldCBpZCA9IGBicmVhZGNydW1iQnV0dG9uXyR7aW5kZXh9YDtcclxuICAgICAgLy9pY29u44Gu6Kit5a6aXHJcbiAgICAgIGxldCBub2RlSWNvblBhdGggPSBjb25maWcubm9kZV9pY29uW25vZGVUeXBlU3RhY2tbaW5kZXhdXTtcclxuICAgICAgbGV0IGNvcnJlY3ROb2RlSWNvblBhdGggPSBub2RlSWNvblBhdGgucmVwbGFjZShcIi5wbmdcIixcIl9wLnBuZ1wiKTsgXHJcbiAgICAgIGxldCBub2RlQ29sb3IgPSBjb25maWcubm9kZV9jb2xvcltub2RlVHlwZVN0YWNrW2luZGV4XV07XHJcbiAgICAgIGJyZWFkY3J1bWIuYXBwZW5kKGA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBpZD0ke2lkfSBjbGFzcz1cImJyZWFkY3J1bWJCdXR0b25cIiB2YWx1ZT0ke25vZGVTdGFja1tpbmRleF19PlxyXG4gICAgICAgIDxpbWcgc3JjPSR7Y29ycmVjdE5vZGVJY29uUGF0aH0gY2xhc3M9XCJpbWdfYnJlYWRjcnVtYkJ1dHRvbl9pY29uXCIgLz48c3BhbiBjbGFzcz1cImJyZWFkY3J1bmJOYW1lXCI+JHtub2RlU3RhY2tbaW5kZXhdfTwvc3Bhbj48L2J1dHRvbj5gKVxyXG4gICAgICAkKGAjJHtpZH1gKS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIG5vZGVDb2xvcik7XHJcbiAgICAgIFxyXG4gICAgICAkKGAjJHtpZH1gKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHdoaWxlIChpbmRleCArIDEgPCBub2RlU3RhY2subGVuZ3RoKSB7XHJcbiAgICAgICAgICBjdXJyZW50Tm9kZSA9IG5vZGVTdGFjay5wb3AoKTtcclxuICAgICAgICAgIGRpclN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgY3VycmVudFdvcmtEaXIgPSBkaXJTdGFja1tub2RlU3RhY2subGVuZ3RoLTFdO1xyXG4gICAgICAgICAgY3VycmVudFdvcmtGbG93ID0gd2ZTdGFja1tub2RlU3RhY2subGVuZ3RoLTFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVCcmVhZHJ1bWIoKTsgXHJcblxyXG4gICAgICAgIGZiLnJlcXVlc3QoJ2dldEZpbGVMaXN0JywgY3VycmVudFdvcmtEaXIsIG51bGwpO1xyXG4gICAgICAgIHNpby5lbWl0KCdnZXRXb3JrZmxvdycsIGN1cnJlbnRXb3JrRmxvdyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJlbWl0IGJyZWFkXCIpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZVRhc2tTdGF0ZVRhYmxlKHRhc2tTdGF0ZUxpc3QpIHtcclxuICAgICQoJyNwcm9qZWN0X3RhYmxlX2JvZHknKS5lbXB0eSgpO1xyXG4gICAgbGV0IHRhc2tTdGF0ZVRhYmxlID0gJCgnI3Byb2plY3RfdGFibGVfYm9keScpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXNrU3RhdGVMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIC8vZm9yIHRlc3RcclxuICAgICAgbGV0IG5vZGVUeXBlID0gXCJ0YXNrXCI7XHJcbiAgICAgIC8vbGV0IG5vZGVUeXBlID0gdGFza1N0YXRlTGlzdFtpXS50eXBlO1xyXG4gICAgICBsZXQgbm9kZVN0YXRlID0gXCJydW5uaW5nXCI7XHJcbiAgICAgIC8vbGV0IG5vZGVTdGF0ZSA9IHRhc2tTdGF0ZUxpc3RbaV0uc3RhdGU7XHJcblxyXG4gICAgICBsZXQgbm9kZUljb25QYXRoID0gY29uZmlnLm5vZGVfaWNvbltub2RlVHlwZV07XHJcbiAgICAgIGxldCBub2RlQ29sb3IgPSBjb25maWcubm9kZV9jb2xvcltub2RlVHlwZV07XHJcbiAgICAgIGxldCBub2RlQ29tcG9uZW50U3RhdGUgPSBjb25maWcuc3RhdGVfaWNvbltub2RlU3RhdGVdOyBcclxuXHJcbiAgICAgIGxldCBpZCA9IGB0YXNrTGFiZWxfJHtpfWA7ICAgICAgXHJcblxyXG4gICAgICB0YXNrU3RhdGVUYWJsZS5hcHBlbmQoYDx0cj48dGQgaWQ9JHtpZH0gY2xhc3M9XCJjb21wb25lbnROYW1lXCI+PGltZyBzcmM9JHtub2RlSWNvblBhdGh9IGNsYXNzPVwid29ya2Zsb3dfY29tcG9uZW50X2ljb25cIi8+PGxhYmVsIGNsYXNzPVwibmFtZUxhYmVsXCI+JHt0YXNrU3RhdGVMaXN0W2ldLm5hbWV9PC9sYWJlbD48L3RkPlxyXG4gICAgICA8dGQgY2xhc3M9XCJjb21wb25lbnRTdGF0ZVwiPjxpbWcgc3JjPSR7bm9kZUNvbXBvbmVudFN0YXRlfS8+PGxhYmVsIGNsYXNzPVwic3RhdGVMYWJlbFwiPiR7dGFza1N0YXRlTGlzdFtpXS5zdGF0ZX08L2xhYmVsPjwvdGQ+XHJcbiAgICAgIDx0ZCBjbGFzcz1cImNvbXBvbmVudFN0YXJ0VGltZVwiPiR7dGFza1N0YXRlTGlzdFtpXS5zdGFydFRpbWV9PC90ZD5cclxuICAgICAgPHRkIGNsYXNzPVwiY29tcG9uZW50RW5kVGltZVwiPiR7dGFza1N0YXRlTGlzdFtpXS5lbmRUaW1lfTwvdGQ+XHJcbiAgICAgIDx0ZCBjbGFzcz1cImNvbXBvbmVudERlc2NyaXB0aW9uXCI+JHt0YXNrU3RhdGVMaXN0W2ldLmRlc2NyaXB0aW9ufTwvdGQ+PC90cj5gKTtcclxuXHJcbiAgICAgICQoYCMke2lkfWApLmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgbm9kZUNvbG9yKTtcclxuICAgICAgXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAkKCcjdXNlSm9iU2NoZWR1bGVyRmxhZ0ZpZWxkJykuY2hhbmdlKGZ1bmN0aW9uKCkge1xyXG4gICAgLy9sZXQgY2hlY2tlZFZhbHVlID0gJCgnI3F1ZXVlU2VsZWN0RmllbGQ6Y2hlY2tlZCcpLnZhbCgpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcImNoZWNrZWRWYWx1ZVwiKTsgICAgICAgIFxyXG4gICAgICBcclxuICAgICAgaWYoJCgnI3VzZUpvYlNjaGVkdWxlckZsYWdGaWVsZCcpLnByb3AoJ2NoZWNrZWQnKSl7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJ0ZXN0XCIpO1xyXG4gICAgICAgICQoJyNxdWV1ZVNlbGVjdEZpZWxkJykucHJvcCgnZGlzYWJsZWQnLGZhbHNlKTtcclxuICAgICAgICAkKCcjcXVldWVTZWxlY3RGaWVsZCcpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsICcjMDAwMDAwJyk7XHJcbiAgICAgICAgJCgnI3F1ZXVlU2VsZWN0RmllbGQnKS5jc3MoJ2NvbG9yJywgJyNGRkZGRkYnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgJCgnI3F1ZXVlU2VsZWN0RmllbGQnKS5wcm9wKCdkaXNhYmxlZCcsdHJ1ZSk7XHJcbiAgICAgICAgJCgnI3F1ZXVlU2VsZWN0RmllbGQnKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCAnIzMzMzMzMycpO1xyXG4gICAgICAgICQoJyNxdWV1ZVNlbGVjdEZpZWxkJykuY3NzKCdjb2xvcicsICcjMDAwMDAwJyk7ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgfVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy/jg5fjg63jg5Hjg4bjgqPjgqjjg6rjgqLjga7jg5XjgqHjgqTjg6vjgIHjg5Xjgqnjg6vjg4Djg7zmlrDopo/kvZzmiJBcclxuICAkKCcjY3JlYXRlRmlsZUJ1dHRvbicpLmNsaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IGh0bWwgPSAnPHAgY2xhc3M9XCJkaWFsb2dUaXRsZVwiPk5ldyBmaWxlIG5hbWUgKGV4LiBhYWEudHh0KTwvcD48aW5wdXQgdHlwZT10ZXh0IGNsYXNzPVwiZGlhbG9nVGV4dGJveFwiPidcclxuICAgIGRpYWxvZ1dyYXBwZXIoJyNkaWFsb2cnLCBodG1sKVxyXG4gICAgICAuZG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IG5ld0ZpbGVOYW1lID0gJCgnI25ld0ZpbGVOYW1lJykudmFsKCk7XHJcbiAgICAgICAgbGV0IG5ld0ZpbGVQYXRoID0gZmIuZ2V0UmVxdWVzdGVkUGF0aCgpICsgXCIvXCIgKyBuZXdGaWxlTmFtZTtcclxuICAgICAgICBzaW8uZW1pdCgnY3JlYXRlTmV3RmlsZScsIG5ld0ZpbGVQYXRoLCAocmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2cobmV3RmlsZVBhdGgpOyAgICAgICAgICBcclxuICAgICAgfSk7XHJcbiAg44CAfSk7XHJcbuOAgH0pO1xyXG4gICQoJyNjcmVhdGVGb2xkZXJCdXR0b24nKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBodG1sID0gJzxwIGNsYXNzPVwiZGlhbG9nVGl0bGVcIj5OZXcgZm9sZGVyIG5hbWU8L3A+PGlucHV0IHR5cGU9dGV4dCBjbGFzcz1cImRpYWxvZ1RleHRib3hcIj4nXHJcbiAgICBkaWFsb2dXcmFwcGVyKCcjZGlhbG9nJywgaHRtbClcclxuICAgICAgLmRvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCBuZXdGb2xkZXJOYW1lID0gJCgnI25ld0ZvbGRlck5hbWUnKS52YWwoKTtcclxuICAgICAgICBsZXQgbmV3Rm9sZGVyUGF0aCA9IGZiLmdldFJlcXVlc3RlZFBhdGgoKSArIFwiL1wiICsgbmV3Rm9sZGVyTmFtZTsgICAgICAgIFxyXG4gICAgICAgIHNpby5lbWl0KCdjcmVhdGVOZXdEaXInLCBuZXdGb2xkZXJQYXRoLCAocmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2cobmV3Rm9sZGVyUGF0aCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbuOAgH0pO1xyXG4gICQoJyNmaWxlVXBsb2FkQnV0dG9uJykuY2xpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgJCgnI2ZpbGVTZWxlY3RvcicpLmNsaWNrKCk7XHJcbiAgfSk7XHJcblxyXG4gICQoJyNkcmF3ZXJfYnV0dG9uJykuY2xpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgJCgnI2RyYXdlcl9tZW51JykudG9nZ2xlQ2xhc3MoJ2FjdGlvbicsIHRydWUpO1xyXG4gIH0pO1xyXG5cclxuICAkKCcjZHJhd2VyX21lbnUnKS5tb3VzZWxlYXZlKGZ1bmN0aW9uICgpIHtcclxuICAgICQoJyNkcmF3ZXJfbWVudScpLnRvZ2dsZUNsYXNzKCdhY3Rpb24nLCBmYWxzZSk7XHJcbiAgfSk7XHJcblxyXG4vKiAgICQoJy52aWV3QnV0dG9uJykuY2xpY2soZnVuY3Rpb24oKXtcclxuICAgICQoXCIudmlld05vZGVzXCIpLmNzcygnZGlzcGxheScsICdibG9jaycpOyAgICBcclxuICB9KTsgKi9cclxuXHJcbiAgLy/jg5zjgr/jg7Pjgafjga52aWV344Gu5YiH44KK5pu/44GIXHJcbiAgJCgnLnZpZXdCdXR0b24nKS5tb3VzZW92ZXIoZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmlld0J1dHRvbklEID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJy52aWV3QnV0dG9uJyk7IFxyXG4gICAgY29uc29sZS5sb2codmlld0J1dHRvbklEKTtcclxuICAgIC8vc2V0QXR0cmlidXRl44Oh44K944OD44OJ44GnZmlsbOWxnuaAp+OBruWApOOCkumdkuOBq+WkieabtCBcclxuXHJcbi8qIGNpcmNsZTEuc2V0QXR0cmlidXRlKFwiZmlsbFwiLFwiIzAwMDBmZlwiKTsgXHJcblxyXG4gICAgc3ZnMSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdmcxJyk7XHJcbiAgICAkKCcudmlld05vZGVzJykuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7ICovXHJcbiAgfSk7XHJcblxyXG4gIFxyXG4gIGZ1bmN0aW9uIGdldFNlbGVjdExhYmVsKGluZGV4KXtcclxuICAgIHZhciBvYmogPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpbmRleCk7XHJcbiAgICB2YXIgaWR4ID0gb2JqLnNlbGVjdGVkSW5kZXg7ICAgICAgIC8v44Kk44Oz44OH44OD44Kv44K555Wq5Y+344KS5Y+W5b6XXHJcbiAgICB2YXIgdmFsID0gb2JqLm9wdGlvbnNbaWR4XS52YWx1ZTsgIC8vdmFsdWXlgKTjgpLlj5blvpdcclxuICAgIHZhciB0eHQgID0gb2JqLm9wdGlvbnNbaWR4XS50ZXh0OyAgLy/jg6njg5njg6vjgpLlj5blvpdcclxuICAgIGNvbnNvbGUubG9nKGlkeCk7XHJcbiAgICBjb25zb2xlLmxvZyh2YWwpO1xyXG4gICAgXHJcbiAgfVxyXG5cclxuICB2YXIgcG9zPSQoXCIjdGl0bGVVc2VyTmFtZVwiKS5vZmZzZXQoKTtcclxuICAkKFwiI2ltZ191c2VyXCIpLmNzcygncmlnaHQnLCB3aW5kb3cuaW5uZXJXaWR0aCAtIDggLSBwb3MubGVmdCArIFwicHhcIik7XHJcbiAgXHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9zcmMvanMvd29ya2Zsb3cuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///52\n");

/***/ }),

/***/ 53:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\n\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (socket) {\r\n    // initial enable log\r\n    socket.on('logDBG', addDebugLog);\r\n    socket.on('logINFO', addInfoLog);\r\n    socket.on('logWARN', addWarnLog);\r\n    socket.on('logERR', addErrLog);\r\n    socket.on('logStdout', addStdoutLog);\r\n    socket.on('logStderr', addStderrLog);\r\n    socket.on('logSSHout', addSSHoutLog);\r\n    socket.on('logSSHerr', addSSHerrLog);       \r\n\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.logButton').click(function () {\r\n        //socket.off('logDBG');\r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.logText').css('display', \"none\");                    \r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.logButton').css('border-bottom-color', \"rgba(28,28,32,0.75)\");                        \r\n\r\n        let flag = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).attr(\"id\");\r\n        switch (flag){\r\n            case \"enableDBG\":\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logDebugLog').show();\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#enableDBG').css('border-bottom-color', \"#88BB00\");            \r\n              break;\r\n            \r\n            case \"enableINFO\":\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logInfoLog').show();\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#enableINFO').css('border-bottom-color', \"#88BB00\");                        \r\n              break;\r\n\r\n            case \"enableWARN\":\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logWarnLog').show();\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#enableWARN').css('border-bottom-color', \"#88BB00\");                        \r\n              break;\r\n\r\n            case \"enableERR\":\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logErrLog').show();\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#enableERR').css('border-bottom-color', \"#88BB00\");                        \r\n              break;\r\n\r\n            case \"enableStdout\":\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logStdoutLog').show();\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#enableStdout').css('border-bottom-color', \"#88BB00\");                        \r\n              break;\r\n\r\n            case \"enableStderr\":\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logStderrLog').show();\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#enableStderr').css('border-bottom-color', \"#88BB00\");                        \r\n              break;\r\n\r\n            case \"enableSSHout\":\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logSSHoutog').show();\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#enableSSHout').css('border-bottom-color', \"#88BB00\");                        \r\n              break;\r\n\r\n            case \"enableSSHerr\":\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logSSHerrLog').show();\r\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#enableSSHerr').css('border-bottom-color', \"#88BB00\");                        \r\n              break;\r\n        } \r\n    });\r\n\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(\"#clear_log\").click(function(){\r\n/*         $(\"#logDebugLog\").empty();\r\n        $(\"#logInfoLog\").empty();\r\n        $(\"#logWarnLog\").empty();\r\n        $(\"#logErrLog\").empty();\r\n        $(\"#logStdoutLog\").empty();\r\n        $(\"#logStderrLog\").empty();\r\n        $(\"#logSSHoutDog\").empty();\r\n        $(\"#logSSHerrDog\").empty();     */    \r\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(\".logText\").empty();        \r\n    });\r\n/* \r\n    $('#enableDBG').click(function () {\r\n        if ($('#enableDBG').prop('checked')) {\r\n            socket.on('logDBG', addLog);\r\n        }\r\n        else {\r\n            socket.off('logDBG');\r\n        }\r\n    }); */\r\n});\r\n\r\nfunction addDebugLog(msg) {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logDebugLog').append(msg.toString() + '\\n');\r\n    var area = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#debugLogArea');\r\n    area.scrollTop = area.scrollHeight;\r\n} \r\n\r\nfunction addInfoLog(msg) {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logInfoLog').append(msg.toString() + '\\n');\r\n    var area = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#infoLogArea');\r\n    area.scrollTop = area.scrollHeight;\r\n} \r\n\r\nfunction addWarnLog(msg) {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logWarnLog').append(msg.toString() + '\\n');\r\n    var area = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#warnLogArea');\r\n    area.scrollTop = area.scrollHeight;\r\n} \r\n\r\nfunction addErrLog(msg) {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logErrLog').append(msg.toString() + '\\n');\r\n    var area = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#errLogArea');\r\n    area.scrollTop = area.scrollHeight;\r\n} \r\n\r\nfunction addStdoutLog(msg) {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logStdoutLog').append(msg.toString() + '\\n');\r\n    var area = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#stdoutLogArea');\r\n    area.scrollTop = area.scrollHeight;\r\n} \r\n\r\nfunction addStderrLog(msg) {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logStderrLog').append(msg.toString() + '\\n');\r\n    var area = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#stderrLogArea');\r\n    area.scrollTop = area.scrollHeight;\r\n} \r\n\r\nfunction addSSHoutLog(msg) {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logSSHoutLog').append(msg.toString() + '\\n');\r\n    var area = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#ssherrLogArea');\r\n    area.scrollTop = area.scrollHeight;\r\n} \r\n\r\nfunction addSSHerrLog(msg) {\r\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#logSSHerrLog').append(msg.toString() + '\\n');\r\n    var area = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#ssherrLogArea');\r\n    area.scrollTop = area.scrollHeight;\r\n} //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2pzL2xvZ1JlY2lldmVyLmpzPzQ2NmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTt5REFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Qzs7QUFFQTtBQUNBO0FBQ0EsMEY7QUFDQSx1SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtIO0FBQ0E7QUFDQSxTO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDJFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDIiwiZmlsZSI6IjUzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHNvY2tldCkge1xyXG4gICAgLy8gaW5pdGlhbCBlbmFibGUgbG9nXHJcbiAgICBzb2NrZXQub24oJ2xvZ0RCRycsIGFkZERlYnVnTG9nKTtcclxuICAgIHNvY2tldC5vbignbG9nSU5GTycsIGFkZEluZm9Mb2cpO1xyXG4gICAgc29ja2V0Lm9uKCdsb2dXQVJOJywgYWRkV2FybkxvZyk7XHJcbiAgICBzb2NrZXQub24oJ2xvZ0VSUicsIGFkZEVyckxvZyk7XHJcbiAgICBzb2NrZXQub24oJ2xvZ1N0ZG91dCcsIGFkZFN0ZG91dExvZyk7XHJcbiAgICBzb2NrZXQub24oJ2xvZ1N0ZGVycicsIGFkZFN0ZGVyckxvZyk7XHJcbiAgICBzb2NrZXQub24oJ2xvZ1NTSG91dCcsIGFkZFNTSG91dExvZyk7XHJcbiAgICBzb2NrZXQub24oJ2xvZ1NTSGVycicsIGFkZFNTSGVyckxvZyk7ICAgICAgIFxyXG5cclxuICAgICQoJy5sb2dCdXR0b24nKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9zb2NrZXQub2ZmKCdsb2dEQkcnKTtcclxuICAgICAgICAkKCcubG9nVGV4dCcpLmNzcygnZGlzcGxheScsIFwibm9uZVwiKTsgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICQoJy5sb2dCdXR0b24nKS5jc3MoJ2JvcmRlci1ib3R0b20tY29sb3InLCBcInJnYmEoMjgsMjgsMzIsMC43NSlcIik7ICAgICAgICAgICAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgIGxldCBmbGFnID0gJCh0aGlzKS5hdHRyKFwiaWRcIik7XHJcbiAgICAgICAgc3dpdGNoIChmbGFnKXtcclxuICAgICAgICAgICAgY2FzZSBcImVuYWJsZURCR1wiOlxyXG4gICAgICAgICAgICAkKCcjbG9nRGVidWdMb2cnKS5zaG93KCk7XHJcbiAgICAgICAgICAgICQoJyNlbmFibGVEQkcnKS5jc3MoJ2JvcmRlci1ib3R0b20tY29sb3InLCBcIiM4OEJCMDBcIik7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjYXNlIFwiZW5hYmxlSU5GT1wiOlxyXG4gICAgICAgICAgICAkKCcjbG9nSW5mb0xvZycpLnNob3coKTtcclxuICAgICAgICAgICAgJCgnI2VuYWJsZUlORk8nKS5jc3MoJ2JvcmRlci1ib3R0b20tY29sb3InLCBcIiM4OEJCMDBcIik7ICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwiZW5hYmxlV0FSTlwiOlxyXG4gICAgICAgICAgICAkKCcjbG9nV2FybkxvZycpLnNob3coKTtcclxuICAgICAgICAgICAgJCgnI2VuYWJsZVdBUk4nKS5jc3MoJ2JvcmRlci1ib3R0b20tY29sb3InLCBcIiM4OEJCMDBcIik7ICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwiZW5hYmxlRVJSXCI6XHJcbiAgICAgICAgICAgICQoJyNsb2dFcnJMb2cnKS5zaG93KCk7XHJcbiAgICAgICAgICAgICQoJyNlbmFibGVFUlInKS5jc3MoJ2JvcmRlci1ib3R0b20tY29sb3InLCBcIiM4OEJCMDBcIik7ICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwiZW5hYmxlU3Rkb3V0XCI6XHJcbiAgICAgICAgICAgICQoJyNsb2dTdGRvdXRMb2cnKS5zaG93KCk7XHJcbiAgICAgICAgICAgICQoJyNlbmFibGVTdGRvdXQnKS5jc3MoJ2JvcmRlci1ib3R0b20tY29sb3InLCBcIiM4OEJCMDBcIik7ICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwiZW5hYmxlU3RkZXJyXCI6XHJcbiAgICAgICAgICAgICQoJyNsb2dTdGRlcnJMb2cnKS5zaG93KCk7XHJcbiAgICAgICAgICAgICQoJyNlbmFibGVTdGRlcnInKS5jc3MoJ2JvcmRlci1ib3R0b20tY29sb3InLCBcIiM4OEJCMDBcIik7ICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwiZW5hYmxlU1NIb3V0XCI6XHJcbiAgICAgICAgICAgICQoJyNsb2dTU0hvdXRvZycpLnNob3coKTtcclxuICAgICAgICAgICAgJCgnI2VuYWJsZVNTSG91dCcpLmNzcygnYm9yZGVyLWJvdHRvbS1jb2xvcicsIFwiIzg4QkIwMFwiKTsgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgXCJlbmFibGVTU0hlcnJcIjpcclxuICAgICAgICAgICAgJCgnI2xvZ1NTSGVyckxvZycpLnNob3coKTtcclxuICAgICAgICAgICAgJCgnI2VuYWJsZVNTSGVycicpLmNzcygnYm9yZGVyLWJvdHRvbS1jb2xvcicsIFwiIzg4QkIwMFwiKTsgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IFxyXG4gICAgfSk7XHJcblxyXG4gICAgJChcIiNjbGVhcl9sb2dcIikuY2xpY2soZnVuY3Rpb24oKXtcclxuLyogICAgICAgICAkKFwiI2xvZ0RlYnVnTG9nXCIpLmVtcHR5KCk7XHJcbiAgICAgICAgJChcIiNsb2dJbmZvTG9nXCIpLmVtcHR5KCk7XHJcbiAgICAgICAgJChcIiNsb2dXYXJuTG9nXCIpLmVtcHR5KCk7XHJcbiAgICAgICAgJChcIiNsb2dFcnJMb2dcIikuZW1wdHkoKTtcclxuICAgICAgICAkKFwiI2xvZ1N0ZG91dExvZ1wiKS5lbXB0eSgpO1xyXG4gICAgICAgICQoXCIjbG9nU3RkZXJyTG9nXCIpLmVtcHR5KCk7XHJcbiAgICAgICAgJChcIiNsb2dTU0hvdXREb2dcIikuZW1wdHkoKTtcclxuICAgICAgICAkKFwiI2xvZ1NTSGVyckRvZ1wiKS5lbXB0eSgpOyAgICAgKi8gICAgXHJcbiAgICAgICAgJChcIi5sb2dUZXh0XCIpLmVtcHR5KCk7ICAgICAgICBcclxuICAgIH0pO1xyXG4vKiBcclxuICAgICQoJyNlbmFibGVEQkcnKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCQoJyNlbmFibGVEQkcnKS5wcm9wKCdjaGVja2VkJykpIHtcclxuICAgICAgICAgICAgc29ja2V0Lm9uKCdsb2dEQkcnLCBhZGRMb2cpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc29ja2V0Lm9mZignbG9nREJHJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7ICovXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZERlYnVnTG9nKG1zZykge1xyXG4gICAgJCgnI2xvZ0RlYnVnTG9nJykuYXBwZW5kKG1zZy50b1N0cmluZygpICsgJ1xcbicpO1xyXG4gICAgdmFyIGFyZWEgPSAkKCcjZGVidWdMb2dBcmVhJyk7XHJcbiAgICBhcmVhLnNjcm9sbFRvcCA9IGFyZWEuc2Nyb2xsSGVpZ2h0O1xyXG59IFxyXG5cclxuZnVuY3Rpb24gYWRkSW5mb0xvZyhtc2cpIHtcclxuICAgICQoJyNsb2dJbmZvTG9nJykuYXBwZW5kKG1zZy50b1N0cmluZygpICsgJ1xcbicpO1xyXG4gICAgdmFyIGFyZWEgPSAkKCcjaW5mb0xvZ0FyZWEnKTtcclxuICAgIGFyZWEuc2Nyb2xsVG9wID0gYXJlYS5zY3JvbGxIZWlnaHQ7XHJcbn0gXHJcblxyXG5mdW5jdGlvbiBhZGRXYXJuTG9nKG1zZykge1xyXG4gICAgJCgnI2xvZ1dhcm5Mb2cnKS5hcHBlbmQobXNnLnRvU3RyaW5nKCkgKyAnXFxuJyk7XHJcbiAgICB2YXIgYXJlYSA9ICQoJyN3YXJuTG9nQXJlYScpO1xyXG4gICAgYXJlYS5zY3JvbGxUb3AgPSBhcmVhLnNjcm9sbEhlaWdodDtcclxufSBcclxuXHJcbmZ1bmN0aW9uIGFkZEVyckxvZyhtc2cpIHtcclxuICAgICQoJyNsb2dFcnJMb2cnKS5hcHBlbmQobXNnLnRvU3RyaW5nKCkgKyAnXFxuJyk7XHJcbiAgICB2YXIgYXJlYSA9ICQoJyNlcnJMb2dBcmVhJyk7XHJcbiAgICBhcmVhLnNjcm9sbFRvcCA9IGFyZWEuc2Nyb2xsSGVpZ2h0O1xyXG59IFxyXG5cclxuZnVuY3Rpb24gYWRkU3Rkb3V0TG9nKG1zZykge1xyXG4gICAgJCgnI2xvZ1N0ZG91dExvZycpLmFwcGVuZChtc2cudG9TdHJpbmcoKSArICdcXG4nKTtcclxuICAgIHZhciBhcmVhID0gJCgnI3N0ZG91dExvZ0FyZWEnKTtcclxuICAgIGFyZWEuc2Nyb2xsVG9wID0gYXJlYS5zY3JvbGxIZWlnaHQ7XHJcbn0gXHJcblxyXG5mdW5jdGlvbiBhZGRTdGRlcnJMb2cobXNnKSB7XHJcbiAgICAkKCcjbG9nU3RkZXJyTG9nJykuYXBwZW5kKG1zZy50b1N0cmluZygpICsgJ1xcbicpO1xyXG4gICAgdmFyIGFyZWEgPSAkKCcjc3RkZXJyTG9nQXJlYScpO1xyXG4gICAgYXJlYS5zY3JvbGxUb3AgPSBhcmVhLnNjcm9sbEhlaWdodDtcclxufSBcclxuXHJcbmZ1bmN0aW9uIGFkZFNTSG91dExvZyhtc2cpIHtcclxuICAgICQoJyNsb2dTU0hvdXRMb2cnKS5hcHBlbmQobXNnLnRvU3RyaW5nKCkgKyAnXFxuJyk7XHJcbiAgICB2YXIgYXJlYSA9ICQoJyNzc2hlcnJMb2dBcmVhJyk7XHJcbiAgICBhcmVhLnNjcm9sbFRvcCA9IGFyZWEuc2Nyb2xsSGVpZ2h0O1xyXG59IFxyXG5cclxuZnVuY3Rpb24gYWRkU1NIZXJyTG9nKG1zZykge1xyXG4gICAgJCgnI2xvZ1NTSGVyckxvZycpLmFwcGVuZChtc2cudG9TdHJpbmcoKSArICdcXG4nKTtcclxuICAgIHZhciBhcmVhID0gJCgnI3NzaGVyckxvZ0FyZWEnKTtcclxuICAgIGFyZWEuc2Nyb2xsVG9wID0gYXJlYS5zY3JvbGxIZWlnaHQ7XHJcbn0gXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL2pzL2xvZ1JlY2lldmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///53\n");

/***/ }),

/***/ 54:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"e\"] = createLower;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = createConnector;\n/* harmony export (immutable) */ __webpack_exports__[\"h\"] = createReceptor;\n/* harmony export (immutable) */ __webpack_exports__[\"i\"] = createUpper;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = createBox;\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = createFilesNameBox;\n/* harmony export (immutable) */ __webpack_exports__[\"f\"] = createParentConnector;\n/* harmony export (immutable) */ __webpack_exports__[\"g\"] = createParentReceptor;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(39);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__config__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_workflow_css__ = __webpack_require__(38);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_workflow_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__css_workflow_css__);\n\r\n\r\n\r\nlet UPlug = [[0, 0], [20, 0], [20, 8], [0, 8]];\r\nlet DPlug = [[0, 0], [20, 0], [10, 12]];\r\nlet LPlug = [[0, 0], [8, 0], [8, 16], [0, 16]];\r\nlet RPlug = [[0, 0], [8, 8], [0, 16]];\r\n/*è¦ªå­éç¨ãå³å·¦é*/\r\nlet parentRPlug = [[0, 0], [16, 0], [16, 32], [0, 32]];\r\nlet parentLPlug = [[0, 0], [16, 16], [0, 32]];\r\n//let UDPlug = [[0, 0], [20, 0], [20, 5], [10, 10], [0, 5]]\r\n//let LRPlug = [[0, 0], [8, 0], [16, 8], [8, 16], [0, 16]];\r\n\r\n/**\r\n * calc y coord of 1st input/output file from top of the box\r\n * @return y coord\r\n */\r\nfunction calcFileBasePosY() {\r\n  const titleHeight = __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.titleHeight;\r\n  return titleHeight;\r\n  //const marginHeight = config.box_appearance.marginHeight;\r\n  //return titleHeight + marginHeight / 2;\r\n}\r\n\r\n/**\r\n * check if droped plug hit any other counterpart\r\n * @param svg instance of svg.js\r\n * @param counterpart selector of counterpart (e.g. '.upperPlut', '.receptorPlug')\r\n * @param x x coordinate of the point which will be checked\r\n * @param y y coordinate of the point which will be checked\r\n */\r\nfunction collisionDetection(svg, counterpart, x, y) {\r\n  console.log(\"collisionDetection\");\r\n  \r\n  let minDistance2 = Number.MAX_VALUE;\r\n  let nearestNodeIndex = -1;\r\n  let nearestPlugPoints = null;\r\n  let nearestPlug = null;\r\n  // dropããplugã¨å¯¾å¿ããç¨®é¡ã®plugã®ãã¡æãè·é¢ãè¿ããã®ãæ¢ã\r\n  svg.select(counterpart).each(function (i, v) {\r\n    let index = v[i].parent().node.instance.data('index');\r\n    let points = v[i].node.points;\r\n    let targetX = points[3].x;\r\n    let targetY = points[2].y;\r\n    let distance2 = (targetX - x) * (targetX - x) + (targetY - y) * (targetY - y);\r\n    console.log(distance2);\r\n    if (minDistance2 > distance2) {\r\n      minDistance2 = distance2;\r\n      nearestNodeIndex = index;\r\n      //child -> parentã®ã¨ã\r\n      if(index === undefined){\r\n        nearestNodeIndex = \"parent\";        \r\n      }\r\n      nearestPlugPoints = points;\r\n      nearestPlug = v[i];\r\n    }\r\n    console.log(minDistance2);        \r\n    \r\n    console.log(svg);\r\n    console.log(v);\r\n    console.log(nearestNodeIndex);    \r\n    console.log(nearestPlug);\r\n    \r\n  });\r\n  // æè¿åplugã®é ç¹åº§æ¨ããå½ããé åãä½æ\r\n  let xPoints = Array.from(nearestPlugPoints).map((p) => {\r\n    return p.x;\r\n  });\r\n  let yPoints = Array.from(nearestPlugPoints).map((p) => {\r\n    return p.y;\r\n  });\r\n  let minX = Math.min(...xPoints);\r\n  let maxX = Math.max(...xPoints);\r\n  let minY = Math.min(...yPoints);\r\n  let maxY = Math.max(...yPoints);\r\n  let extendX = (maxX - minX) * (__WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.plug_drop_area_scale - 1.0) / 2;\r\n  let extendY = (maxY - minY) * (__WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.plug_drop_area_scale - 1.0) / 2;\r\n  minX -= extendX;\r\n  maxX += extendX;\r\n  minY -= extendY;\r\n  maxY += extendY;\r\n  console.log(maxX);\r\n  console.log(maxY);\r\n  console.log(minX);\r\n  console.log(minY);\r\n  console.log(x);\r\n  console.log(y);\r\n  \r\n\r\n  // æè¿åplugãç¯å²åã«å¥ã£ã¦ããã° indexã¨ãã®plugãè¿ã\r\n  if (minX < x && x < maxX && minY < y && y < maxY) {\r\n    return [nearestNodeIndex, nearestPlug];\r\n  }\r\n  // å¤ãã®æã¯ -1ãäºã¤(indexã¨plug)è¿ã\r\n  return [-1, -1];\r\n}\r\n\r\nclass SvgCable {\r\n  /**\r\n   * @param svg instance of svg.js\r\n   * @param color color of the cable\r\n   * @param direction direction of the cable. DU(Down to Up) or RL(Right to Legt)\r\n   * @param startX x coordinate of initial start point\r\n   * @param startY y coordinate of initial start point\r\n   * @param endtX x coordinate of initial end point\r\n   * @param endtY y coordinate of initial end point\r\n   */\r\n  constructor(svg, color, direction, startX, startY, endX, endY) {\r\n    this.tmpSvg = svg; //for debug calcControlPoint\r\n    this.cable = svg.path('').fill('none').stroke({ color: color, width: __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.strokeWidth });\r\n    this.startX = startX;\r\n    this.startY = startY;\r\n    this.endX = endX || startX;\r\n    this.endY = endY || startY;\r\n    if (direction === 'DU' || direction === 'RL') {\r\n      this.direction = direction;\r\n    } else {\r\n      console.log('illegal direction: ', direction);\r\n    }\r\n  }\r\n  _calcControlPoint(sx, sy, ex, ey, boxBbox) {\r\n    const scaleRange = 1.5;\r\n    const scaleControlPoint = 1.8;\r\n    const mx = (sx + ex) / 2;\r\n    const my = (sy + ey) / 2;\r\n    let cp1x = 0;\r\n    let cp1y = 0;\r\n    let cp2x = 0;\r\n    let cp2y = 0;\r\n    if (this.direction === 'DU') {\r\n      const boxWidth = boxBbox.width;\r\n      const offset = boxWidth * scaleControlPoint;\r\n      if (ey < sy) {\r\n        if (sx - boxWidth * scaleRange < ex && ex < sx + boxWidth * scaleRange) {\r\n          if (sx > ex) {\r\n            cp1x = sx + offset;\r\n            cp1y = sy + offset;\r\n            cp2x = ex + offset;\r\n            cp2y = ey - offset;\r\n          } else {\r\n            cp1x = sx - offset;\r\n            cp1y = sy + offset;\r\n            cp2x = ex - offset;\r\n            cp2y = ey - offset;\r\n          }\r\n        } else {\r\n          cp1x = mx;\r\n          cp1y = sy + offset;\r\n          cp2x = mx;\r\n          cp2y = ey - offset;\r\n        }\r\n      } else {\r\n        cp1x = sx;\r\n        cp1y = my;\r\n        cp2x = ex;\r\n        cp2y = my;\r\n      }\r\n    } else if (this.direction === 'RL') {\r\n      const boxHeight = boxBbox.height;\r\n      const offset = boxHeight * scaleControlPoint;\r\n      if (ex < sx) {\r\n        if (sy - boxHeight * scaleRange < ey && ey < sy + boxHeight * scaleRange) {\r\n          cp1x = sx + offset;\r\n          cp1y = sy - offset;\r\n          cp2x = ex - offset;\r\n          cp2y = ey - offset;\r\n        } else {\r\n          cp1x = sx + offset;\r\n          cp1y = my;\r\n          cp2x = ex - offset;\r\n          cp2y = my;\r\n        }\r\n      } else {\r\n        cp1x = mx;\r\n        cp1y = sy;\r\n        cp2x = mx;\r\n        cp2y = ey;\r\n      }\r\n    }\r\n    return [cp1x, cp1y, cp2x, cp2y];\r\n  }\r\n  _draw(sx, sy, ex, ey, boxBbox) {\r\n    if (boxBbox == null) {\r\n      boxBbox = this.cable.parent().node.instance.data('boxBbox');\r\n    }\r\n    const [cp1x, cp1y, cp2x, cp2y] = this._calcControlPoint(sx, sy, ex, ey, boxBbox);\r\n    this.cable.plot(`M ${sx} ${sy} C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${ex} ${ey}`)\r\n    // if (this.direction === 'DU') {\r\n    //   // const t = 2 * Math.abs(Math.atan((ex - sx) / (ey - sy))) / Math.PI;\r\n    //   // this.cable.plot(`M ${sx} ${sy} V ${t * sy + (1 - t) * ey} H ${ex} L ${ex} ${ey}`)\r\n    //   this.cable.plot(`M ${sx} ${sy} V ${(sy + ey) / 2} H ${ex} L ${ex} ${ey}`)\r\n    // } else {\r\n    //   // const t = 2 * Math.abs(Math.atan((ey - sy) / (ex - sx))) / Math.PI;\r\n    //   // this.cable.plot(`M ${sx} ${sy} H ${t * sx + (1 - t) * ex} V ${ey} L ${ex} ${ey}`)\r\n    //   this.cable.plot(`M ${sx} ${sy} H ${(sx+ex) / 2} L ${ex} ${ey}`)\r\n    // }\r\n  }\r\n  dragEndPoint(dx, dy, boxBbox) {\r\n    this._draw(this.startX, this.startY, this.endX + dx, this.endY + dy, boxBbox);\r\n  }\r\n  dragStartPoint(dx, dy, boxBbox) {\r\n    this._draw(this.startX + dx, this.startY + dy, this.endX, this.endY, boxBbox);\r\n  }\r\n  remove() {\r\n    if (this.cable != null) this.cable.remove();\r\n    this.cable = null;\r\n  }\r\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = SvgCable;\n\r\n\r\nclass SvgBox {\r\n  constructor(svg, x, y, type, name, inputFiles, outputFiles, state, nodes, numTotal, numFinished, numFailed) {\r\n    this.draw = svg;\r\n    this.type = type.toLowerCase();\r\n\r\n    // read draw settings from config\r\n    // upper parts (outerFrame)\r\n    const titleHeight = __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.titleHeight;\r\n    const titleWidth = __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.titleWidth;\r\n    \r\n    const opacity = __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.opacity;\r\n    const strokeWidth = __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.strokeWidth;\r\n    const marginHeight = __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.marginHeight;\r\n    const marginWidth = titleHeight * 2;\r\n    const outputTextOffset = __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.outputTextOffset;\r\n    const nodeColor = __WEBPACK_IMPORTED_MODULE_0__config___default.a.node_color[type];\r\n\r\n    // create inner parts\r\n    const input = this.createInputText(inputFiles);\r\n    const output = this.createOutputText(outputFiles);\r\n\r\n    const outputBBox = output.bbox();\r\n    const inputBBox = input.bbox();\r\n\r\n    const bodyHeight = titleHeight + Math.ceil(Math.max(inputBBox.height, outputBBox.height));\r\n    //const bodyHeight = marginHeight + Math.ceil(Math.max(inputBBox.height, outputBBox.height));\r\n    \r\n    this.height = bodyHeight + titleHeight;\r\n\r\n    const title = this.createTitle(name);\r\n    const iconImage = this.createIconImage(type);\r\n    const taskState = this.createState(type, state, numTotal, numFinished, numFailed);\r\n\r\n    // const nodesViewField = this.createNodesViewField(type, bodyHeight, nodes);\r\n    // const nodesButtonField = this.createNodesButtonField(type, bodyHeight, nodes);\r\n    // const nodesView = this.createNodes(type, nodes);\r\n    // const nodesIconField = this.createNodesIconField(type, nodes);\r\n    // const nodesViewButton = this.createNodesButton(type, bodyHeight);\r\n\r\n\r\n    \r\n    //æ±ºãæã¡ã«å¤æ´\r\n    this.width = 256;\r\n    //this.width = Math.ceil(Math.max(inputBBox.width + outputBBox.width, title.bbox().width)) + marginWidth;\r\n\r\n    const outerFrame = this.createOuterFrame(type);\r\n    const innerFrame = this.createInnerFrame();\r\n\r\n    this.box = this.draw.group();\r\n    this.box\r\n      .add(outerFrame)\r\n      .add(innerFrame)\r\n      .add(title)\r\n      .add(input)\r\n      .add(output)\r\n      .add(taskState)\r\n      .add(iconImage)\r\n      // .add(nodesButtonField)\r\n      // .add(nodesViewButton)\r\n      // .add(nodesViewField)\r\n      // .add(nodesIconField)            \r\n      // .add(nodesView)\r\n      .move(x, y)\r\n      .style('cursor', 'default')\r\n      .opacity(opacity)\r\n      .addClass('box');\r\n      \r\n    // adjust size\r\n    //output.x(this.width);\r\n    output.x(titleWidth);\r\n    \r\n    //innerFrame.size(this.width - strokeWidth, bodyHeight);\r\n    innerFrame.size(titleWidth, bodyHeight);\r\n    \r\n  }\r\n\r\n  /**\r\n   * create outer frame\r\n   * @return outer frame element\r\n   */\r\n/*   createOuterFrame() {\r\n    const titleHeight = config.box_appearance['titleHeight'];\r\n    const nodeColor = config.node_color[this.type];\r\n    return this.draw\r\n      .polygon([\r\n        [titleHeight / 2, 0],\r\n        [this.width, 0],\r\n        [this.width, titleHeight],\r\n        [0, titleHeight],\r\n        [0, titleHeight / 2]\r\n      ])\r\n      .fill(nodeColor);\r\n  } */\r\n  //ç©å½¢ãã¼ã¸ã§ã³ãèãã\r\n  createOuterFrame(type) {\r\n    const titleHeight = 32;\r\n    const titlewidth = 256;    \r\n    const nodeColor = __WEBPACK_IMPORTED_MODULE_0__config___default.a.node_color[type];\r\n    return this.draw\r\n      .polygon([\r\n        [0, 0],\r\n        [titlewidth, 0],\r\n        [titlewidth, titleHeight],\r\n        [0, titleHeight],\r\n      ])\r\n      .fill(nodeColor);\r\n  }\r\n  /**\r\n   * create inner frame\r\n   * @return inner frame element\r\n   */\r\n/*   createInnerFrame() {\r\n    const titleHeight = config.box_appearance['titleHeight'];\r\n    const strokeWidth = config.box_appearance['strokeWidth'];\r\n    const nodeColor = config.node_color[this.type];\r\n    return this.draw\r\n      .rect(0, 0)\r\n      .attr({\r\n        'fill': 'rgb(50, 50, 50)',\r\n        'stroke': nodeColor,\r\n        'stroke-width': strokeWidth\r\n      })\r\n      .move(strokeWidth / 2, titleHeight);\r\n  } */\r\n    createInnerFrame() {\r\n      const titleHeight = 32;\r\n      const titleWidth = 256;\r\n      \r\n      return this.draw\r\n      .polygon([\r\n        [0, 0],\r\n        [titleWidth, 0],\r\n        [titleWidth, titleHeight],\r\n        [0, titleHeight],\r\n      ])\r\n      .fill(\"rgba(68, 68, 73,0.5\");\r\n    }\r\n  /**\r\n   * create title\r\n   * @return title element\r\n   */\r\n   createTitle(name) {\r\n    const titlePosY = 6;\r\n    const titlePosX = 48;\r\n    return this.draw\r\n      .text(name)\r\n      .fill('#FFFFFF')\r\n      .x(titlePosX)\r\n      .y(titlePosY);\r\n   }\r\n\r\n  /**\r\n   * create output file text\r\n   * @return output file text\r\n   */\r\n  createOutputText(outputFiles) {\r\n    this.outputGroup = this.draw.group();\r\n    outputFiles.forEach((output, index) => {\r\n      const text = this.draw\r\n        .text(output.name)\r\n        .fill('#FFFFFF');\r\n      this.textHeight = text.bbox().height * __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.textHeightScale;\r\n\r\n      const x = -text.bbox().width - __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.outputTextOffset;\r\n      const y = calcFileBasePosY() + this.textHeight * index;\r\n      text.move(x, y);\r\n      this.outputGroup.add(text);\r\n    });\r\n    return this.outputGroup;\r\n  }\r\n  /**\r\n   * create input file text\r\n   * @return input file text\r\n   */\r\n  createInputText(inputFiles) {\r\n    this.inputGroup = this.draw.group();\r\n    inputFiles.forEach((input, index) => {\r\n      const text = this.draw\r\n        .text(input.name)\r\n        .fill('#FFFFFF');\r\n      //this.textHeight = text.bbox().height * config.box_appearance.textHeightScale;\r\n      this.textHeight = 24;\r\n      const x = __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.inputTextNamePosX;\r\n      const y = 32 + this.textHeight * index;\r\n      text.move(x, y);\r\n      this.inputGroup.add(text);\r\n    });\r\n    return this.inputGroup;\r\n  }\r\n\r\n    /**\r\n   * create children view field\r\n   * @return view field\r\n   */\r\n  createNodesViewField(type, bodyHeight, nodes) {\r\n    this.fieldGroup = this.draw.group();\r\n    if(type === 'workflow' || type === 'parameterStudy' || type === 'for' || type === 'while' || type === 'foreach'){ \r\n      if( nodes.length > 0){                    \r\n        const titleHeight = 160;\r\n        const titlewidth = 256;    \r\n        const nodeColor = \"rgba(68, 68, 73, 0.5)\";\r\n        const field =  this.draw\r\n          .polygon([\r\n            [0, 0],\r\n            [titlewidth, 0],\r\n            [titlewidth, titleHeight],\r\n            [0, titleHeight],\r\n          ])\r\n          .attr('class','viewNodes')      \r\n          .fill(nodeColor);\r\n          const y = bodyHeight + 24;\r\n          field.move(0, y);\r\n          this.inputGroup.add(field);    \r\n      }  \r\n    }\r\n      return this.fieldGroup;\r\n  }\r\n\r\n      /**\r\n   * create children button field\r\n   * @return button field\r\n   */\r\n  createNodesButtonField(type, bodyHeight, nodes) {\r\n    this.fieldGroup = this.draw.group();\r\n    if(type === 'workflow' || type === 'parameterStudy' || type === 'for' || type === 'while' || type === 'foreach'){\r\n      if( nodes.length > 0){\r\n        console.log(\"nodes check\");\r\n        const titleHeight = 24;\r\n        const titlewidth = 256;    \r\n        const nodeColor = \"rgba(68, 68, 73, 0.5)\";\r\n        const field =  this.draw\r\n          .polygon([\r\n            [0, 0],\r\n            [titlewidth, 0],\r\n            [titlewidth, titleHeight],\r\n            [0, titleHeight],\r\n          ])\r\n          .fill(nodeColor);\r\n    \r\n          const y = bodyHeight;\r\n          field.move(0, y);\r\n          this.fieldGroup.add(field); \r\n        }\r\n    }\r\n      return this.fieldGroup;\r\n  }\r\n\r\n/*   createNodesButton(type, bodyHeight) {\r\n    this.buttonGroup = this.draw.group();    \r\n    if(type === 'workflow' || type === 'parameterStudy' || type === 'for' || type === 'while' || type === 'foreach'){                           \r\n    const statePosX = 232;\r\n    const statePosY = bodyHeight + 4;\r\n    const nodeIconPath = \"/image/btn_openCloseD_n.png\";\r\n    const button = this.draw\r\n      .image(nodeIconPath)\r\n      .attr('class','viewButton')                  \r\n      .x(statePosX)\r\n      .y(statePosY);\r\n      this.buttonGroup.add(button);            \r\n    }\r\n    return this.buttonGroup;\r\n  } */\r\n\r\n  /**\r\n   * create nodes\r\n   * @return nodes\r\n   */\r\n  createNodes(type, nodes) {\r\n    this.nodeGroup = this.draw.group();\r\n    console.log(nodes);\r\n    console.log(type);\r\n    \r\n    if(type === 'workflow' || type === 'parameterStudy' || type === 'for' || type === 'while' || type === 'foreach'){             \r\n      nodes.forEach((node, index) => {\r\n          const nodeColor = __WEBPACK_IMPORTED_MODULE_0__config___default.a.node_color[node.type];\r\n          const nodeIconPath = __WEBPACK_IMPORTED_MODULE_0__config___default.a.node_icon[node.type];          \r\n          const nodePosX = node.pos.x / 10;\r\n          const nodePosY = 32 + node.pos.y / 10;\r\n          const correctNodeIconPath = nodeIconPath.replace(\".png\",\"_p.png\"); \r\n          const img = this.draw\r\n            .image(correctNodeIconPath)\r\n            .attr('class','viewNodes')          \r\n            .fill(nodeColor);\r\n          this.textHeight = 24;\r\n          const x = nodePosX;\r\n          const y = nodePosY + 24;\r\n  \r\n          if( x > 232 || y > 134){\r\n            if(x > 232 && y < 134){\r\n              img.move(232, y);                  \r\n            }\r\n            if(x < 232 && y > 134){\r\n              img.move(x, 134);                            \r\n            } \r\n            if(x > 232 && y > 134)\r\n            {\r\n              img.move(232, 134);                                      \r\n            }\r\n          } else {\r\n            img.move(x, y);        \r\n          }\r\n          this.nodeGroup.add(img);\r\n        \r\n      });\r\n    }\r\n    console.log(\"return\");\r\n    return this.nodeGroup;\r\n  }\r\n\r\n  /**\r\n   * create children icon field\r\n   * @return button field\r\n   */\r\n  createNodesIconField(type, nodes) {\r\n    this.iconFieldGroup = this.draw.group();\r\n    if(type === 'workflow' || type === 'parameterStudy' || type === 'for' || type === 'while' || type === 'foreach'){\r\n      nodes.forEach((node, index) => {        \r\n        const iconFieldHeight = 24;\r\n        const iconTitlewidth = 24;\r\n        const nodeColor = __WEBPACK_IMPORTED_MODULE_0__config___default.a.node_color[node.type];\r\n        const nodePosX = node.pos.x / 10;\r\n        const nodePosY = 32 + node.pos.y / 10;\r\n        const iconField =  this.draw\r\n\r\n        .polygon([\r\n          [0, 0],\r\n          [iconTitlewidth, 0],\r\n          [iconTitlewidth, iconFieldHeight],\r\n          [0, iconFieldHeight],\r\n        ])\r\n        .fill(nodeColor)\r\n        .attr('class','viewNodes');          \r\n        \r\n        const x = nodePosX;\r\n        const y = nodePosY + 24;\r\n\r\n        if( x > 232 || y > 134){\r\n          if(x > 232 && y < 134){\r\n            iconField.move(232, y);                  \r\n          }\r\n          if(x < 232 && y > 134){\r\n            iconField.move(x, 134);                            \r\n          } \r\n          if(x > 232 && y > 134)\r\n          {\r\n            iconField.move(232, 134);                                      \r\n          }\r\n        } else {\r\n          iconField.move(x, y);        \r\n        }\r\n        this.fieldGroup.add(iconField);      \r\n      });\r\n    }\r\n      return this.fieldGroup;\r\n  }\r\n\r\n  /**\r\n   * create state\r\n   * @return state element\r\n   */\r\n  createState(type, state, numTotal, numFinished, numFailed) {\r\n    const statePosX = 220;\r\n    const statePosY = 0;\r\n    const paraStuPosX = 120;\r\n    const nodeStatePath = __WEBPACK_IMPORTED_MODULE_0__config___default.a.state_icon[state];\r\n    const paraStuState = \"Fin:\"+numFinished+\"Fail:\"+numFailed+\"(\"+numTotal+\")\";\r\n    if(type === 'parameterStudy' && state === 'running'){\r\n      return this.draw      \r\n      .text(paraStuState)\r\n      .fill('#FFFFFF')\r\n      .x(paraStuPosX)\r\n      .y(statePosY);\r\n    } else {\r\n      return this.draw\r\n      .image(nodeStatePath)\r\n      .fill('#FFFFFF')\r\n      .x(statePosX)\r\n      .y(statePosY);\r\n    }\r\n  }\r\n\r\n   /**\r\n   * create state\r\n   * @return state element\r\n   */\r\n  createParaStuState(numTotal, numFinished, numFailed) {\r\n    const statePosX = 120;\r\n    const statePosY = 0;\r\n    const paraStuState = \"Fin:\"+20+\"Fail:\"+numFailed+\"(\"+numTotal+\")\";\r\n    return this.draw\r\n      .text(paraStuState)\r\n      .fill('#111')\r\n      .x(statePosX)\r\n      .y(statePosY);\r\n  }\r\n\r\n    /**\r\n   * create workflow component icon\r\n   * @return icon\r\n   */\r\n  createIconImage(type) {\r\n    //ä»ã¯æ±ºãæã¡ã§é©å½ã«è¨­å®\r\n    const statePosX = 8;\r\n    const statePosY = 0;\r\n    const nodeIconPath = __WEBPACK_IMPORTED_MODULE_0__config___default.a.node_icon[type];    \r\n    return this.draw\r\n      //.text(taskState)\r\n      .image(nodeIconPath)\r\n      .fill('#111')\r\n      .x(statePosX)\r\n      .y(statePosY);\r\n  }\r\n\r\n}\r\n\r\nclass SvgParentFilesBox {\r\n  constructor(svg, x, y, type, name, inputFiles, outputFiles) {\r\n    this.draw = svg;\r\n    this.type = type.toLowerCase();\r\n\r\n    const titleHeight = __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.titleHeight;\r\n    const titleWidth = __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.titleWidth;\r\n    const opacity = __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.opacity;\r\n    const outputTextOffset = __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.outputTextOffset;\r\n\r\n    const input = this.createInputText(inputFiles);\r\n    const output = this.createOutputText(outputFiles);\r\n\r\n    const outputBBox = output.bbox();\r\n    const inputBBox = input.bbox();\r\n\r\n    const bodyHeight = titleHeight + Math.ceil(Math.max(inputBBox.height, outputBBox.height));\r\n    \r\n    this.height = bodyHeight + titleHeight;\r\n    this.width = 256;\r\n\r\n    this.box = this.draw.group();\r\n    this.box\r\n      .add(input)\r\n      .add(output)\r\n      .move(x, y)\r\n      .style('cursor', 'default')\r\n      .opacity(opacity)\r\n      .addClass('box');\r\n      \r\n    // adjust size\r\n    output.x(titleWidth);\r\n  }\r\n\r\n  /**\r\n   * create output file text\r\n   * @return output file text\r\n   */\r\n  createOutputText(outputFiles) {\r\n    this.outputGroup = this.draw.group();\r\n    outputFiles.forEach((output, index) => {\r\n      const text = this.draw\r\n        .text(output.name)\r\n        .fill('#FFFFFF');\r\n      this.textHeight = text.bbox().height * __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.textHeightScale;\r\n\r\n      // const x = -text.bbox().width - config.box_appearance.outputTextOffset;\r\n      // const y = calcFileBasePosY() + this.textHeight * index;\r\n      const x = 632;\r\n      //const y = 870+ this.textHeight * index;\r\n      const y = 830 + 40 * index;      \r\n      text.move(x, y);\r\n      this.outputGroup.add(text);\r\n    });\r\n    return this.outputGroup;\r\n  }\r\n  /**\r\n   * create input file text\r\n   * @return input file text\r\n   */\r\n  createInputText(inputFiles) {\r\n    this.inputGroup = this.draw.group();\r\n    inputFiles.forEach((input, index) => {\r\n      const text = this.draw\r\n        .text(input.name)\r\n        .fill('#FFFFFF');\r\n      //this.textHeight = text.bbox().height * config.box_appearance.textHeightScale;\r\n      this.textHeight = 24;\r\n      const x = __WEBPACK_IMPORTED_MODULE_0__config___default.a.box_appearance.inputTextNamePosX;\r\n      //const y = 64 + this.textHeight * index;\r\n      const y = 54 + 40 * index;\r\n\r\n      text.move(x, y);\r\n      this.inputGroup.add(text);\r\n    });\r\n    return this.inputGroup;\r\n  }\r\n\r\n\r\n}\r\n\r\n//plug\r\nfunction createLCPlugAndCable(svg, originX, originY, moveY, color, plugShape, cableDirection, counterpart, callback) {\r\n  //plugã®ä½ç½®ï¼originX,originYï¼ãæ±ºãã\r\n  let plug = svg.polygon(plugShape).fill(color);\r\n  const bbox = plug.bbox();\r\n  //originX -= bbox.width / 2; RPlugã¯å½±é¿ãªã \r\n  if (moveY) originX -= bbox.width / 2;//lowerã®ã¨ã\r\n  //if (moveY) originY -= bbox.height / 2; RPlugã¯å½±é¿ãªã \r\n  plug.move(originX, originY).draggable();\r\n  const cable = new SvgCable(svg, color, cableDirection, originX + bbox.width / 2, originY + bbox.height / 2);\r\n  let firstTime = true;\r\n  let clone = null;\r\n  let dragStartPointX = null;\r\n  let dragStartPointY = null;\r\n  plug\r\n    .on('dragstart', (e) => {\r\n      if (firstTime) {\r\n        clone = plug.clone();\r\n        firstTime = false;\r\n      }\r\n      dragStartPointX = e.detail.p.x;\r\n      dragStartPointY = e.detail.p.y;\r\n    })\r\n    .on('dragmove', (e) => {\r\n      let dx = e.detail.p.x - dragStartPointX;\r\n      let dy = e.detail.p.y - dragStartPointY;\r\n      cable.dragEndPoint(dx, dy);\r\n    })\r\n    .on('dragend', (e) => {\r\n      cable.endX = e.target.instance.x();\r\n      cable.endY = e.target.instance.y();\r\n      const [hitIndex, hitPlug] = collisionDetection(svg, counterpart, cable.endX, cable.endY);\r\n      console.log(\"[hitIndex, hitPlug]\");      \r\n      console.log(hitIndex);\r\n      console.log(hitPlug);\r\n      if (hitIndex === -1) return;\r\n      const myIndex = plug.parent().node.instance.data('index');\r\n      console.log(myIndex);\r\n      \r\n      if (hitIndex !== myIndex) {\r\n        callback(myIndex, hitIndex, plug, hitPlug);\r\n      }\r\n      cable.remove();\r\n      plug.remove();\r\n      plug = clone\r\n    });\r\n  return [plug, cable.cable];\r\n}\r\n\r\nfunction createParentCPlugAndCable(svg, originX, originY, moveY, color, plugShape, cableDirection, counterpart, callback) {\r\n  //plugã®ä½ç½®ï¼originX,originYï¼ãæ±ºãã\r\n  let plug = svg.polygon(plugShape).fill(color);\r\n  console.log(\"plug\");  \r\n  console.log(plug);\r\n  const bbox = plug.bbox();\r\n  if (moveY) originX -= bbox.width / 2;\r\n  plug.move(originX, originY).draggable();\r\n  const cable = new SvgCable(svg, color, cableDirection, originX + bbox.width / 2, originY + bbox.height / 2);\r\n  let firstTime = true;\r\n  let clone = null;\r\n  let dragStartPointX = null;\r\n  let dragStartPointY = null;\r\n  plug\r\n    .on('dragstart', (e) => {\r\n      if (firstTime) {\r\n        clone = plug.clone();\r\n        firstTime = false;\r\n      }\r\n      dragStartPointX = e.detail.p.x;\r\n      dragStartPointY = e.detail.p.y;\r\n    })\r\n    .on('dragmove', (e) => {\r\n      let dx = e.detail.p.x - dragStartPointX;\r\n      let dy = e.detail.p.y - dragStartPointY;\r\n      cable.dragEndPoint(dx, dy);\r\n    })\r\n    .on('dragend', (e) => {\r\n      cable.endX = e.target.instance.x();\r\n      cable.endY = e.target.instance.y();\r\n      const [hitIndex, hitPlug] = collisionDetection(svg, counterpart, cable.endX, cable.endY);\r\n      console.log(\"[hitIndex, hitPlug]\");\r\n      console.log(hitIndex);\r\n      console.log(hitPlug);\r\n      if (hitIndex === -1) return;\r\n      const myIndex = \"parent\";\r\n      //const myIndex = plug.parent().node.instance.data('index');\r\n      console.log(myIndex);\r\n      if (hitIndex !== myIndex) {\r\n        callback(myIndex, hitIndex, plug, hitPlug);\r\n      }\r\n      cable.remove();\r\n      plug.remove();\r\n      plug = clone\r\n    });\r\n  return [plug, cable.cable];\r\n}\r\n\r\n\r\nfunction createLower(svg, originX, originY, offsetX, offsetY, color, sio) {\r\n  return createLCPlugAndCable(svg, originX + offsetX, originY + offsetY, true, color, DPlug, 'DU', '.upperPlug', function (myIndex, hitIndex, plug) {\r\n    sio.emit('addLink', { src: myIndex, dst: hitIndex, isElse: plug.hasClass('elsePlug') });\r\n  });\r\n}\r\n\r\nfunction createConnector(svg, originX, originY, offsetX, offsetY, sio) {\r\n  offsetY += calcFileBasePosY();\r\n  return createLCPlugAndCable(svg, originX + offsetX, originY + offsetY, false, __WEBPACK_IMPORTED_MODULE_0__config___default.a.plug_color.file, RPlug, 'RL', '.receptorPlug', function (myIndex, hitIndex, plug, hitPlug) {\r\n    let srcName = plug.data('name');\r\n    let dstName = hitPlug.data('name');\r\n        console.log(myIndex);\r\n    console.log(hitIndex);\r\n    sio.emit('addFileLink', { src: myIndex, dst: hitIndex, srcName: srcName, dstName: dstName });\r\n  });\r\n}\r\n\r\nfunction createReceptor(svg, originX, originY, offsetX, offsetY) {\r\n  const plug = svg.polygon(LPlug).fill(__WEBPACK_IMPORTED_MODULE_0__config___default.a.plug_color.file).addClass('receptorPlug');\r\n  const bbox = plug.bbox();\r\n  plug.move(originX + offsetX - bbox.width, originY + offsetY + calcFileBasePosY());\r\n  return plug;\r\n}\r\n\r\nfunction createUpper(svg, originX, originY, offsetX, offsetY) {\r\n  const plug = svg.polygon(UPlug).fill(__WEBPACK_IMPORTED_MODULE_0__config___default.a.plug_color.flow).addClass('upperPlug');\r\n  const bbox = plug.bbox();\r\n  plug.move(originX + offsetX - bbox.width / 2, originY + offsetY - bbox.height);\r\n  return plug;\r\n}\r\n\r\nfunction createBox(svg, x, y, type, name, inputFiles, outputFiles, state, nodes, numTotal, numFinished, numFailed) {\r\n  const box = new SvgBox(svg, x, y, type, name, inputFiles, outputFiles, state, nodes, numTotal, numFinished, numFailed);\r\n  return [box.box, box.textHeight];\r\n}\r\n\r\n//parent - children relation \r\nfunction createFilesNameBox(svg, x, y, type, name, inputFiles, outputFiles) {\r\n  const box = new SvgParentFilesBox(svg, x, y, type, name, inputFiles, outputFiles);\r\n  return [box.box, box.textHeight];\r\n}\r\n\r\n//parent -> children connector\r\n//ä½ç½®ã®ä¿®æ­£ãå¿è¦\r\nfunction createParentConnector(svg, originX, originY, offsetX, offsetY, sio) {\r\n  offsetY += calcFileBasePosY();\r\n  return createParentCPlugAndCable(svg, originX + offsetX, originY + offsetY, false, __WEBPACK_IMPORTED_MODULE_0__config___default.a.plug_color.file, parentLPlug, 'RL', '.receptorPlug', function (myIndex, hitIndex, plug, hitPlug) {\r\n    let srcName = plug.data('name');\r\n    let dstName = hitPlug.data('name');\r\n    console.log(myIndex);\r\n    console.log(hitIndex);\r\n    console.log(srcName);\r\n    console.log(dstName);\r\n    sio.emit('addFileLink', { src: myIndex, dst: hitIndex, srcName: srcName, dstName: dstName });\r\n  });\r\n}\r\n\r\n//children -> parent connector\r\n//ä½ç½®ã®ä¿®æ­£ãå¿è¦\r\nfunction createParentReceptor(svg, originX, originY, offsetX, offsetY) {\r\n  const plug = svg.polygon(parentRPlug).fill(__WEBPACK_IMPORTED_MODULE_0__config___default.a.plug_color.file).addClass('receptorPlug');\r\n  const bbox = plug.bbox();\r\n  plug.move(900, originY + offsetY + calcFileBasePosY());\r\n  //plug.move(originX + offsetX - bbox.width / 2, originY + offsetY + calcFileBasePosY());\r\n  return plug;\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2pzL3N2Z1BhcnRzLmpzPzEwMDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEI7O0FBRUE7QUFDQTtBQUNBLGtDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLG1EQUFtRCxrR0FBeUQ7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixHQUFHLEdBQUcsR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRztBQUNoRjtBQUNBO0FBQ0EsaUNBQWlDLEdBQUcsR0FBRyxHQUFHLEtBQUssc0JBQXNCLEtBQUssR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHO0FBQzNGLDhCQUE4QixHQUFHLEdBQUcsR0FBRyxLQUFLLGNBQWMsS0FBSyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUc7QUFDaEYsUUFBUTtBQUNSO0FBQ0EsaUNBQWlDLEdBQUcsR0FBRyxHQUFHLEtBQUssc0JBQXNCLEtBQUssR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHO0FBQzNGLDhCQUE4QixHQUFHLEdBQUcsR0FBRyxLQUFLLFlBQVksS0FBSyxHQUFHLEdBQUcsR0FBRztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUg7QUFDQSw0QjtBQUNBO0FBQ0EsK0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQztBQUNBLE87QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDO0FBQ0EscUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFIO0FBQ0E7QUFDQTtBQUNBLG9HO0FBQ0E7QUFDQTtBQUNBLDRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCO0FBQ0E7QUFDQTtBQUNBLCtCO0FBQ0EsYTtBQUNBO0FBQ0E7QUFDQSxpQztBQUNBO0FBQ0EsV0FBVztBQUNYLDJCO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DO0FBQ0E7QUFDQTtBQUNBLG1DO0FBQ0EsVztBQUNBO0FBQ0E7QUFDQSxxQztBQUNBO0FBQ0EsU0FBUztBQUNULCtCO0FBQ0E7QUFDQSx1QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLHVDQUF1QztBQUN2QywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EseUJBQXlCLGlFQUFpRTtBQUMxRixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0VBQWtFO0FBQy9GLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrRUFBa0U7QUFDL0YsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1NC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjb25maWcgZnJvbSAnLi9jb25maWcnO1xyXG5pbXBvcnQgJy4uL2Nzcy93b3JrZmxvdy5jc3MnO1xyXG5cclxubGV0IFVQbHVnID0gW1swLCAwXSwgWzIwLCAwXSwgWzIwLCA4XSwgWzAsIDhdXTtcclxubGV0IERQbHVnID0gW1swLCAwXSwgWzIwLCAwXSwgWzEwLCAxMl1dO1xyXG5sZXQgTFBsdWcgPSBbWzAsIDBdLCBbOCwgMF0sIFs4LCAxNl0sIFswLCAxNl1dO1xyXG5sZXQgUlBsdWcgPSBbWzAsIDBdLCBbOCwgOF0sIFswLCAxNl1dO1xyXG4vKuimquWtkOmWk+eUqOOAgOWPs+W3pumAhiovXHJcbmxldCBwYXJlbnRSUGx1ZyA9IFtbMCwgMF0sIFsxNiwgMF0sIFsxNiwgMzJdLCBbMCwgMzJdXTtcclxubGV0IHBhcmVudExQbHVnID0gW1swLCAwXSwgWzE2LCAxNl0sIFswLCAzMl1dO1xyXG4vL2xldCBVRFBsdWcgPSBbWzAsIDBdLCBbMjAsIDBdLCBbMjAsIDVdLCBbMTAsIDEwXSwgWzAsIDVdXVxyXG4vL2xldCBMUlBsdWcgPSBbWzAsIDBdLCBbOCwgMF0sIFsxNiwgOF0sIFs4LCAxNl0sIFswLCAxNl1dO1xyXG5cclxuLyoqXHJcbiAqIGNhbGMgeSBjb29yZCBvZiAxc3QgaW5wdXQvb3V0cHV0IGZpbGUgZnJvbSB0b3Agb2YgdGhlIGJveFxyXG4gKiBAcmV0dXJuIHkgY29vcmRcclxuICovXHJcbmZ1bmN0aW9uIGNhbGNGaWxlQmFzZVBvc1koKSB7XHJcbiAgY29uc3QgdGl0bGVIZWlnaHQgPSBjb25maWcuYm94X2FwcGVhcmFuY2UudGl0bGVIZWlnaHQ7XHJcbiAgcmV0dXJuIHRpdGxlSGVpZ2h0O1xyXG4gIC8vY29uc3QgbWFyZ2luSGVpZ2h0ID0gY29uZmlnLmJveF9hcHBlYXJhbmNlLm1hcmdpbkhlaWdodDtcclxuICAvL3JldHVybiB0aXRsZUhlaWdodCArIG1hcmdpbkhlaWdodCAvIDI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjaGVjayBpZiBkcm9wZWQgcGx1ZyBoaXQgYW55IG90aGVyIGNvdW50ZXJwYXJ0XHJcbiAqIEBwYXJhbSBzdmcgaW5zdGFuY2Ugb2Ygc3ZnLmpzXHJcbiAqIEBwYXJhbSBjb3VudGVycGFydCBzZWxlY3RvciBvZiBjb3VudGVycGFydCAoZS5nLiAnLnVwcGVyUGx1dCcsICcucmVjZXB0b3JQbHVnJylcclxuICogQHBhcmFtIHggeCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB3aGljaCB3aWxsIGJlIGNoZWNrZWRcclxuICogQHBhcmFtIHkgeSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB3aGljaCB3aWxsIGJlIGNoZWNrZWRcclxuICovXHJcbmZ1bmN0aW9uIGNvbGxpc2lvbkRldGVjdGlvbihzdmcsIGNvdW50ZXJwYXJ0LCB4LCB5KSB7XHJcbiAgY29uc29sZS5sb2coXCJjb2xsaXNpb25EZXRlY3Rpb25cIik7XHJcbiAgXHJcbiAgbGV0IG1pbkRpc3RhbmNlMiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgbGV0IG5lYXJlc3ROb2RlSW5kZXggPSAtMTtcclxuICBsZXQgbmVhcmVzdFBsdWdQb2ludHMgPSBudWxsO1xyXG4gIGxldCBuZWFyZXN0UGx1ZyA9IG51bGw7XHJcbiAgLy8gZHJvcOOBl+OBn3BsdWfjgajlr77lv5zjgZnjgovnqK7poZ7jga5wbHVn44Gu44GG44Gh5pyA44KC6Led6Zui44GM6L+R44GE44KC44Gu44KS5o6i44GZXHJcbiAgc3ZnLnNlbGVjdChjb3VudGVycGFydCkuZWFjaChmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgbGV0IGluZGV4ID0gdltpXS5wYXJlbnQoKS5ub2RlLmluc3RhbmNlLmRhdGEoJ2luZGV4Jyk7XHJcbiAgICBsZXQgcG9pbnRzID0gdltpXS5ub2RlLnBvaW50cztcclxuICAgIGxldCB0YXJnZXRYID0gcG9pbnRzWzNdLng7XHJcbiAgICBsZXQgdGFyZ2V0WSA9IHBvaW50c1syXS55O1xyXG4gICAgbGV0IGRpc3RhbmNlMiA9ICh0YXJnZXRYIC0geCkgKiAodGFyZ2V0WCAtIHgpICsgKHRhcmdldFkgLSB5KSAqICh0YXJnZXRZIC0geSk7XHJcbiAgICBjb25zb2xlLmxvZyhkaXN0YW5jZTIpO1xyXG4gICAgaWYgKG1pbkRpc3RhbmNlMiA+IGRpc3RhbmNlMikge1xyXG4gICAgICBtaW5EaXN0YW5jZTIgPSBkaXN0YW5jZTI7XHJcbiAgICAgIG5lYXJlc3ROb2RlSW5kZXggPSBpbmRleDtcclxuICAgICAgLy9jaGlsZCAtPiBwYXJlbnTjga7jgajjgY1cclxuICAgICAgaWYoaW5kZXggPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgbmVhcmVzdE5vZGVJbmRleCA9IFwicGFyZW50XCI7ICAgICAgICBcclxuICAgICAgfVxyXG4gICAgICBuZWFyZXN0UGx1Z1BvaW50cyA9IHBvaW50cztcclxuICAgICAgbmVhcmVzdFBsdWcgPSB2W2ldO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2cobWluRGlzdGFuY2UyKTsgICAgICAgIFxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhzdmcpO1xyXG4gICAgY29uc29sZS5sb2codik7XHJcbiAgICBjb25zb2xlLmxvZyhuZWFyZXN0Tm9kZUluZGV4KTsgICAgXHJcbiAgICBjb25zb2xlLmxvZyhuZWFyZXN0UGx1Zyk7XHJcbiAgICBcclxuICB9KTtcclxuICAvLyDmnIDov5Hlgo1wbHVn44Gu6aCC54K55bqn5qiZ44GL44KJ5b2T44Gf44KK6aCY5Z+f44KS5L2c5oiQXHJcbiAgbGV0IHhQb2ludHMgPSBBcnJheS5mcm9tKG5lYXJlc3RQbHVnUG9pbnRzKS5tYXAoKHApID0+IHtcclxuICAgIHJldHVybiBwLng7XHJcbiAgfSk7XHJcbiAgbGV0IHlQb2ludHMgPSBBcnJheS5mcm9tKG5lYXJlc3RQbHVnUG9pbnRzKS5tYXAoKHApID0+IHtcclxuICAgIHJldHVybiBwLnk7XHJcbiAgfSk7XHJcbiAgbGV0IG1pblggPSBNYXRoLm1pbiguLi54UG9pbnRzKTtcclxuICBsZXQgbWF4WCA9IE1hdGgubWF4KC4uLnhQb2ludHMpO1xyXG4gIGxldCBtaW5ZID0gTWF0aC5taW4oLi4ueVBvaW50cyk7XHJcbiAgbGV0IG1heFkgPSBNYXRoLm1heCguLi55UG9pbnRzKTtcclxuICBsZXQgZXh0ZW5kWCA9IChtYXhYIC0gbWluWCkgKiAoY29uZmlnLmJveF9hcHBlYXJhbmNlLnBsdWdfZHJvcF9hcmVhX3NjYWxlIC0gMS4wKSAvIDI7XHJcbiAgbGV0IGV4dGVuZFkgPSAobWF4WSAtIG1pblkpICogKGNvbmZpZy5ib3hfYXBwZWFyYW5jZS5wbHVnX2Ryb3BfYXJlYV9zY2FsZSAtIDEuMCkgLyAyO1xyXG4gIG1pblggLT0gZXh0ZW5kWDtcclxuICBtYXhYICs9IGV4dGVuZFg7XHJcbiAgbWluWSAtPSBleHRlbmRZO1xyXG4gIG1heFkgKz0gZXh0ZW5kWTtcclxuICBjb25zb2xlLmxvZyhtYXhYKTtcclxuICBjb25zb2xlLmxvZyhtYXhZKTtcclxuICBjb25zb2xlLmxvZyhtaW5YKTtcclxuICBjb25zb2xlLmxvZyhtaW5ZKTtcclxuICBjb25zb2xlLmxvZyh4KTtcclxuICBjb25zb2xlLmxvZyh5KTtcclxuICBcclxuXHJcbiAgLy8g5pyA6L+R5YKNcGx1Z+OBjOevhOWbsuWGheOBq+WFpeOBo+OBpuOBhOOCjOOBsCBpbmRleOOBqOOBneOBrnBsdWfjgpLov5TjgZlcclxuICBpZiAobWluWCA8IHggJiYgeCA8IG1heFggJiYgbWluWSA8IHkgJiYgeSA8IG1heFkpIHtcclxuICAgIHJldHVybiBbbmVhcmVzdE5vZGVJbmRleCwgbmVhcmVzdFBsdWddO1xyXG4gIH1cclxuICAvLyDlpJbjgozjga7mmYLjga8gLTHjgpLkuozjgaQoaW5kZXjjgahwbHVnKei/lOOBmVxyXG4gIHJldHVybiBbLTEsIC0xXTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFN2Z0NhYmxlIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0gc3ZnIGluc3RhbmNlIG9mIHN2Zy5qc1xyXG4gICAqIEBwYXJhbSBjb2xvciBjb2xvciBvZiB0aGUgY2FibGVcclxuICAgKiBAcGFyYW0gZGlyZWN0aW9uIGRpcmVjdGlvbiBvZiB0aGUgY2FibGUuIERVKERvd24gdG8gVXApIG9yIFJMKFJpZ2h0IHRvIExlZ3QpXHJcbiAgICogQHBhcmFtIHN0YXJ0WCB4IGNvb3JkaW5hdGUgb2YgaW5pdGlhbCBzdGFydCBwb2ludFxyXG4gICAqIEBwYXJhbSBzdGFydFkgeSBjb29yZGluYXRlIG9mIGluaXRpYWwgc3RhcnQgcG9pbnRcclxuICAgKiBAcGFyYW0gZW5kdFggeCBjb29yZGluYXRlIG9mIGluaXRpYWwgZW5kIHBvaW50XHJcbiAgICogQHBhcmFtIGVuZHRZIHkgY29vcmRpbmF0ZSBvZiBpbml0aWFsIGVuZCBwb2ludFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHN2ZywgY29sb3IsIGRpcmVjdGlvbiwgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFkpIHtcclxuICAgIHRoaXMudG1wU3ZnID0gc3ZnOyAvL2ZvciBkZWJ1ZyBjYWxjQ29udHJvbFBvaW50XHJcbiAgICB0aGlzLmNhYmxlID0gc3ZnLnBhdGgoJycpLmZpbGwoJ25vbmUnKS5zdHJva2UoeyBjb2xvcjogY29sb3IsIHdpZHRoOiBjb25maWcuYm94X2FwcGVhcmFuY2Uuc3Ryb2tlV2lkdGggfSk7XHJcbiAgICB0aGlzLnN0YXJ0WCA9IHN0YXJ0WDtcclxuICAgIHRoaXMuc3RhcnRZID0gc3RhcnRZO1xyXG4gICAgdGhpcy5lbmRYID0gZW5kWCB8fCBzdGFydFg7XHJcbiAgICB0aGlzLmVuZFkgPSBlbmRZIHx8IHN0YXJ0WTtcclxuICAgIGlmIChkaXJlY3Rpb24gPT09ICdEVScgfHwgZGlyZWN0aW9uID09PSAnUkwnKSB7XHJcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coJ2lsbGVnYWwgZGlyZWN0aW9uOiAnLCBkaXJlY3Rpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuICBfY2FsY0NvbnRyb2xQb2ludChzeCwgc3ksIGV4LCBleSwgYm94QmJveCkge1xyXG4gICAgY29uc3Qgc2NhbGVSYW5nZSA9IDEuNTtcclxuICAgIGNvbnN0IHNjYWxlQ29udHJvbFBvaW50ID0gMS44O1xyXG4gICAgY29uc3QgbXggPSAoc3ggKyBleCkgLyAyO1xyXG4gICAgY29uc3QgbXkgPSAoc3kgKyBleSkgLyAyO1xyXG4gICAgbGV0IGNwMXggPSAwO1xyXG4gICAgbGV0IGNwMXkgPSAwO1xyXG4gICAgbGV0IGNwMnggPSAwO1xyXG4gICAgbGV0IGNwMnkgPSAwO1xyXG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnRFUnKSB7XHJcbiAgICAgIGNvbnN0IGJveFdpZHRoID0gYm94QmJveC53aWR0aDtcclxuICAgICAgY29uc3Qgb2Zmc2V0ID0gYm94V2lkdGggKiBzY2FsZUNvbnRyb2xQb2ludDtcclxuICAgICAgaWYgKGV5IDwgc3kpIHtcclxuICAgICAgICBpZiAoc3ggLSBib3hXaWR0aCAqIHNjYWxlUmFuZ2UgPCBleCAmJiBleCA8IHN4ICsgYm94V2lkdGggKiBzY2FsZVJhbmdlKSB7XHJcbiAgICAgICAgICBpZiAoc3ggPiBleCkge1xyXG4gICAgICAgICAgICBjcDF4ID0gc3ggKyBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGNwMXkgPSBzeSArIG9mZnNldDtcclxuICAgICAgICAgICAgY3AyeCA9IGV4ICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICBjcDJ5ID0gZXkgLSBvZmZzZXQ7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjcDF4ID0gc3ggLSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGNwMXkgPSBzeSArIG9mZnNldDtcclxuICAgICAgICAgICAgY3AyeCA9IGV4IC0gb2Zmc2V0O1xyXG4gICAgICAgICAgICBjcDJ5ID0gZXkgLSBvZmZzZXQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNwMXggPSBteDtcclxuICAgICAgICAgIGNwMXkgPSBzeSArIG9mZnNldDtcclxuICAgICAgICAgIGNwMnggPSBteDtcclxuICAgICAgICAgIGNwMnkgPSBleSAtIG9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3AxeCA9IHN4O1xyXG4gICAgICAgIGNwMXkgPSBteTtcclxuICAgICAgICBjcDJ4ID0gZXg7XHJcbiAgICAgICAgY3AyeSA9IG15O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnUkwnKSB7XHJcbiAgICAgIGNvbnN0IGJveEhlaWdodCA9IGJveEJib3guaGVpZ2h0O1xyXG4gICAgICBjb25zdCBvZmZzZXQgPSBib3hIZWlnaHQgKiBzY2FsZUNvbnRyb2xQb2ludDtcclxuICAgICAgaWYgKGV4IDwgc3gpIHtcclxuICAgICAgICBpZiAoc3kgLSBib3hIZWlnaHQgKiBzY2FsZVJhbmdlIDwgZXkgJiYgZXkgPCBzeSArIGJveEhlaWdodCAqIHNjYWxlUmFuZ2UpIHtcclxuICAgICAgICAgIGNwMXggPSBzeCArIG9mZnNldDtcclxuICAgICAgICAgIGNwMXkgPSBzeSAtIG9mZnNldDtcclxuICAgICAgICAgIGNwMnggPSBleCAtIG9mZnNldDtcclxuICAgICAgICAgIGNwMnkgPSBleSAtIG9mZnNldDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY3AxeCA9IHN4ICsgb2Zmc2V0O1xyXG4gICAgICAgICAgY3AxeSA9IG15O1xyXG4gICAgICAgICAgY3AyeCA9IGV4IC0gb2Zmc2V0O1xyXG4gICAgICAgICAgY3AyeSA9IG15O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjcDF4ID0gbXg7XHJcbiAgICAgICAgY3AxeSA9IHN5O1xyXG4gICAgICAgIGNwMnggPSBteDtcclxuICAgICAgICBjcDJ5ID0gZXk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbY3AxeCwgY3AxeSwgY3AyeCwgY3AyeV07XHJcbiAgfVxyXG4gIF9kcmF3KHN4LCBzeSwgZXgsIGV5LCBib3hCYm94KSB7XHJcbiAgICBpZiAoYm94QmJveCA9PSBudWxsKSB7XHJcbiAgICAgIGJveEJib3ggPSB0aGlzLmNhYmxlLnBhcmVudCgpLm5vZGUuaW5zdGFuY2UuZGF0YSgnYm94QmJveCcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgW2NwMXgsIGNwMXksIGNwMngsIGNwMnldID0gdGhpcy5fY2FsY0NvbnRyb2xQb2ludChzeCwgc3ksIGV4LCBleSwgYm94QmJveCk7XHJcbiAgICB0aGlzLmNhYmxlLnBsb3QoYE0gJHtzeH0gJHtzeX0gQyAke2NwMXh9ICR7Y3AxeX0gJHtjcDJ4fSAke2NwMnl9ICR7ZXh9ICR7ZXl9YClcclxuICAgIC8vIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ0RVJykge1xyXG4gICAgLy8gICAvLyBjb25zdCB0ID0gMiAqIE1hdGguYWJzKE1hdGguYXRhbigoZXggLSBzeCkgLyAoZXkgLSBzeSkpKSAvIE1hdGguUEk7XHJcbiAgICAvLyAgIC8vIHRoaXMuY2FibGUucGxvdChgTSAke3N4fSAke3N5fSBWICR7dCAqIHN5ICsgKDEgLSB0KSAqIGV5fSBIICR7ZXh9IEwgJHtleH0gJHtleX1gKVxyXG4gICAgLy8gICB0aGlzLmNhYmxlLnBsb3QoYE0gJHtzeH0gJHtzeX0gViAkeyhzeSArIGV5KSAvIDJ9IEggJHtleH0gTCAke2V4fSAke2V5fWApXHJcbiAgICAvLyB9IGVsc2Uge1xyXG4gICAgLy8gICAvLyBjb25zdCB0ID0gMiAqIE1hdGguYWJzKE1hdGguYXRhbigoZXkgLSBzeSkgLyAoZXggLSBzeCkpKSAvIE1hdGguUEk7XHJcbiAgICAvLyAgIC8vIHRoaXMuY2FibGUucGxvdChgTSAke3N4fSAke3N5fSBIICR7dCAqIHN4ICsgKDEgLSB0KSAqIGV4fSBWICR7ZXl9IEwgJHtleH0gJHtleX1gKVxyXG4gICAgLy8gICB0aGlzLmNhYmxlLnBsb3QoYE0gJHtzeH0gJHtzeX0gSCAkeyhzeCtleCkgLyAyfSBMICR7ZXh9ICR7ZXl9YClcclxuICAgIC8vIH1cclxuICB9XHJcbiAgZHJhZ0VuZFBvaW50KGR4LCBkeSwgYm94QmJveCkge1xyXG4gICAgdGhpcy5fZHJhdyh0aGlzLnN0YXJ0WCwgdGhpcy5zdGFydFksIHRoaXMuZW5kWCArIGR4LCB0aGlzLmVuZFkgKyBkeSwgYm94QmJveCk7XHJcbiAgfVxyXG4gIGRyYWdTdGFydFBvaW50KGR4LCBkeSwgYm94QmJveCkge1xyXG4gICAgdGhpcy5fZHJhdyh0aGlzLnN0YXJ0WCArIGR4LCB0aGlzLnN0YXJ0WSArIGR5LCB0aGlzLmVuZFgsIHRoaXMuZW5kWSwgYm94QmJveCk7XHJcbiAgfVxyXG4gIHJlbW92ZSgpIHtcclxuICAgIGlmICh0aGlzLmNhYmxlICE9IG51bGwpIHRoaXMuY2FibGUucmVtb3ZlKCk7XHJcbiAgICB0aGlzLmNhYmxlID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFN2Z0JveCB7XHJcbiAgY29uc3RydWN0b3Ioc3ZnLCB4LCB5LCB0eXBlLCBuYW1lLCBpbnB1dEZpbGVzLCBvdXRwdXRGaWxlcywgc3RhdGUsIG5vZGVzLCBudW1Ub3RhbCwgbnVtRmluaXNoZWQsIG51bUZhaWxlZCkge1xyXG4gICAgdGhpcy5kcmF3ID0gc3ZnO1xyXG4gICAgdGhpcy50eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIC8vIHJlYWQgZHJhdyBzZXR0aW5ncyBmcm9tIGNvbmZpZ1xyXG4gICAgLy8gdXBwZXIgcGFydHMgKG91dGVyRnJhbWUpXHJcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IGNvbmZpZy5ib3hfYXBwZWFyYW5jZS50aXRsZUhlaWdodDtcclxuICAgIGNvbnN0IHRpdGxlV2lkdGggPSBjb25maWcuYm94X2FwcGVhcmFuY2UudGl0bGVXaWR0aDtcclxuICAgIFxyXG4gICAgY29uc3Qgb3BhY2l0eSA9IGNvbmZpZy5ib3hfYXBwZWFyYW5jZS5vcGFjaXR5O1xyXG4gICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBjb25maWcuYm94X2FwcGVhcmFuY2Uuc3Ryb2tlV2lkdGg7XHJcbiAgICBjb25zdCBtYXJnaW5IZWlnaHQgPSBjb25maWcuYm94X2FwcGVhcmFuY2UubWFyZ2luSGVpZ2h0O1xyXG4gICAgY29uc3QgbWFyZ2luV2lkdGggPSB0aXRsZUhlaWdodCAqIDI7XHJcbiAgICBjb25zdCBvdXRwdXRUZXh0T2Zmc2V0ID0gY29uZmlnLmJveF9hcHBlYXJhbmNlLm91dHB1dFRleHRPZmZzZXQ7XHJcbiAgICBjb25zdCBub2RlQ29sb3IgPSBjb25maWcubm9kZV9jb2xvclt0eXBlXTtcclxuXHJcbiAgICAvLyBjcmVhdGUgaW5uZXIgcGFydHNcclxuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5jcmVhdGVJbnB1dFRleHQoaW5wdXRGaWxlcyk7XHJcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmNyZWF0ZU91dHB1dFRleHQob3V0cHV0RmlsZXMpO1xyXG5cclxuICAgIGNvbnN0IG91dHB1dEJCb3ggPSBvdXRwdXQuYmJveCgpO1xyXG4gICAgY29uc3QgaW5wdXRCQm94ID0gaW5wdXQuYmJveCgpO1xyXG5cclxuICAgIGNvbnN0IGJvZHlIZWlnaHQgPSB0aXRsZUhlaWdodCArIE1hdGguY2VpbChNYXRoLm1heChpbnB1dEJCb3guaGVpZ2h0LCBvdXRwdXRCQm94LmhlaWdodCkpO1xyXG4gICAgLy9jb25zdCBib2R5SGVpZ2h0ID0gbWFyZ2luSGVpZ2h0ICsgTWF0aC5jZWlsKE1hdGgubWF4KGlucHV0QkJveC5oZWlnaHQsIG91dHB1dEJCb3guaGVpZ2h0KSk7XHJcbiAgICBcclxuICAgIHRoaXMuaGVpZ2h0ID0gYm9keUhlaWdodCArIHRpdGxlSGVpZ2h0O1xyXG5cclxuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5jcmVhdGVUaXRsZShuYW1lKTtcclxuICAgIGNvbnN0IGljb25JbWFnZSA9IHRoaXMuY3JlYXRlSWNvbkltYWdlKHR5cGUpO1xyXG4gICAgY29uc3QgdGFza1N0YXRlID0gdGhpcy5jcmVhdGVTdGF0ZSh0eXBlLCBzdGF0ZSwgbnVtVG90YWwsIG51bUZpbmlzaGVkLCBudW1GYWlsZWQpO1xyXG5cclxuICAgIC8vIGNvbnN0IG5vZGVzVmlld0ZpZWxkID0gdGhpcy5jcmVhdGVOb2Rlc1ZpZXdGaWVsZCh0eXBlLCBib2R5SGVpZ2h0LCBub2Rlcyk7XHJcbiAgICAvLyBjb25zdCBub2Rlc0J1dHRvbkZpZWxkID0gdGhpcy5jcmVhdGVOb2Rlc0J1dHRvbkZpZWxkKHR5cGUsIGJvZHlIZWlnaHQsIG5vZGVzKTtcclxuICAgIC8vIGNvbnN0IG5vZGVzVmlldyA9IHRoaXMuY3JlYXRlTm9kZXModHlwZSwgbm9kZXMpO1xyXG4gICAgLy8gY29uc3Qgbm9kZXNJY29uRmllbGQgPSB0aGlzLmNyZWF0ZU5vZGVzSWNvbkZpZWxkKHR5cGUsIG5vZGVzKTtcclxuICAgIC8vIGNvbnN0IG5vZGVzVmlld0J1dHRvbiA9IHRoaXMuY3JlYXRlTm9kZXNCdXR0b24odHlwZSwgYm9keUhlaWdodCk7XHJcblxyXG5cclxuICAgIFxyXG4gICAgLy/msbrjgoHmiZPjgaHjgavlpInmm7RcclxuICAgIHRoaXMud2lkdGggPSAyNTY7XHJcbiAgICAvL3RoaXMud2lkdGggPSBNYXRoLmNlaWwoTWF0aC5tYXgoaW5wdXRCQm94LndpZHRoICsgb3V0cHV0QkJveC53aWR0aCwgdGl0bGUuYmJveCgpLndpZHRoKSkgKyBtYXJnaW5XaWR0aDtcclxuXHJcbiAgICBjb25zdCBvdXRlckZyYW1lID0gdGhpcy5jcmVhdGVPdXRlckZyYW1lKHR5cGUpO1xyXG4gICAgY29uc3QgaW5uZXJGcmFtZSA9IHRoaXMuY3JlYXRlSW5uZXJGcmFtZSgpO1xyXG5cclxuICAgIHRoaXMuYm94ID0gdGhpcy5kcmF3Lmdyb3VwKCk7XHJcbiAgICB0aGlzLmJveFxyXG4gICAgICAuYWRkKG91dGVyRnJhbWUpXHJcbiAgICAgIC5hZGQoaW5uZXJGcmFtZSlcclxuICAgICAgLmFkZCh0aXRsZSlcclxuICAgICAgLmFkZChpbnB1dClcclxuICAgICAgLmFkZChvdXRwdXQpXHJcbiAgICAgIC5hZGQodGFza1N0YXRlKVxyXG4gICAgICAuYWRkKGljb25JbWFnZSlcclxuICAgICAgLy8gLmFkZChub2Rlc0J1dHRvbkZpZWxkKVxyXG4gICAgICAvLyAuYWRkKG5vZGVzVmlld0J1dHRvbilcclxuICAgICAgLy8gLmFkZChub2Rlc1ZpZXdGaWVsZClcclxuICAgICAgLy8gLmFkZChub2Rlc0ljb25GaWVsZCkgICAgICAgICAgICBcclxuICAgICAgLy8gLmFkZChub2Rlc1ZpZXcpXHJcbiAgICAgIC5tb3ZlKHgsIHkpXHJcbiAgICAgIC5zdHlsZSgnY3Vyc29yJywgJ2RlZmF1bHQnKVxyXG4gICAgICAub3BhY2l0eShvcGFjaXR5KVxyXG4gICAgICAuYWRkQ2xhc3MoJ2JveCcpO1xyXG4gICAgICBcclxuICAgIC8vIGFkanVzdCBzaXplXHJcbiAgICAvL291dHB1dC54KHRoaXMud2lkdGgpO1xyXG4gICAgb3V0cHV0LngodGl0bGVXaWR0aCk7XHJcbiAgICBcclxuICAgIC8vaW5uZXJGcmFtZS5zaXplKHRoaXMud2lkdGggLSBzdHJva2VXaWR0aCwgYm9keUhlaWdodCk7XHJcbiAgICBpbm5lckZyYW1lLnNpemUodGl0bGVXaWR0aCwgYm9keUhlaWdodCk7XHJcbiAgICBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSBvdXRlciBmcmFtZVxyXG4gICAqIEByZXR1cm4gb3V0ZXIgZnJhbWUgZWxlbWVudFxyXG4gICAqL1xyXG4vKiAgIGNyZWF0ZU91dGVyRnJhbWUoKSB7XHJcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IGNvbmZpZy5ib3hfYXBwZWFyYW5jZVsndGl0bGVIZWlnaHQnXTtcclxuICAgIGNvbnN0IG5vZGVDb2xvciA9IGNvbmZpZy5ub2RlX2NvbG9yW3RoaXMudHlwZV07XHJcbiAgICByZXR1cm4gdGhpcy5kcmF3XHJcbiAgICAgIC5wb2x5Z29uKFtcclxuICAgICAgICBbdGl0bGVIZWlnaHQgLyAyLCAwXSxcclxuICAgICAgICBbdGhpcy53aWR0aCwgMF0sXHJcbiAgICAgICAgW3RoaXMud2lkdGgsIHRpdGxlSGVpZ2h0XSxcclxuICAgICAgICBbMCwgdGl0bGVIZWlnaHRdLFxyXG4gICAgICAgIFswLCB0aXRsZUhlaWdodCAvIDJdXHJcbiAgICAgIF0pXHJcbiAgICAgIC5maWxsKG5vZGVDb2xvcik7XHJcbiAgfSAqL1xyXG4gIC8v55+p5b2i44OQ44O844K444On44Oz44KS6ICD44GI44KLXHJcbiAgY3JlYXRlT3V0ZXJGcmFtZSh0eXBlKSB7XHJcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IDMyO1xyXG4gICAgY29uc3QgdGl0bGV3aWR0aCA9IDI1NjsgICAgXHJcbiAgICBjb25zdCBub2RlQ29sb3IgPSBjb25maWcubm9kZV9jb2xvclt0eXBlXTtcclxuICAgIHJldHVybiB0aGlzLmRyYXdcclxuICAgICAgLnBvbHlnb24oW1xyXG4gICAgICAgIFswLCAwXSxcclxuICAgICAgICBbdGl0bGV3aWR0aCwgMF0sXHJcbiAgICAgICAgW3RpdGxld2lkdGgsIHRpdGxlSGVpZ2h0XSxcclxuICAgICAgICBbMCwgdGl0bGVIZWlnaHRdLFxyXG4gICAgICBdKVxyXG4gICAgICAuZmlsbChub2RlQ29sb3IpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBjcmVhdGUgaW5uZXIgZnJhbWVcclxuICAgKiBAcmV0dXJuIGlubmVyIGZyYW1lIGVsZW1lbnRcclxuICAgKi9cclxuLyogICBjcmVhdGVJbm5lckZyYW1lKCkge1xyXG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSBjb25maWcuYm94X2FwcGVhcmFuY2VbJ3RpdGxlSGVpZ2h0J107XHJcbiAgICBjb25zdCBzdHJva2VXaWR0aCA9IGNvbmZpZy5ib3hfYXBwZWFyYW5jZVsnc3Ryb2tlV2lkdGgnXTtcclxuICAgIGNvbnN0IG5vZGVDb2xvciA9IGNvbmZpZy5ub2RlX2NvbG9yW3RoaXMudHlwZV07XHJcbiAgICByZXR1cm4gdGhpcy5kcmF3XHJcbiAgICAgIC5yZWN0KDAsIDApXHJcbiAgICAgIC5hdHRyKHtcclxuICAgICAgICAnZmlsbCc6ICdyZ2IoNTAsIDUwLCA1MCknLFxyXG4gICAgICAgICdzdHJva2UnOiBub2RlQ29sb3IsXHJcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoXHJcbiAgICAgIH0pXHJcbiAgICAgIC5tb3ZlKHN0cm9rZVdpZHRoIC8gMiwgdGl0bGVIZWlnaHQpO1xyXG4gIH0gKi9cclxuICAgIGNyZWF0ZUlubmVyRnJhbWUoKSB7XHJcbiAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gMzI7XHJcbiAgICAgIGNvbnN0IHRpdGxlV2lkdGggPSAyNTY7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gdGhpcy5kcmF3XHJcbiAgICAgIC5wb2x5Z29uKFtcclxuICAgICAgICBbMCwgMF0sXHJcbiAgICAgICAgW3RpdGxlV2lkdGgsIDBdLFxyXG4gICAgICAgIFt0aXRsZVdpZHRoLCB0aXRsZUhlaWdodF0sXHJcbiAgICAgICAgWzAsIHRpdGxlSGVpZ2h0XSxcclxuICAgICAgXSlcclxuICAgICAgLmZpbGwoXCJyZ2JhKDY4LCA2OCwgNzMsMC41XCIpO1xyXG4gICAgfVxyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSB0aXRsZVxyXG4gICAqIEByZXR1cm4gdGl0bGUgZWxlbWVudFxyXG4gICAqL1xyXG4gICBjcmVhdGVUaXRsZShuYW1lKSB7XHJcbiAgICBjb25zdCB0aXRsZVBvc1kgPSA2O1xyXG4gICAgY29uc3QgdGl0bGVQb3NYID0gNDg7XHJcbiAgICByZXR1cm4gdGhpcy5kcmF3XHJcbiAgICAgIC50ZXh0KG5hbWUpXHJcbiAgICAgIC5maWxsKCcjRkZGRkZGJylcclxuICAgICAgLngodGl0bGVQb3NYKVxyXG4gICAgICAueSh0aXRsZVBvc1kpO1xyXG4gICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSBvdXRwdXQgZmlsZSB0ZXh0XHJcbiAgICogQHJldHVybiBvdXRwdXQgZmlsZSB0ZXh0XHJcbiAgICovXHJcbiAgY3JlYXRlT3V0cHV0VGV4dChvdXRwdXRGaWxlcykge1xyXG4gICAgdGhpcy5vdXRwdXRHcm91cCA9IHRoaXMuZHJhdy5ncm91cCgpO1xyXG4gICAgb3V0cHV0RmlsZXMuZm9yRWFjaCgob3V0cHV0LCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCB0ZXh0ID0gdGhpcy5kcmF3XHJcbiAgICAgICAgLnRleHQob3V0cHV0Lm5hbWUpXHJcbiAgICAgICAgLmZpbGwoJyNGRkZGRkYnKTtcclxuICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gdGV4dC5iYm94KCkuaGVpZ2h0ICogY29uZmlnLmJveF9hcHBlYXJhbmNlLnRleHRIZWlnaHRTY2FsZTtcclxuXHJcbiAgICAgIGNvbnN0IHggPSAtdGV4dC5iYm94KCkud2lkdGggLSBjb25maWcuYm94X2FwcGVhcmFuY2Uub3V0cHV0VGV4dE9mZnNldDtcclxuICAgICAgY29uc3QgeSA9IGNhbGNGaWxlQmFzZVBvc1koKSArIHRoaXMudGV4dEhlaWdodCAqIGluZGV4O1xyXG4gICAgICB0ZXh0Lm1vdmUoeCwgeSk7XHJcbiAgICAgIHRoaXMub3V0cHV0R3JvdXAuYWRkKHRleHQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRHcm91cDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogY3JlYXRlIGlucHV0IGZpbGUgdGV4dFxyXG4gICAqIEByZXR1cm4gaW5wdXQgZmlsZSB0ZXh0XHJcbiAgICovXHJcbiAgY3JlYXRlSW5wdXRUZXh0KGlucHV0RmlsZXMpIHtcclxuICAgIHRoaXMuaW5wdXRHcm91cCA9IHRoaXMuZHJhdy5ncm91cCgpO1xyXG4gICAgaW5wdXRGaWxlcy5mb3JFYWNoKChpbnB1dCwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgdGV4dCA9IHRoaXMuZHJhd1xyXG4gICAgICAgIC50ZXh0KGlucHV0Lm5hbWUpXHJcbiAgICAgICAgLmZpbGwoJyNGRkZGRkYnKTtcclxuICAgICAgLy90aGlzLnRleHRIZWlnaHQgPSB0ZXh0LmJib3goKS5oZWlnaHQgKiBjb25maWcuYm94X2FwcGVhcmFuY2UudGV4dEhlaWdodFNjYWxlO1xyXG4gICAgICB0aGlzLnRleHRIZWlnaHQgPSAyNDtcclxuICAgICAgY29uc3QgeCA9IGNvbmZpZy5ib3hfYXBwZWFyYW5jZS5pbnB1dFRleHROYW1lUG9zWDtcclxuICAgICAgY29uc3QgeSA9IDMyICsgdGhpcy50ZXh0SGVpZ2h0ICogaW5kZXg7XHJcbiAgICAgIHRleHQubW92ZSh4LCB5KTtcclxuICAgICAgdGhpcy5pbnB1dEdyb3VwLmFkZCh0ZXh0KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuaW5wdXRHcm91cDtcclxuICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICogY3JlYXRlIGNoaWxkcmVuIHZpZXcgZmllbGRcclxuICAgKiBAcmV0dXJuIHZpZXcgZmllbGRcclxuICAgKi9cclxuICBjcmVhdGVOb2Rlc1ZpZXdGaWVsZCh0eXBlLCBib2R5SGVpZ2h0LCBub2Rlcykge1xyXG4gICAgdGhpcy5maWVsZEdyb3VwID0gdGhpcy5kcmF3Lmdyb3VwKCk7XHJcbiAgICBpZih0eXBlID09PSAnd29ya2Zsb3cnIHx8IHR5cGUgPT09ICdwYXJhbWV0ZXJTdHVkeScgfHwgdHlwZSA9PT0gJ2ZvcicgfHwgdHlwZSA9PT0gJ3doaWxlJyB8fCB0eXBlID09PSAnZm9yZWFjaCcpeyBcclxuICAgICAgaWYoIG5vZGVzLmxlbmd0aCA+IDApeyAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSAxNjA7XHJcbiAgICAgICAgY29uc3QgdGl0bGV3aWR0aCA9IDI1NjsgICAgXHJcbiAgICAgICAgY29uc3Qgbm9kZUNvbG9yID0gXCJyZ2JhKDY4LCA2OCwgNzMsIDAuNSlcIjtcclxuICAgICAgICBjb25zdCBmaWVsZCA9ICB0aGlzLmRyYXdcclxuICAgICAgICAgIC5wb2x5Z29uKFtcclxuICAgICAgICAgICAgWzAsIDBdLFxyXG4gICAgICAgICAgICBbdGl0bGV3aWR0aCwgMF0sXHJcbiAgICAgICAgICAgIFt0aXRsZXdpZHRoLCB0aXRsZUhlaWdodF0sXHJcbiAgICAgICAgICAgIFswLCB0aXRsZUhlaWdodF0sXHJcbiAgICAgICAgICBdKVxyXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywndmlld05vZGVzJykgICAgICBcclxuICAgICAgICAgIC5maWxsKG5vZGVDb2xvcik7XHJcbiAgICAgICAgICBjb25zdCB5ID0gYm9keUhlaWdodCArIDI0O1xyXG4gICAgICAgICAgZmllbGQubW92ZSgwLCB5KTtcclxuICAgICAgICAgIHRoaXMuaW5wdXRHcm91cC5hZGQoZmllbGQpOyAgICBcclxuICAgICAgfSAgXHJcbiAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmZpZWxkR3JvdXA7XHJcbiAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICogY3JlYXRlIGNoaWxkcmVuIGJ1dHRvbiBmaWVsZFxyXG4gICAqIEByZXR1cm4gYnV0dG9uIGZpZWxkXHJcbiAgICovXHJcbiAgY3JlYXRlTm9kZXNCdXR0b25GaWVsZCh0eXBlLCBib2R5SGVpZ2h0LCBub2Rlcykge1xyXG4gICAgdGhpcy5maWVsZEdyb3VwID0gdGhpcy5kcmF3Lmdyb3VwKCk7XHJcbiAgICBpZih0eXBlID09PSAnd29ya2Zsb3cnIHx8IHR5cGUgPT09ICdwYXJhbWV0ZXJTdHVkeScgfHwgdHlwZSA9PT0gJ2ZvcicgfHwgdHlwZSA9PT0gJ3doaWxlJyB8fCB0eXBlID09PSAnZm9yZWFjaCcpe1xyXG4gICAgICBpZiggbm9kZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJub2RlcyBjaGVja1wiKTtcclxuICAgICAgICBjb25zdCB0aXRsZUhlaWdodCA9IDI0O1xyXG4gICAgICAgIGNvbnN0IHRpdGxld2lkdGggPSAyNTY7ICAgIFxyXG4gICAgICAgIGNvbnN0IG5vZGVDb2xvciA9IFwicmdiYSg2OCwgNjgsIDczLCAwLjUpXCI7XHJcbiAgICAgICAgY29uc3QgZmllbGQgPSAgdGhpcy5kcmF3XHJcbiAgICAgICAgICAucG9seWdvbihbXHJcbiAgICAgICAgICAgIFswLCAwXSxcclxuICAgICAgICAgICAgW3RpdGxld2lkdGgsIDBdLFxyXG4gICAgICAgICAgICBbdGl0bGV3aWR0aCwgdGl0bGVIZWlnaHRdLFxyXG4gICAgICAgICAgICBbMCwgdGl0bGVIZWlnaHRdLFxyXG4gICAgICAgICAgXSlcclxuICAgICAgICAgIC5maWxsKG5vZGVDb2xvcik7XHJcbiAgICBcclxuICAgICAgICAgIGNvbnN0IHkgPSBib2R5SGVpZ2h0O1xyXG4gICAgICAgICAgZmllbGQubW92ZSgwLCB5KTtcclxuICAgICAgICAgIHRoaXMuZmllbGRHcm91cC5hZGQoZmllbGQpOyBcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmZpZWxkR3JvdXA7XHJcbiAgfVxyXG5cclxuLyogICBjcmVhdGVOb2Rlc0J1dHRvbih0eXBlLCBib2R5SGVpZ2h0KSB7XHJcbiAgICB0aGlzLmJ1dHRvbkdyb3VwID0gdGhpcy5kcmF3Lmdyb3VwKCk7ICAgIFxyXG4gICAgaWYodHlwZSA9PT0gJ3dvcmtmbG93JyB8fCB0eXBlID09PSAncGFyYW1ldGVyU3R1ZHknIHx8IHR5cGUgPT09ICdmb3InIHx8IHR5cGUgPT09ICd3aGlsZScgfHwgdHlwZSA9PT0gJ2ZvcmVhY2gnKXsgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgIGNvbnN0IHN0YXRlUG9zWCA9IDIzMjtcclxuICAgIGNvbnN0IHN0YXRlUG9zWSA9IGJvZHlIZWlnaHQgKyA0O1xyXG4gICAgY29uc3Qgbm9kZUljb25QYXRoID0gXCIvaW1hZ2UvYnRuX29wZW5DbG9zZURfbi5wbmdcIjtcclxuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuZHJhd1xyXG4gICAgICAuaW1hZ2Uobm9kZUljb25QYXRoKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCd2aWV3QnV0dG9uJykgICAgICAgICAgICAgICAgICBcclxuICAgICAgLngoc3RhdGVQb3NYKVxyXG4gICAgICAueShzdGF0ZVBvc1kpO1xyXG4gICAgICB0aGlzLmJ1dHRvbkdyb3VwLmFkZChidXR0b24pOyAgICAgICAgICAgIFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuYnV0dG9uR3JvdXA7XHJcbiAgfSAqL1xyXG5cclxuICAvKipcclxuICAgKiBjcmVhdGUgbm9kZXNcclxuICAgKiBAcmV0dXJuIG5vZGVzXHJcbiAgICovXHJcbiAgY3JlYXRlTm9kZXModHlwZSwgbm9kZXMpIHtcclxuICAgIHRoaXMubm9kZUdyb3VwID0gdGhpcy5kcmF3Lmdyb3VwKCk7XHJcbiAgICBjb25zb2xlLmxvZyhub2Rlcyk7XHJcbiAgICBjb25zb2xlLmxvZyh0eXBlKTtcclxuICAgIFxyXG4gICAgaWYodHlwZSA9PT0gJ3dvcmtmbG93JyB8fCB0eXBlID09PSAncGFyYW1ldGVyU3R1ZHknIHx8IHR5cGUgPT09ICdmb3InIHx8IHR5cGUgPT09ICd3aGlsZScgfHwgdHlwZSA9PT0gJ2ZvcmVhY2gnKXsgICAgICAgICAgICAgXHJcbiAgICAgIG5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBub2RlQ29sb3IgPSBjb25maWcubm9kZV9jb2xvcltub2RlLnR5cGVdO1xyXG4gICAgICAgICAgY29uc3Qgbm9kZUljb25QYXRoID0gY29uZmlnLm5vZGVfaWNvbltub2RlLnR5cGVdOyAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IG5vZGVQb3NYID0gbm9kZS5wb3MueCAvIDEwO1xyXG4gICAgICAgICAgY29uc3Qgbm9kZVBvc1kgPSAzMiArIG5vZGUucG9zLnkgLyAxMDtcclxuICAgICAgICAgIGNvbnN0IGNvcnJlY3ROb2RlSWNvblBhdGggPSBub2RlSWNvblBhdGgucmVwbGFjZShcIi5wbmdcIixcIl9wLnBuZ1wiKTsgXHJcbiAgICAgICAgICBjb25zdCBpbWcgPSB0aGlzLmRyYXdcclxuICAgICAgICAgICAgLmltYWdlKGNvcnJlY3ROb2RlSWNvblBhdGgpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ3ZpZXdOb2RlcycpICAgICAgICAgIFxyXG4gICAgICAgICAgICAuZmlsbChub2RlQ29sb3IpO1xyXG4gICAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gMjQ7XHJcbiAgICAgICAgICBjb25zdCB4ID0gbm9kZVBvc1g7XHJcbiAgICAgICAgICBjb25zdCB5ID0gbm9kZVBvc1kgKyAyNDtcclxuICBcclxuICAgICAgICAgIGlmKCB4ID4gMjMyIHx8IHkgPiAxMzQpe1xyXG4gICAgICAgICAgICBpZih4ID4gMjMyICYmIHkgPCAxMzQpe1xyXG4gICAgICAgICAgICAgIGltZy5tb3ZlKDIzMiwgeSk7ICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoeCA8IDIzMiAmJiB5ID4gMTM0KXtcclxuICAgICAgICAgICAgICBpbWcubW92ZSh4LCAxMzQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgaWYoeCA+IDIzMiAmJiB5ID4gMTM0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgaW1nLm1vdmUoMjMyLCAxMzQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGltZy5tb3ZlKHgsIHkpOyAgICAgICAgXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLm5vZGVHcm91cC5hZGQoaW1nKTtcclxuICAgICAgICBcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyhcInJldHVyblwiKTtcclxuICAgIHJldHVybiB0aGlzLm5vZGVHcm91cDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSBjaGlsZHJlbiBpY29uIGZpZWxkXHJcbiAgICogQHJldHVybiBidXR0b24gZmllbGRcclxuICAgKi9cclxuICBjcmVhdGVOb2Rlc0ljb25GaWVsZCh0eXBlLCBub2Rlcykge1xyXG4gICAgdGhpcy5pY29uRmllbGRHcm91cCA9IHRoaXMuZHJhdy5ncm91cCgpO1xyXG4gICAgaWYodHlwZSA9PT0gJ3dvcmtmbG93JyB8fCB0eXBlID09PSAncGFyYW1ldGVyU3R1ZHknIHx8IHR5cGUgPT09ICdmb3InIHx8IHR5cGUgPT09ICd3aGlsZScgfHwgdHlwZSA9PT0gJ2ZvcmVhY2gnKXtcclxuICAgICAgbm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHsgICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGljb25GaWVsZEhlaWdodCA9IDI0O1xyXG4gICAgICAgIGNvbnN0IGljb25UaXRsZXdpZHRoID0gMjQ7XHJcbiAgICAgICAgY29uc3Qgbm9kZUNvbG9yID0gY29uZmlnLm5vZGVfY29sb3Jbbm9kZS50eXBlXTtcclxuICAgICAgICBjb25zdCBub2RlUG9zWCA9IG5vZGUucG9zLnggLyAxMDtcclxuICAgICAgICBjb25zdCBub2RlUG9zWSA9IDMyICsgbm9kZS5wb3MueSAvIDEwO1xyXG4gICAgICAgIGNvbnN0IGljb25GaWVsZCA9ICB0aGlzLmRyYXdcclxuXHJcbiAgICAgICAgLnBvbHlnb24oW1xyXG4gICAgICAgICAgWzAsIDBdLFxyXG4gICAgICAgICAgW2ljb25UaXRsZXdpZHRoLCAwXSxcclxuICAgICAgICAgIFtpY29uVGl0bGV3aWR0aCwgaWNvbkZpZWxkSGVpZ2h0XSxcclxuICAgICAgICAgIFswLCBpY29uRmllbGRIZWlnaHRdLFxyXG4gICAgICAgIF0pXHJcbiAgICAgICAgLmZpbGwobm9kZUNvbG9yKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsJ3ZpZXdOb2RlcycpOyAgICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCB4ID0gbm9kZVBvc1g7XHJcbiAgICAgICAgY29uc3QgeSA9IG5vZGVQb3NZICsgMjQ7XHJcblxyXG4gICAgICAgIGlmKCB4ID4gMjMyIHx8IHkgPiAxMzQpe1xyXG4gICAgICAgICAgaWYoeCA+IDIzMiAmJiB5IDwgMTM0KXtcclxuICAgICAgICAgICAgaWNvbkZpZWxkLm1vdmUoMjMyLCB5KTsgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmKHggPCAyMzIgJiYgeSA+IDEzNCl7XHJcbiAgICAgICAgICAgIGljb25GaWVsZC5tb3ZlKHgsIDEzNCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgfSBcclxuICAgICAgICAgIGlmKHggPiAyMzIgJiYgeSA+IDEzNClcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgaWNvbkZpZWxkLm1vdmUoMjMyLCAxMzQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGljb25GaWVsZC5tb3ZlKHgsIHkpOyAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZmllbGRHcm91cC5hZGQoaWNvbkZpZWxkKTsgICAgICBcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmZpZWxkR3JvdXA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBjcmVhdGUgc3RhdGVcclxuICAgKiBAcmV0dXJuIHN0YXRlIGVsZW1lbnRcclxuICAgKi9cclxuICBjcmVhdGVTdGF0ZSh0eXBlLCBzdGF0ZSwgbnVtVG90YWwsIG51bUZpbmlzaGVkLCBudW1GYWlsZWQpIHtcclxuICAgIGNvbnN0IHN0YXRlUG9zWCA9IDIyMDtcclxuICAgIGNvbnN0IHN0YXRlUG9zWSA9IDA7XHJcbiAgICBjb25zdCBwYXJhU3R1UG9zWCA9IDEyMDtcclxuICAgIGNvbnN0IG5vZGVTdGF0ZVBhdGggPSBjb25maWcuc3RhdGVfaWNvbltzdGF0ZV07XHJcbiAgICBjb25zdCBwYXJhU3R1U3RhdGUgPSBcIkZpbjpcIitudW1GaW5pc2hlZCtcIkZhaWw6XCIrbnVtRmFpbGVkK1wiKFwiK251bVRvdGFsK1wiKVwiO1xyXG4gICAgaWYodHlwZSA9PT0gJ3BhcmFtZXRlclN0dWR5JyAmJiBzdGF0ZSA9PT0gJ3J1bm5pbmcnKXtcclxuICAgICAgcmV0dXJuIHRoaXMuZHJhdyAgICAgIFxyXG4gICAgICAudGV4dChwYXJhU3R1U3RhdGUpXHJcbiAgICAgIC5maWxsKCcjRkZGRkZGJylcclxuICAgICAgLngocGFyYVN0dVBvc1gpXHJcbiAgICAgIC55KHN0YXRlUG9zWSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5kcmF3XHJcbiAgICAgIC5pbWFnZShub2RlU3RhdGVQYXRoKVxyXG4gICAgICAuZmlsbCgnI0ZGRkZGRicpXHJcbiAgICAgIC54KHN0YXRlUG9zWClcclxuICAgICAgLnkoc3RhdGVQb3NZKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gICAvKipcclxuICAgKiBjcmVhdGUgc3RhdGVcclxuICAgKiBAcmV0dXJuIHN0YXRlIGVsZW1lbnRcclxuICAgKi9cclxuICBjcmVhdGVQYXJhU3R1U3RhdGUobnVtVG90YWwsIG51bUZpbmlzaGVkLCBudW1GYWlsZWQpIHtcclxuICAgIGNvbnN0IHN0YXRlUG9zWCA9IDEyMDtcclxuICAgIGNvbnN0IHN0YXRlUG9zWSA9IDA7XHJcbiAgICBjb25zdCBwYXJhU3R1U3RhdGUgPSBcIkZpbjpcIisyMCtcIkZhaWw6XCIrbnVtRmFpbGVkK1wiKFwiK251bVRvdGFsK1wiKVwiO1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhd1xyXG4gICAgICAudGV4dChwYXJhU3R1U3RhdGUpXHJcbiAgICAgIC5maWxsKCcjMTExJylcclxuICAgICAgLngoc3RhdGVQb3NYKVxyXG4gICAgICAueShzdGF0ZVBvc1kpO1xyXG4gIH1cclxuXHJcbiAgICAvKipcclxuICAgKiBjcmVhdGUgd29ya2Zsb3cgY29tcG9uZW50IGljb25cclxuICAgKiBAcmV0dXJuIGljb25cclxuICAgKi9cclxuICBjcmVhdGVJY29uSW1hZ2UodHlwZSkge1xyXG4gICAgLy/ku4rjga/msbrjgoHmiZPjgaHjgafpganlvZPjgavoqK3lrppcclxuICAgIGNvbnN0IHN0YXRlUG9zWCA9IDg7XHJcbiAgICBjb25zdCBzdGF0ZVBvc1kgPSAwO1xyXG4gICAgY29uc3Qgbm9kZUljb25QYXRoID0gY29uZmlnLm5vZGVfaWNvblt0eXBlXTsgICAgXHJcbiAgICByZXR1cm4gdGhpcy5kcmF3XHJcbiAgICAgIC8vLnRleHQodGFza1N0YXRlKVxyXG4gICAgICAuaW1hZ2Uobm9kZUljb25QYXRoKVxyXG4gICAgICAuZmlsbCgnIzExMScpXHJcbiAgICAgIC54KHN0YXRlUG9zWClcclxuICAgICAgLnkoc3RhdGVQb3NZKTtcclxuICB9XHJcblxyXG59XHJcblxyXG5jbGFzcyBTdmdQYXJlbnRGaWxlc0JveCB7XHJcbiAgY29uc3RydWN0b3Ioc3ZnLCB4LCB5LCB0eXBlLCBuYW1lLCBpbnB1dEZpbGVzLCBvdXRwdXRGaWxlcykge1xyXG4gICAgdGhpcy5kcmF3ID0gc3ZnO1xyXG4gICAgdGhpcy50eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gY29uZmlnLmJveF9hcHBlYXJhbmNlLnRpdGxlSGVpZ2h0O1xyXG4gICAgY29uc3QgdGl0bGVXaWR0aCA9IGNvbmZpZy5ib3hfYXBwZWFyYW5jZS50aXRsZVdpZHRoO1xyXG4gICAgY29uc3Qgb3BhY2l0eSA9IGNvbmZpZy5ib3hfYXBwZWFyYW5jZS5vcGFjaXR5O1xyXG4gICAgY29uc3Qgb3V0cHV0VGV4dE9mZnNldCA9IGNvbmZpZy5ib3hfYXBwZWFyYW5jZS5vdXRwdXRUZXh0T2Zmc2V0O1xyXG5cclxuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5jcmVhdGVJbnB1dFRleHQoaW5wdXRGaWxlcyk7XHJcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmNyZWF0ZU91dHB1dFRleHQob3V0cHV0RmlsZXMpO1xyXG5cclxuICAgIGNvbnN0IG91dHB1dEJCb3ggPSBvdXRwdXQuYmJveCgpO1xyXG4gICAgY29uc3QgaW5wdXRCQm94ID0gaW5wdXQuYmJveCgpO1xyXG5cclxuICAgIGNvbnN0IGJvZHlIZWlnaHQgPSB0aXRsZUhlaWdodCArIE1hdGguY2VpbChNYXRoLm1heChpbnB1dEJCb3guaGVpZ2h0LCBvdXRwdXRCQm94LmhlaWdodCkpO1xyXG4gICAgXHJcbiAgICB0aGlzLmhlaWdodCA9IGJvZHlIZWlnaHQgKyB0aXRsZUhlaWdodDtcclxuICAgIHRoaXMud2lkdGggPSAyNTY7XHJcblxyXG4gICAgdGhpcy5ib3ggPSB0aGlzLmRyYXcuZ3JvdXAoKTtcclxuICAgIHRoaXMuYm94XHJcbiAgICAgIC5hZGQoaW5wdXQpXHJcbiAgICAgIC5hZGQob3V0cHV0KVxyXG4gICAgICAubW92ZSh4LCB5KVxyXG4gICAgICAuc3R5bGUoJ2N1cnNvcicsICdkZWZhdWx0JylcclxuICAgICAgLm9wYWNpdHkob3BhY2l0eSlcclxuICAgICAgLmFkZENsYXNzKCdib3gnKTtcclxuICAgICAgXHJcbiAgICAvLyBhZGp1c3Qgc2l6ZVxyXG4gICAgb3V0cHV0LngodGl0bGVXaWR0aCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBjcmVhdGUgb3V0cHV0IGZpbGUgdGV4dFxyXG4gICAqIEByZXR1cm4gb3V0cHV0IGZpbGUgdGV4dFxyXG4gICAqL1xyXG4gIGNyZWF0ZU91dHB1dFRleHQob3V0cHV0RmlsZXMpIHtcclxuICAgIHRoaXMub3V0cHV0R3JvdXAgPSB0aGlzLmRyYXcuZ3JvdXAoKTtcclxuICAgIG91dHB1dEZpbGVzLmZvckVhY2goKG91dHB1dCwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgdGV4dCA9IHRoaXMuZHJhd1xyXG4gICAgICAgIC50ZXh0KG91dHB1dC5uYW1lKVxyXG4gICAgICAgIC5maWxsKCcjRkZGRkZGJyk7XHJcbiAgICAgIHRoaXMudGV4dEhlaWdodCA9IHRleHQuYmJveCgpLmhlaWdodCAqIGNvbmZpZy5ib3hfYXBwZWFyYW5jZS50ZXh0SGVpZ2h0U2NhbGU7XHJcblxyXG4gICAgICAvLyBjb25zdCB4ID0gLXRleHQuYmJveCgpLndpZHRoIC0gY29uZmlnLmJveF9hcHBlYXJhbmNlLm91dHB1dFRleHRPZmZzZXQ7XHJcbiAgICAgIC8vIGNvbnN0IHkgPSBjYWxjRmlsZUJhc2VQb3NZKCkgKyB0aGlzLnRleHRIZWlnaHQgKiBpbmRleDtcclxuICAgICAgY29uc3QgeCA9IDYzMjtcclxuICAgICAgLy9jb25zdCB5ID0gODcwKyB0aGlzLnRleHRIZWlnaHQgKiBpbmRleDtcclxuICAgICAgY29uc3QgeSA9IDgzMCArIDQwICogaW5kZXg7ICAgICAgXHJcbiAgICAgIHRleHQubW92ZSh4LCB5KTtcclxuICAgICAgdGhpcy5vdXRwdXRHcm91cC5hZGQodGV4dCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLm91dHB1dEdyb3VwO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBjcmVhdGUgaW5wdXQgZmlsZSB0ZXh0XHJcbiAgICogQHJldHVybiBpbnB1dCBmaWxlIHRleHRcclxuICAgKi9cclxuICBjcmVhdGVJbnB1dFRleHQoaW5wdXRGaWxlcykge1xyXG4gICAgdGhpcy5pbnB1dEdyb3VwID0gdGhpcy5kcmF3Lmdyb3VwKCk7XHJcbiAgICBpbnB1dEZpbGVzLmZvckVhY2goKGlucHV0LCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCB0ZXh0ID0gdGhpcy5kcmF3XHJcbiAgICAgICAgLnRleHQoaW5wdXQubmFtZSlcclxuICAgICAgICAuZmlsbCgnI0ZGRkZGRicpO1xyXG4gICAgICAvL3RoaXMudGV4dEhlaWdodCA9IHRleHQuYmJveCgpLmhlaWdodCAqIGNvbmZpZy5ib3hfYXBwZWFyYW5jZS50ZXh0SGVpZ2h0U2NhbGU7XHJcbiAgICAgIHRoaXMudGV4dEhlaWdodCA9IDI0O1xyXG4gICAgICBjb25zdCB4ID0gY29uZmlnLmJveF9hcHBlYXJhbmNlLmlucHV0VGV4dE5hbWVQb3NYO1xyXG4gICAgICAvL2NvbnN0IHkgPSA2NCArIHRoaXMudGV4dEhlaWdodCAqIGluZGV4O1xyXG4gICAgICBjb25zdCB5ID0gNTQgKyA0MCAqIGluZGV4O1xyXG5cclxuICAgICAgdGV4dC5tb3ZlKHgsIHkpO1xyXG4gICAgICB0aGlzLmlucHV0R3JvdXAuYWRkKHRleHQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5pbnB1dEdyb3VwO1xyXG4gIH1cclxuXHJcblxyXG59XHJcblxyXG4vL3BsdWdcclxuZnVuY3Rpb24gY3JlYXRlTENQbHVnQW5kQ2FibGUoc3ZnLCBvcmlnaW5YLCBvcmlnaW5ZLCBtb3ZlWSwgY29sb3IsIHBsdWdTaGFwZSwgY2FibGVEaXJlY3Rpb24sIGNvdW50ZXJwYXJ0LCBjYWxsYmFjaykge1xyXG4gIC8vcGx1Z+OBruS9jee9ru+8iG9yaWdpblgsb3JpZ2luWe+8ieOCkuaxuuOCgeOCi1xyXG4gIGxldCBwbHVnID0gc3ZnLnBvbHlnb24ocGx1Z1NoYXBlKS5maWxsKGNvbG9yKTtcclxuICBjb25zdCBiYm94ID0gcGx1Zy5iYm94KCk7XHJcbiAgLy9vcmlnaW5YIC09IGJib3gud2lkdGggLyAyOyBSUGx1Z+OBr+W9semfv+OBquOBlyBcclxuICBpZiAobW92ZVkpIG9yaWdpblggLT0gYmJveC53aWR0aCAvIDI7Ly9sb3dlcuOBruOBqOOBjVxyXG4gIC8vaWYgKG1vdmVZKSBvcmlnaW5ZIC09IGJib3guaGVpZ2h0IC8gMjsgUlBsdWfjga/lvbHpn7/jgarjgZcgXHJcbiAgcGx1Zy5tb3ZlKG9yaWdpblgsIG9yaWdpblkpLmRyYWdnYWJsZSgpO1xyXG4gIGNvbnN0IGNhYmxlID0gbmV3IFN2Z0NhYmxlKHN2ZywgY29sb3IsIGNhYmxlRGlyZWN0aW9uLCBvcmlnaW5YICsgYmJveC53aWR0aCAvIDIsIG9yaWdpblkgKyBiYm94LmhlaWdodCAvIDIpO1xyXG4gIGxldCBmaXJzdFRpbWUgPSB0cnVlO1xyXG4gIGxldCBjbG9uZSA9IG51bGw7XHJcbiAgbGV0IGRyYWdTdGFydFBvaW50WCA9IG51bGw7XHJcbiAgbGV0IGRyYWdTdGFydFBvaW50WSA9IG51bGw7XHJcbiAgcGx1Z1xyXG4gICAgLm9uKCdkcmFnc3RhcnQnLCAoZSkgPT4ge1xyXG4gICAgICBpZiAoZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgY2xvbmUgPSBwbHVnLmNsb25lKCk7XHJcbiAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgZHJhZ1N0YXJ0UG9pbnRYID0gZS5kZXRhaWwucC54O1xyXG4gICAgICBkcmFnU3RhcnRQb2ludFkgPSBlLmRldGFpbC5wLnk7XHJcbiAgICB9KVxyXG4gICAgLm9uKCdkcmFnbW92ZScsIChlKSA9PiB7XHJcbiAgICAgIGxldCBkeCA9IGUuZGV0YWlsLnAueCAtIGRyYWdTdGFydFBvaW50WDtcclxuICAgICAgbGV0IGR5ID0gZS5kZXRhaWwucC55IC0gZHJhZ1N0YXJ0UG9pbnRZO1xyXG4gICAgICBjYWJsZS5kcmFnRW5kUG9pbnQoZHgsIGR5KTtcclxuICAgIH0pXHJcbiAgICAub24oJ2RyYWdlbmQnLCAoZSkgPT4ge1xyXG4gICAgICBjYWJsZS5lbmRYID0gZS50YXJnZXQuaW5zdGFuY2UueCgpO1xyXG4gICAgICBjYWJsZS5lbmRZID0gZS50YXJnZXQuaW5zdGFuY2UueSgpO1xyXG4gICAgICBjb25zdCBbaGl0SW5kZXgsIGhpdFBsdWddID0gY29sbGlzaW9uRGV0ZWN0aW9uKHN2ZywgY291bnRlcnBhcnQsIGNhYmxlLmVuZFgsIGNhYmxlLmVuZFkpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIltoaXRJbmRleCwgaGl0UGx1Z11cIik7ICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGhpdEluZGV4KTtcclxuICAgICAgY29uc29sZS5sb2coaGl0UGx1Zyk7XHJcbiAgICAgIGlmIChoaXRJbmRleCA9PT0gLTEpIHJldHVybjtcclxuICAgICAgY29uc3QgbXlJbmRleCA9IHBsdWcucGFyZW50KCkubm9kZS5pbnN0YW5jZS5kYXRhKCdpbmRleCcpO1xyXG4gICAgICBjb25zb2xlLmxvZyhteUluZGV4KTtcclxuICAgICAgXHJcbiAgICAgIGlmIChoaXRJbmRleCAhPT0gbXlJbmRleCkge1xyXG4gICAgICAgIGNhbGxiYWNrKG15SW5kZXgsIGhpdEluZGV4LCBwbHVnLCBoaXRQbHVnKTtcclxuICAgICAgfVxyXG4gICAgICBjYWJsZS5yZW1vdmUoKTtcclxuICAgICAgcGx1Zy5yZW1vdmUoKTtcclxuICAgICAgcGx1ZyA9IGNsb25lXHJcbiAgICB9KTtcclxuICByZXR1cm4gW3BsdWcsIGNhYmxlLmNhYmxlXTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUGFyZW50Q1BsdWdBbmRDYWJsZShzdmcsIG9yaWdpblgsIG9yaWdpblksIG1vdmVZLCBjb2xvciwgcGx1Z1NoYXBlLCBjYWJsZURpcmVjdGlvbiwgY291bnRlcnBhcnQsIGNhbGxiYWNrKSB7XHJcbiAgLy9wbHVn44Gu5L2N572u77yIb3JpZ2luWCxvcmlnaW5Z77yJ44KS5rG644KB44KLXHJcbiAgbGV0IHBsdWcgPSBzdmcucG9seWdvbihwbHVnU2hhcGUpLmZpbGwoY29sb3IpO1xyXG4gIGNvbnNvbGUubG9nKFwicGx1Z1wiKTsgIFxyXG4gIGNvbnNvbGUubG9nKHBsdWcpO1xyXG4gIGNvbnN0IGJib3ggPSBwbHVnLmJib3goKTtcclxuICBpZiAobW92ZVkpIG9yaWdpblggLT0gYmJveC53aWR0aCAvIDI7XHJcbiAgcGx1Zy5tb3ZlKG9yaWdpblgsIG9yaWdpblkpLmRyYWdnYWJsZSgpO1xyXG4gIGNvbnN0IGNhYmxlID0gbmV3IFN2Z0NhYmxlKHN2ZywgY29sb3IsIGNhYmxlRGlyZWN0aW9uLCBvcmlnaW5YICsgYmJveC53aWR0aCAvIDIsIG9yaWdpblkgKyBiYm94LmhlaWdodCAvIDIpO1xyXG4gIGxldCBmaXJzdFRpbWUgPSB0cnVlO1xyXG4gIGxldCBjbG9uZSA9IG51bGw7XHJcbiAgbGV0IGRyYWdTdGFydFBvaW50WCA9IG51bGw7XHJcbiAgbGV0IGRyYWdTdGFydFBvaW50WSA9IG51bGw7XHJcbiAgcGx1Z1xyXG4gICAgLm9uKCdkcmFnc3RhcnQnLCAoZSkgPT4ge1xyXG4gICAgICBpZiAoZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgY2xvbmUgPSBwbHVnLmNsb25lKCk7XHJcbiAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgZHJhZ1N0YXJ0UG9pbnRYID0gZS5kZXRhaWwucC54O1xyXG4gICAgICBkcmFnU3RhcnRQb2ludFkgPSBlLmRldGFpbC5wLnk7XHJcbiAgICB9KVxyXG4gICAgLm9uKCdkcmFnbW92ZScsIChlKSA9PiB7XHJcbiAgICAgIGxldCBkeCA9IGUuZGV0YWlsLnAueCAtIGRyYWdTdGFydFBvaW50WDtcclxuICAgICAgbGV0IGR5ID0gZS5kZXRhaWwucC55IC0gZHJhZ1N0YXJ0UG9pbnRZO1xyXG4gICAgICBjYWJsZS5kcmFnRW5kUG9pbnQoZHgsIGR5KTtcclxuICAgIH0pXHJcbiAgICAub24oJ2RyYWdlbmQnLCAoZSkgPT4ge1xyXG4gICAgICBjYWJsZS5lbmRYID0gZS50YXJnZXQuaW5zdGFuY2UueCgpO1xyXG4gICAgICBjYWJsZS5lbmRZID0gZS50YXJnZXQuaW5zdGFuY2UueSgpO1xyXG4gICAgICBjb25zdCBbaGl0SW5kZXgsIGhpdFBsdWddID0gY29sbGlzaW9uRGV0ZWN0aW9uKHN2ZywgY291bnRlcnBhcnQsIGNhYmxlLmVuZFgsIGNhYmxlLmVuZFkpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIltoaXRJbmRleCwgaGl0UGx1Z11cIik7XHJcbiAgICAgIGNvbnNvbGUubG9nKGhpdEluZGV4KTtcclxuICAgICAgY29uc29sZS5sb2coaGl0UGx1Zyk7XHJcbiAgICAgIGlmIChoaXRJbmRleCA9PT0gLTEpIHJldHVybjtcclxuICAgICAgY29uc3QgbXlJbmRleCA9IFwicGFyZW50XCI7XHJcbiAgICAgIC8vY29uc3QgbXlJbmRleCA9IHBsdWcucGFyZW50KCkubm9kZS5pbnN0YW5jZS5kYXRhKCdpbmRleCcpO1xyXG4gICAgICBjb25zb2xlLmxvZyhteUluZGV4KTtcclxuICAgICAgaWYgKGhpdEluZGV4ICE9PSBteUluZGV4KSB7XHJcbiAgICAgICAgY2FsbGJhY2sobXlJbmRleCwgaGl0SW5kZXgsIHBsdWcsIGhpdFBsdWcpO1xyXG4gICAgICB9XHJcbiAgICAgIGNhYmxlLnJlbW92ZSgpO1xyXG4gICAgICBwbHVnLnJlbW92ZSgpO1xyXG4gICAgICBwbHVnID0gY2xvbmVcclxuICAgIH0pO1xyXG4gIHJldHVybiBbcGx1ZywgY2FibGUuY2FibGVdO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxvd2VyKHN2Zywgb3JpZ2luWCwgb3JpZ2luWSwgb2Zmc2V0WCwgb2Zmc2V0WSwgY29sb3IsIHNpbykge1xyXG4gIHJldHVybiBjcmVhdGVMQ1BsdWdBbmRDYWJsZShzdmcsIG9yaWdpblggKyBvZmZzZXRYLCBvcmlnaW5ZICsgb2Zmc2V0WSwgdHJ1ZSwgY29sb3IsIERQbHVnLCAnRFUnLCAnLnVwcGVyUGx1ZycsIGZ1bmN0aW9uIChteUluZGV4LCBoaXRJbmRleCwgcGx1Zykge1xyXG4gICAgc2lvLmVtaXQoJ2FkZExpbmsnLCB7IHNyYzogbXlJbmRleCwgZHN0OiBoaXRJbmRleCwgaXNFbHNlOiBwbHVnLmhhc0NsYXNzKCdlbHNlUGx1ZycpIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29ubmVjdG9yKHN2Zywgb3JpZ2luWCwgb3JpZ2luWSwgb2Zmc2V0WCwgb2Zmc2V0WSwgc2lvKSB7XHJcbiAgb2Zmc2V0WSArPSBjYWxjRmlsZUJhc2VQb3NZKCk7XHJcbiAgcmV0dXJuIGNyZWF0ZUxDUGx1Z0FuZENhYmxlKHN2Zywgb3JpZ2luWCArIG9mZnNldFgsIG9yaWdpblkgKyBvZmZzZXRZLCBmYWxzZSwgY29uZmlnLnBsdWdfY29sb3IuZmlsZSwgUlBsdWcsICdSTCcsICcucmVjZXB0b3JQbHVnJywgZnVuY3Rpb24gKG15SW5kZXgsIGhpdEluZGV4LCBwbHVnLCBoaXRQbHVnKSB7XHJcbiAgICBsZXQgc3JjTmFtZSA9IHBsdWcuZGF0YSgnbmFtZScpO1xyXG4gICAgbGV0IGRzdE5hbWUgPSBoaXRQbHVnLmRhdGEoJ25hbWUnKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhteUluZGV4KTtcclxuICAgIGNvbnNvbGUubG9nKGhpdEluZGV4KTtcclxuICAgIHNpby5lbWl0KCdhZGRGaWxlTGluaycsIHsgc3JjOiBteUluZGV4LCBkc3Q6IGhpdEluZGV4LCBzcmNOYW1lOiBzcmNOYW1lLCBkc3ROYW1lOiBkc3ROYW1lIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVjZXB0b3Ioc3ZnLCBvcmlnaW5YLCBvcmlnaW5ZLCBvZmZzZXRYLCBvZmZzZXRZKSB7XHJcbiAgY29uc3QgcGx1ZyA9IHN2Zy5wb2x5Z29uKExQbHVnKS5maWxsKGNvbmZpZy5wbHVnX2NvbG9yLmZpbGUpLmFkZENsYXNzKCdyZWNlcHRvclBsdWcnKTtcclxuICBjb25zdCBiYm94ID0gcGx1Zy5iYm94KCk7XHJcbiAgcGx1Zy5tb3ZlKG9yaWdpblggKyBvZmZzZXRYIC0gYmJveC53aWR0aCwgb3JpZ2luWSArIG9mZnNldFkgKyBjYWxjRmlsZUJhc2VQb3NZKCkpO1xyXG4gIHJldHVybiBwbHVnO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVXBwZXIoc3ZnLCBvcmlnaW5YLCBvcmlnaW5ZLCBvZmZzZXRYLCBvZmZzZXRZKSB7XHJcbiAgY29uc3QgcGx1ZyA9IHN2Zy5wb2x5Z29uKFVQbHVnKS5maWxsKGNvbmZpZy5wbHVnX2NvbG9yLmZsb3cpLmFkZENsYXNzKCd1cHBlclBsdWcnKTtcclxuICBjb25zdCBiYm94ID0gcGx1Zy5iYm94KCk7XHJcbiAgcGx1Zy5tb3ZlKG9yaWdpblggKyBvZmZzZXRYIC0gYmJveC53aWR0aCAvIDIsIG9yaWdpblkgKyBvZmZzZXRZIC0gYmJveC5oZWlnaHQpO1xyXG4gIHJldHVybiBwbHVnO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQm94KHN2ZywgeCwgeSwgdHlwZSwgbmFtZSwgaW5wdXRGaWxlcywgb3V0cHV0RmlsZXMsIHN0YXRlLCBub2RlcywgbnVtVG90YWwsIG51bUZpbmlzaGVkLCBudW1GYWlsZWQpIHtcclxuICBjb25zdCBib3ggPSBuZXcgU3ZnQm94KHN2ZywgeCwgeSwgdHlwZSwgbmFtZSwgaW5wdXRGaWxlcywgb3V0cHV0RmlsZXMsIHN0YXRlLCBub2RlcywgbnVtVG90YWwsIG51bUZpbmlzaGVkLCBudW1GYWlsZWQpO1xyXG4gIHJldHVybiBbYm94LmJveCwgYm94LnRleHRIZWlnaHRdO1xyXG59XHJcblxyXG4vL3BhcmVudCAtIGNoaWxkcmVuIHJlbGF0aW9uIFxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRmlsZXNOYW1lQm94KHN2ZywgeCwgeSwgdHlwZSwgbmFtZSwgaW5wdXRGaWxlcywgb3V0cHV0RmlsZXMpIHtcclxuICBjb25zdCBib3ggPSBuZXcgU3ZnUGFyZW50RmlsZXNCb3goc3ZnLCB4LCB5LCB0eXBlLCBuYW1lLCBpbnB1dEZpbGVzLCBvdXRwdXRGaWxlcyk7XHJcbiAgcmV0dXJuIFtib3guYm94LCBib3gudGV4dEhlaWdodF07XHJcbn1cclxuXHJcbi8vcGFyZW50IC0+IGNoaWxkcmVuIGNvbm5lY3RvclxyXG4vL+S9jee9ruOBruS/ruato+OBjOW/heimgVxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGFyZW50Q29ubmVjdG9yKHN2Zywgb3JpZ2luWCwgb3JpZ2luWSwgb2Zmc2V0WCwgb2Zmc2V0WSwgc2lvKSB7XHJcbiAgb2Zmc2V0WSArPSBjYWxjRmlsZUJhc2VQb3NZKCk7XHJcbiAgcmV0dXJuIGNyZWF0ZVBhcmVudENQbHVnQW5kQ2FibGUoc3ZnLCBvcmlnaW5YICsgb2Zmc2V0WCwgb3JpZ2luWSArIG9mZnNldFksIGZhbHNlLCBjb25maWcucGx1Z19jb2xvci5maWxlLCBwYXJlbnRMUGx1ZywgJ1JMJywgJy5yZWNlcHRvclBsdWcnLCBmdW5jdGlvbiAobXlJbmRleCwgaGl0SW5kZXgsIHBsdWcsIGhpdFBsdWcpIHtcclxuICAgIGxldCBzcmNOYW1lID0gcGx1Zy5kYXRhKCduYW1lJyk7XHJcbiAgICBsZXQgZHN0TmFtZSA9IGhpdFBsdWcuZGF0YSgnbmFtZScpO1xyXG4gICAgY29uc29sZS5sb2cobXlJbmRleCk7XHJcbiAgICBjb25zb2xlLmxvZyhoaXRJbmRleCk7XHJcbiAgICBjb25zb2xlLmxvZyhzcmNOYW1lKTtcclxuICAgIGNvbnNvbGUubG9nKGRzdE5hbWUpO1xyXG4gICAgc2lvLmVtaXQoJ2FkZEZpbGVMaW5rJywgeyBzcmM6IG15SW5kZXgsIGRzdDogaGl0SW5kZXgsIHNyY05hbWU6IHNyY05hbWUsIGRzdE5hbWU6IGRzdE5hbWUgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vY2hpbGRyZW4gLT4gcGFyZW50IGNvbm5lY3RvclxyXG4vL+S9jee9ruOBruS/ruato+OBjOW/heimgVxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGFyZW50UmVjZXB0b3Ioc3ZnLCBvcmlnaW5YLCBvcmlnaW5ZLCBvZmZzZXRYLCBvZmZzZXRZKSB7XHJcbiAgY29uc3QgcGx1ZyA9IHN2Zy5wb2x5Z29uKHBhcmVudFJQbHVnKS5maWxsKGNvbmZpZy5wbHVnX2NvbG9yLmZpbGUpLmFkZENsYXNzKCdyZWNlcHRvclBsdWcnKTtcclxuICBjb25zdCBiYm94ID0gcGx1Zy5iYm94KCk7XHJcbiAgcGx1Zy5tb3ZlKDkwMCwgb3JpZ2luWSArIG9mZnNldFkgKyBjYWxjRmlsZUJhc2VQb3NZKCkpO1xyXG4gIC8vcGx1Zy5tb3ZlKG9yaWdpblggKyBvZmZzZXRYIC0gYmJveC53aWR0aCAvIDIsIG9yaWdpblkgKyBvZmZzZXRZICsgY2FsY0ZpbGVCYXNlUG9zWSgpKTtcclxuICByZXR1cm4gcGx1ZztcclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL3NyYy9qcy9zdmdQYXJ0cy5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///54\n");

/***/ })

},[52]);